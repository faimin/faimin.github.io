
<!DOCTYPE html>
<html lang="zh-cn" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zero.D.Saber&#39;s Home - 困于心，衡于虑，而后作</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Zero.D.Saber, iOS, Swift, Objective-C,"> 
    <meta name="description" content="记录点滴,
C &amp;amp;&amp;amp; Objective-C代码技巧 


1. GNU C的赋值扩展：即使用`({...})`的形式。这种形式的语句可以类似很多脚本语言，在顺次执行之后，会将最后一次的表达式,"> 
    <meta name="author" content="Zero.D.Saber"> 
    <link rel="alternative" href="atom.xml" title="Zero.D.Saber&#39;s Home" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8691406134231910",
        enable_page_level_ads: true
      });
    </script>

</head>

<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">解读ReactiveCocoa中的部分函数</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">解读ReactiveCocoa中的部分函数</h1>
        <div class="stuff">
            <span>八月 13, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/RAC/">RAC</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/ReactiveCocoa/">ReactiveCocoa</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/源码分析/">源码分析</a></li></ul>


        </div>
        <div class="content markdown">
            <h4 id="一、bind、flattenMap和map"><a href="#一、bind、flattenMap和map" class="headerlink" title="一、bind、flattenMap和map"></a>一、bind、flattenMap和map</h4><blockquote>
<p>冷信号与热信号：</p>
<ol>
<li><p>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。</p>
<ol start="2">
<li>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。</li>
<li>冷信号可以理解为<code>点播</code>，每次订阅都从头开始；热信号可以理解为<code>直播</code>，订阅时从当前的状态开始；</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<blockquote>
<ul>
<li><code>map</code>和<code>flatten</code>是基于<code>flattenMap</code>,而<code>flattenMap</code>是基于<code>bind:</code>,所以在此之前先来看看<code>bind</code>函数。</li>
</ul>
</blockquote>
<h5 id="1-bind"><a href="#1-bind" class="headerlink" title="1. bind:"></a>1. bind:</h5><ul>
<li>具体来看源码（为方便理解，去掉了源代码中<code>RACDisposable</code>, <code>@synchronized</code>, <code>@autoreleasepool</code>相关代码)。当新信号<code>N</code>被外部订阅时，会进入信号<code>N</code>的<code>didSubscribeBlock</code> (1)，之后订阅原信号<code>O</code> (2)，当原信号<code>O</code>有值输出后就用<code>bind</code>函数传入的<code>bindBlock</code>将其变换成中间信号<code>M</code> (3), 并马上对其进行订阅(4)，最后将中间信号<code>M</code>的输出作为新信号<code>N</code>的输出 (5)。即：当新生成的信号被订阅时，源信号也会立即被订阅。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">        RACStreamBindBlock bindingBlock = block(); <span class="comment">// (MARK:此处执行block回调,生成一个bindingBlock)</span></span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;  <span class="comment">// (2)</span></span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">id</span> middleSignal = bindingBlock(x, &amp;stop);  <span class="comment">// (3) map与flatten结果不同，问题就出在这里</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (middleSignal != <span class="literal">nil</span>) &#123;</span><br><span class="line">                RACDisposable *disposable = [middleSignal subscribeNext:^(<span class="keyword">id</span> x) &#123; <span class="comment">// (4)</span></span><br><span class="line">                    [subscriber sendNext:x];  <span class="comment">// (5)</span></span><br><span class="line">                &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                    [subscriber sendError:error];</span><br><span class="line">                &#125; completed:^&#123;</span><br><span class="line">                    [subscriber sendCompleted];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-flattenMap"><a href="#2-flattenMap" class="headerlink" title="2. flattenMap:"></a>2. flattenMap:</h5><p><code>flattenMap</code>其实就是对<code>bind:</code>方法进行了一些安全检查，它最终返回的是<code>bindBlock</code>执行后生成的那个中间<code>signal</code>又被订阅后传递出的值的信号，而<code>map</code>方法返回的是<code>bindBlock</code>的执行结果生成的那个信号，没有再加工处理（即被订阅，再发送值）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)flattenMap:(RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        <span class="comment">/// @return 返回的是RACStreamBindBlock</span></span><br><span class="line">        <span class="comment">/// @discussion</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// 跟`bind：`方法中的代码对应起来如下：</span></span><br><span class="line">        <span class="comment">/// BOOL stop = NO;</span></span><br><span class="line">         <span class="comment">/// id middleSignal = bindingBlock(x, &amp;stop);</span></span><br><span class="line">         <span class="comment">///</span></span><br><span class="line">         <span class="comment">/// 与上面`bind:`函数中的(3)对应起来,</span></span><br><span class="line">         <span class="comment">/// 可以看出bindBlock中的x是原信号被subscribe后传出的值，即对应下面的value</span></span><br><span class="line">         <span class="comment">/// 也即flattenMap中的 block执行后传出的值，</span></span><br><span class="line">         <span class="comment">/// 即上面的(RACStream * (^ block)(id value))中的value</span></span><br><span class="line">         <span class="comment">/// flattenMap:后的那个block其实与bind:后的block基本是一样的，参数都是原信号发出的值，返回值都是RACStream，差别就是一个bool参数，所以说，flattenMap其实就是对bind方法进行了一些安全检查</span></span><br><span class="line">         <span class="comment">/// 综上所述：*flattenMap方法中传进来的那个block参数值就是原信号被订阅后发送的值*</span></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">// 下面这个value并不是flattenMap后面block中的那个value，而是(就近原则)原信号中的值；flattenMap后面那个block中的value的值是原信号发出的值被转换为中间信号后，又被订阅后发出去的值，这里要区分开；</span></span><br><span class="line">            <span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">            <span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-map"><a href="#3-map" class="headerlink" title="3. map:"></a>3. map:</h5><p><code>map</code>: 下面是<code>map</code>方法的源码，可以看出，<code>map</code>只是对<code>flattenMap</code>传出的<code>vaue</code>（即原信号传出的值）进行了<code>mapBlock</code>操作，并没有再进行订阅操作，即并不像<code>bind：</code>一样再次对原信号进行<code>bindBlock</code>后生成的中间信号进行订阅。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -map:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-flatten"><a href="#4-flatten" class="headerlink" title="4. flatten:"></a>4. flatten:</h5><p><code>flatten</code>: 该操作主要作用于信号的信号。原信号<code>O</code>作为信号的信号，在被订阅时输出的数据必然也是个信号<code>(signalValue)</code>，这往往不是我们想要的。当我们执行<code>[O flatten]</code>操作时，因为<code>flatten</code>内部调用了<code>flattenMap</code> (1)，<code>flattenMap</code>里对应的中间信号就是原信号<code>O</code>输出的<code>signalValue</code> (2)。按照之前分析的经验，在<code>flattenMap</code>操作中新信号<code>N</code>输出的结果就是各中间信号<code>M</code>输出的集合。因此在<code>flatten</code>操作中新信号<code>N</code>被订阅时输出的值就是原信号<code>O</code>的各个子信号输出值的集合。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)flatten</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> flattenMap:^(RACSignal *signalValue) &#123; <span class="comment">// (1)</span></span><br><span class="line">            <span class="comment">/// 返回值作为bind:中的中间信号</span></span><br><span class="line">        <span class="keyword">return</span> signalValue; <span class="comment">// (2)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-小结："><a href="#5-小结：" class="headerlink" title="5. 小结："></a>5. <strong>小结：</strong></h5><p>以前一直不理解<code>flatten</code>与<code>map</code>之间的区别，然后经过不断在源码中打断点，一步步跟代码，终于是明白了：<br><code>flatten</code>和<code>map</code>后面的block返回结果其实最终都会变为<code>bind:</code>方法中的中间信号，但是<code>flatten:</code>的<code>block</code>是直接把原信号发出的值返回来作为中间信号的，所以中间信号被订阅，其实就是原信号发出的值又被订阅，这也就是<code>flatten:</code>能拿到信号中的信号中的值的原因。<br>而<code>map:</code>后面的block是把原信号发出的值加工处理了的，又生成了一个新的信号，即<code>map:</code>方法<code>block</code>返回的中间信号已经不是原来的信号中的信号了，而是把原信号发出的值作为它的包含值的一个新的信号，它被订阅时，发送的是原信号发出的那个值，这就是<code>map</code>拿不到原信号中的信号的原因。<br>说白了就是<code>flatten:</code>操作的始终是原来的信号，而<code>map:</code>会生成一个包含原信号发送值的新信号。</p>
<hr>
<h4 id="二、multicast"><a href="#二、multicast" class="headerlink" title="二、multicast:"></a>二、multicast:</h4><p>简单分析一下 <code>- (RACMulticastConnection *)multicast:(RACSubject *)subject;</code>方法：</p>
<ul>
<li>1、当 <code>RACSignal</code> 类的实例调用 <code>- (RACMulticastConnection *)multicast:(RACSubject *)subject</code> 时，以 <code>self</code> 和 <code>subject</code> 作为构造参数创建一个 <code>RACMulticastConnection</code> 实例。</li>
<li>2、<code>RACMulticastConnection</code> 构造的时候，保存 <code>source</code> 和 <code>subject</code> 作为成员变量，创建一个 <code>RACSerialDisposable</code> 对象，用于取消订阅。</li>
<li>3、当 <code>RACMulticastConnection</code> 类的实例调用 <code>- (RACDisposable *)connect</code> 这个方法的时候，判断是否是第一次。如果是的话 用 <code>_signal</code> 这个成员变量（RACSubject类型）来订阅 <code>sourceSignal</code>， 之后返回 <code>self.serialDisposable</code>，否则直接返回 <code>self.serialDisposable</code> 。</li>
<li>4、<code>RACMulticastConnection</code> 的 <code>signal</code> 只读属性，就是一个热信号，订阅这个热信号就避免了各种副作用的问题。它会在 <code>- (RACDisposable *)connect</code> 第一次调用后，根据 <code>sourceSignal</code> 的订阅结果来传递事件。</li>
<li>5、想要确保第一次订阅就能成功订阅 <code>sourceSignal</code> ，可以使用 <code>- (RACSignal *)autoconnect</code> 这个方法，它保证了第一个订阅者触发 <code>sourceSignal</code> 的订阅，也保证了当返回的信号所有订阅者都关闭连接后 <code>sourceSignal</code> 被正确关闭连接。</li>
<li>6、这里面订阅 <code>sourceSignal</code> 是重点，<code>_signal</code>是一个<code>RACSubject</code>类型，它里面维护着一个可变数组，每当它被订阅时，会把所有的<strong>订阅者</strong>保存到这个数组中。当<code>connection.signal</code>（即<code>_signal</code>）被订阅时，其实是<code>_signal</code>被订阅了。由于<code>_signal</code>是<code>RACSubject</code>类型对象，且<code>_signal</code>也是信号，它里面重写了订阅方法，所以会执行它自己的<code>subscribe:</code>方法，执行此方法之前订阅者参数是<code>RACSubscriber</code>类型，但是在这个subscribe方法中，初始化了一个<code>RACPassthroughSubscriber</code>实例对象，使它作为新的订阅者（其实就是对订阅者进行了一层包装），并把它存入了<code>subject</code>维护的那个订阅者数组里（原来的<code>订阅者</code>和<code>信号</code>被<code>RACPassthroughSubscriber</code>实例保存了），所以数组中最终保存的是<code>RACPassthroughSubscriber</code>类型的订阅者，然后它发送消息的时候调的还是它持有的<code>subject</code>对象进行发送消息。</li>
<li>7、当<code>RACMulticastConnection</code>调用<code>connect</code>方法时，源信号<code>sourceSignal</code>被<code>_signal</code>订阅，即执行<code>[sourceSignal subscribe:subject]</code>方法，然后执行订阅<code>subscribeNext:</code>block回调，在回调中执行<code>sendNext:</code>，由于订阅者是<code>RACSubject</code>类型的实例对象，它里面也会执行<code>sendNext:</code>方法，此方法中会遍历它的数组中的订阅者依次发送消息。</li>
<li>8、<code>connect</code>时订阅者是<code>RACSubject</code>发送的<code>sendNext:</code>，subject会拿到它那个订阅者数组遍历，取出其中的<code>RACPassthroughSubscriber</code>对象，然后用<code>RACPassthroughSubscriber</code>对象中的真实的订阅者去发送数据。</li>
</ul>
<hr>
<h4 id="三、RACCommand"><a href="#三、RACCommand" class="headerlink" title="三、RACCommand"></a>三、RACCommand</h4><p>不废话，直接上源码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal * (^)(<span class="keyword">id</span> input))signalBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(signalBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    _activeExecutionSignals = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    _signalBlock = [signalBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听`activeExecutionSignals`数组</span></span><br><span class="line">    RACSignal *newActiveExecutionSignals = [[[[[<span class="keyword">self</span></span><br><span class="line">        rac_valuesAndChangesForKeyPath:@keypath(<span class="keyword">self</span>.activeExecutionSignals) options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>]</span><br><span class="line">        reduceEach:^(<span class="keyword">id</span> _, <span class="built_in">NSDictionary</span> *change) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *signals = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">            <span class="keyword">if</span> (signals == <span class="literal">nil</span>) <span class="keyword">return</span> [RACSignal empty];</span><br><span class="line">            <span class="comment">// 把数组转换为信号发送出去</span></span><br><span class="line">            <span class="keyword">return</span> [signals.rac_sequence signalWithScheduler:RACScheduler.immediateScheduler];</span><br><span class="line">        &#125;]</span><br><span class="line">        concat]            <span class="comment">// 把各个信号中的信号连接起来</span></span><br><span class="line">        publish]            <span class="comment">// 广播出去，可以被多个订阅者订阅</span></span><br><span class="line">        autoconnect];    <span class="comment">// 有订阅了再发送广播</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把上面的信号`map`一下,当出现错误的时候转换成`empty`空信号,并在主线程上传递</span></span><br><span class="line">    _executionSignals = [[[newActiveExecutionSignals</span><br><span class="line">        map:^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="keyword">return</span> [signal catchTo:[RACSignal empty]];</span><br><span class="line">        &#125;]</span><br><span class="line">        deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">        setNameWithFormat:<span class="string">@"%@ -executionSignals"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先通过`ignoreValues`方法屏蔽掉`sendNext:`的结果，只保留`sendError:`和`sendCompleted`结果，然后再通过`catch:`方法拿到所有的`sendError:`结果，发送给订阅者。</span></span><br><span class="line">    <span class="comment">// 此处用的是`flattenMap`，可以直接获取到错误信息。</span></span><br><span class="line">    RACMulticastConnection *errorsConnection = [[[newActiveExecutionSignals</span><br><span class="line">        flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="keyword">return</span> [[signal</span><br><span class="line">                ignoreValues]</span><br><span class="line">                catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                    <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:error];</span><br><span class="line">                &#125;];</span><br><span class="line">        &#125;]</span><br><span class="line">        deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">        publish];</span><br><span class="line"></span><br><span class="line">    _errors = [errorsConnection.signal setNameWithFormat:<span class="string">@"%@ -errors"</span>, <span class="keyword">self</span>];</span><br><span class="line">    [errorsConnection connect];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据执行信号的数量判断`RACCommand`当前是否正在执行</span></span><br><span class="line">    RACSignal *immediateExecuting = [RACObserve(<span class="keyword">self</span>, activeExecutionSignals) map:^(<span class="built_in">NSArray</span> *activeSignals) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(activeSignals.count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在执行</span></span><br><span class="line">    _executing = [[[[[immediateExecuting</span><br><span class="line">        deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">        <span class="comment">// This is useful before the first value arrives on the main thread.</span></span><br><span class="line">        startWith:@NO]</span><br><span class="line">        distinctUntilChanged]</span><br><span class="line">        replayLast]</span><br><span class="line">        setNameWithFormat:<span class="string">@"%@ -executing"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果允许并发执行，返回`YES`，否则反转`immediateExecuting`信号的结果</span></span><br><span class="line">    RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">        <span class="keyword">if</span>:RACObserve(<span class="keyword">self</span>, allowsConcurrentExecution)</span><br><span class="line">        then:[RACSignal <span class="keyword">return</span>:@YES]</span><br><span class="line">        <span class="keyword">else</span>:[immediateExecuting not]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enabledSignal == <span class="literal">nil</span>) &#123;</span><br><span class="line">        enabledSignal = [RACSignal <span class="keyword">return</span>:@YES];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        enabledSignal = [[[enabledSignal</span><br><span class="line">            startWith:@YES]</span><br><span class="line">            takeUntil:<span class="keyword">self</span>.rac_willDeallocSignal]</span><br><span class="line">            replayLast];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _immediateEnabled = [[RACSignal</span><br><span class="line">        combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">        and];</span><br><span class="line"></span><br><span class="line">    _enabled = [[[[[<span class="keyword">self</span>.immediateEnabled</span><br><span class="line">        take:<span class="number">1</span>]</span><br><span class="line">        concat:[[<span class="keyword">self</span>.immediateEnabled skip:<span class="number">1</span>] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">        distinctUntilChanged]</span><br><span class="line">        replayLast]</span><br><span class="line">        setNameWithFormat:<span class="string">@"%@ -enabled"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时，我们通常会去生成一个RACCommand对象，并传入一个返回signal对象的block。每次RACCommand execute 执行操作时，都会通过传入的这个signal block生成一个执行信号E (1)，并将该信号添加到RACCommand内部信号数组activeExecutionSignals中 (2)，同时将信号E由冷信号转成热信号(3)，最后订阅该热信号(4)，并将其返回(5)。</span></span><br><span class="line">- (RACSignal *)execute:(<span class="keyword">id</span>)input &#123; </span><br><span class="line">    RACSignal *signal = <span class="keyword">self</span>.signalBlock(input); <span class="comment">//（1）</span></span><br><span class="line">    RACMulticastConnection *connection = [[signal subscribeOn:RACScheduler.mainThreadScheduler] multicast:[RACReplaySubject subject]]; <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line">    @weakify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> addActiveExecutionSignal:connection.signal]; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">    [connection.signal subscribeError:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span> removeActiveExecutionSignal:connection.signal];</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span> removeActiveExecutionSignal:connection.signal];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [connection connect]; <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [connection.signal]; <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、其他："><a href="#四、其他：" class="headerlink" title="四、其他："></a>四、其他：</h4><p>说说几个函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是对`allowsConcurrentExecution`属性的处理方法，利用了属性的原子性，防止资源竞争，值得学习</span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowsConcurrentExecution;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *activeExecutionSignals;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The mutable array backing `activeExecutionSignals`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This should only be used while synchronized on `self`.</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_activeExecutionSignals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomic backing variable for `allowsConcurrentExecution`.</span></span><br><span class="line">    <span class="keyword">volatile</span> uint32_t _allowsConcurrentExecution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============================================================</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)allowsConcurrentExecution &#123;</span><br><span class="line">    <span class="keyword">return</span> _allowsConcurrentExecution != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAllowsConcurrentExecution:(<span class="built_in">BOOL</span>)allowed &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:@keypath(<span class="keyword">self</span>.allowsConcurrentExecution)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">        <span class="comment">// 以下函数类似于 `||`  </span></span><br><span class="line">        <span class="comment">// 只要前者和后者有一个为真，那么后者就为真；即：不管`_allowsConcurrentExecution`是否等于1，它最终都会变为`1`，因为前者是1；</span></span><br><span class="line">        OSAtomicOr32Barrier(<span class="number">1</span>, &amp;_allowsConcurrentExecution);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以下函数类似于 `&amp;&amp;`  </span></span><br><span class="line">        <span class="comment">// 前后二者必须都为真，后者才会变为真；即：不管`_allowsConcurrentExecution`等于0还是1，它最终都会变为`0`，因为前者是0</span></span><br><span class="line">        OSAtomicAnd32Barrier(<span class="number">0</span>, &amp;_allowsConcurrentExecution);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动调用KVO，通知监听者 `allowsConcurrentExecution`属性改变了</span></span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:@keypath(<span class="keyword">self</span>.allowsConcurrentExecution)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//========================数组属性================================</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)activeExecutionSignals &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [_activeExecutionSignals <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addActiveExecutionSignal:(RACSignal *)signal &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>([signal isKindOfClass:RACSignal.class]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSIndexSet</span> *indexes = [<span class="built_in">NSIndexSet</span> indexSetWithIndex:_activeExecutionSignals.count];</span><br><span class="line">        [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeInsertion</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">        [_activeExecutionSignals addObject:signal];</span><br><span class="line">        [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeInsertion</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeActiveExecutionSignal:(RACSignal *)signal &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>([signal isKindOfClass:RACSignal.class]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前数组中获取到要移除的对象的indexSets，如果不存在直接返回</span></span><br><span class="line">        <span class="built_in">NSIndexSet</span> *indexes = [_activeExecutionSignals indexesOfObjectsPassingTest:^ <span class="built_in">BOOL</span> (RACSignal *obj, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj == signal;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indexes.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 手动调用KVO，通知监听者 `activeExecutionSignals` 数组的改变</span></span><br><span class="line">        [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">        [_activeExecutionSignals removeObjectsAtIndexes:indexes];</span><br><span class="line">        [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h4><h5 id="附1：部分函数的图表解释"><a href="#附1：部分函数的图表解释" class="headerlink" title="附1：部分函数的图表解释"></a>附1：部分函数的图表解释</h5><blockquote>
<p><img src="http://img0.tuicool.com/QbyMjyR.png" alt="CombineLatest"><br><img src="http://img2.tuicool.com/JBrMn2r.png" alt="Zip"><br><img src="http://img0.tuicool.com/Nr2AriV.png" alt="操作结果"><br><img src="http://img1.tuicool.com/U3Mzym3.png" alt="Merge"><br><img src="http://img0.tuicool.com/faIv6bu.png" alt="Concat"></p>
</blockquote>
<h5 id="附2：ReactiveCocoa和RxSwift-API图"><a href="#附2：ReactiveCocoa和RxSwift-API图" class="headerlink" title="附2：ReactiveCocoa和RxSwift API图"></a>附2：<code>ReactiveCocoa</code>和<code>RxSwift</code> API图</h5><blockquote>
<p>引用自<a href="https://github.com/aiqiuqiu/FRPCheatSheeta" target="_blank" rel="noopener">FRPCheatSheeta</a></p>
</blockquote>
<p><strong>1. ReactiveCocoa-ObjC</strong><br><img src="http://ww1.sinaimg.cn/large/006tNbRwjw1f69ss3l0y4j31jf1cpwtm.jpg" alt="ReactiveCocoa-Objc"></p>
<p><strong>2. ReactiveCocoa-Swift</strong><br><img src="http://ww4.sinaimg.cn/large/006tNbRwjw1f69u9n630vj31kw10nk1g.jpg" alt="ReactiveCocoaV4.x-Swift.png"></p>
<p><strong>3. RxSwift</strong><br><img src="http://ww2.sinaimg.cn/large/006tNbRwjw1f69u2fugtjj317k1n1tis.jpg" alt="RXSwift.png"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ul>
<li><a href="http://www.jianshu.com/p/d262f2c55fbe" target="_blank" rel="noopener">RAC核心元素与信号流</a> </li>
<li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</a> </li>
<li><a href="http://www.tuicool.com/sites/NRbMbqa" target="_blank" rel="noopener">Halfrost’s Field分析ReactiveCocoa的系列文章</a></li>
<li><a href="http://www.tuicool.com/articles/QJrqeam" target="_blank" rel="noopener">Reactive Cocoa中的@weakify、@strongify的实现</a></li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='763f906863260a462bc4'
        data-cs='b09ecb713d7df4fdbd123fe84b9f71e077d50b95'
        data-r='faimin.github.io'
        data-o='faimin'
        data-a='faimin'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、bind、flattenMap和map"><span class="toc-number">1.</span> <span class="toc-text">一、bind、flattenMap和map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-bind"><span class="toc-number">1.1.</span> <span class="toc-text">1. bind:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-flattenMap"><span class="toc-number">1.2.</span> <span class="toc-text">2. flattenMap:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-map"><span class="toc-number">1.3.</span> <span class="toc-text">3. map:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-flatten"><span class="toc-number">1.4.</span> <span class="toc-text">4. flatten:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-小结："><span class="toc-number">1.5.</span> <span class="toc-text">5. 小结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、multicast"><span class="toc-number">2.</span> <span class="toc-text">二、multicast:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、RACCommand"><span class="toc-number">3.</span> <span class="toc-text">三、RACCommand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、其他："><span class="toc-number">4.</span> <span class="toc-text">四、其他：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#附录："><span class="toc-number">5.</span> <span class="toc-text">附录：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#附1：部分函数的图表解释"><span class="toc-number">5.1.</span> <span class="toc-text">附1：部分函数的图表解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#附2：ReactiveCocoa和RxSwift-API图"><span class="toc-number">5.2.</span> <span class="toc-text">附2：ReactiveCocoa和RxSwift API图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考"><span class="toc-number">6.</span> <span class="toc-text">参考:</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>