
<!DOCTYPE html>
<html lang="zh-cn" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zero.D.Saber&#39;s Home - 困于心，衡于虑，而后作！</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Zero.D.Saber, iOS, Swift, Objective-C,"> 
    <meta name="description" content="记录点滴,
Promise思想的开源库其实有很多，这里仅简单分析下Bolts、PromiseKit、promises

一、 Bolts:
Facebook出品

BFTask原理：每个BFTask自己都维护,"> 
    <meta name="author" content="Zero.D.Saber"> 
    <link rel="alternative" href="atom.xml" title="Zero.D.Saber&#39;s Home" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>

<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Promise源码简析</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Promise源码简析</h1>
        <div class="stuff">
            <span>八月 30, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/iOS/">iOS</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/promise/">promise</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/源码分析/">源码分析</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
<p><code>Promise</code>思想的开源库其实有很多，这里仅简单分析下<a href="https://github.com/BoltsFramework/Bolts-ObjC" target="_blank" rel="noopener">Bolts</a>、<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>、<a href="https://github.com/google/promises" target="_blank" rel="noopener">promises</a></p>
</blockquote>
<h3 id="一、-Bolts"><a href="#一、-Bolts" class="headerlink" title="一、 Bolts:"></a>一、 <a href="https://github.com/BoltsFramework/Bolts-ObjC" target="_blank" rel="noopener">Bolts</a>:</h3><blockquote>
<p><code>Facebook</code>出品</p>
</blockquote>
<p><code>BFTask</code>原理：<br>每个<code>BFTask</code>自己都维护着一个任务数组，当task执行<code>continueWithBlock:</code>后（会生成一个新的<code>BFTask</code>），<code>continueWithBlock:</code>带的那个<code>block</code>会被加入到任务数组中，每当有结果返回时，会执行<code>trySetResult:</code>方法，这个方法中会拿到<code>task</code>它自己维护的那个任务数组，然后取出其中的所有任务<code>block</code>，然后遍历执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 内部维护的任务数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *callbacks;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// `continueWithBlock:`方法</span></span><br><span class="line">- (BFTask *)continueWithExecutor:(BFExecutor *)executor</span><br><span class="line">                           block:(BFContinuationBlock)block</span><br><span class="line">               cancellationToken:(<span class="keyword">nullable</span> BFCancellationToken *)cancellationToken &#123;</span><br><span class="line">	 <span class="comment">// 创建一个新的`BFTaskCompletionSource`，创建它时，它里面会`new`一个`task`对象，最后`return`的也是这个`task`</span></span><br><span class="line">	 <span class="comment">// 这个不是单例方法，所以此处创建的`task`是一个新对象</span></span><br><span class="line">    BFTaskCompletionSource *tcs = [BFTaskCompletionSource taskCompletionSource]; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个任务`block`，后面会把执行这个`block`的操作加入到数组中，当回调时会执行这个`block`里面的操作</span></span><br><span class="line">    <span class="comment">// P.S. 下面附一张把这个block折叠后的图片</span></span><br><span class="line">    dispatch_block_t executionBlock = ^&#123;                    <span class="comment">//(N.0)</span></span><br><span class="line">        <span class="keyword">if</span> (cancellationToken.cancellationRequested) &#123;</span><br><span class="line">            [tcs cancel];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		  </span><br><span class="line">		   <span class="comment">// 把当前类（`task`对象）作为参数进行回调               //(N.1)</span></span><br><span class="line">        <span class="keyword">id</span> result = <span class="literal">nil</span>;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">        <span class="keyword">if</span> (BFTaskCatchesExceptions()) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                result = block(<span class="keyword">self</span>);</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"[Bolts] Warning: `BFTask` caught an exception in the continuation block."</span></span><br><span class="line">                      <span class="string">@" This behavior is discouraged and will be removed in a future release."</span></span><br><span class="line">                      <span class="string">@" Caught Exception: %@"</span>, exception);</span><br><span class="line">                tcs.exception = exception;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = block(<span class="keyword">self</span>);                          </span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">			<span class="comment">// 如果回调结果返回的是`BFTask`类型</span></span><br><span class="line">        <span class="keyword">if</span> ([result isKindOfClass:[BFTask <span class="keyword">class</span>]]) &#123;</span><br><span class="line">				 <span class="comment">// 下面`block`中的`task`就是上面的`result`</span></span><br><span class="line">            <span class="keyword">id</span> (^setupWithTask) (BFTask *) = ^<span class="keyword">id</span>(BFTask *task) &#123;     <span class="comment">//(N.3)</span></span><br><span class="line">                <span class="keyword">if</span> (cancellationToken.cancellationRequested || task.cancelled) &#123;</span><br><span class="line">                    [tcs cancel];</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.exception) &#123;</span><br><span class="line">                    tcs.exception = task.exception;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.error) &#123;</span><br><span class="line">                    tcs.error = task.error;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tcs.result = task.result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            BFTask *resultTask = (BFTask *)result;</span><br><span class="line">				 <span class="comment">/// 如果`continueWithBlock:`中的`block`回调返回的`task`是`complete`状态，则直接到 (N.3)，把任务的结果传递到上面新创建的那个`BFTask`对象的`result`属性中,否则就继续执行`continueWithBlock:`来监测任务状态</span></span><br><span class="line">            <span class="keyword">if</span> (resultTask.completed) &#123;</span><br><span class="line">                setupWithTask(resultTask);                      <span class="comment">//(N.2)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [resultTask continueWithBlock:setupWithTask];   <span class="comment">//(N.4)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tcs.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">// 如果是未完成状态，则把操作加入到数组中，延后执行；否则就立即执行</span></span><br><span class="line">    <span class="built_in">BOOL</span> completed;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>.lock) &#123;	                        <span class="comment">//(2.0)</span></span><br><span class="line">        completed = <span class="keyword">self</span>.completed;</span><br><span class="line">        <span class="keyword">if</span> (!completed) &#123;</span><br><span class="line">        		<span class="comment">// 把任务添加到数组中</span></span><br><span class="line">            [<span class="keyword">self</span>.callbacks addObject:[^&#123;</span><br><span class="line">                [executor execute:executionBlock];</span><br><span class="line">            &#125; <span class="keyword">copy</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completed) &#123;                                   <span class="comment">//(2.1) </span></span><br><span class="line">        [executor execute:executionBlock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcs.task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://olmn3rwny.bkt.clouddn.com/20180830114906_3C04kM_continueWithBlock.jpeg" alt=""></p>
<h3 id="二、-PromiseKit"><a href="#二、-PromiseKit" class="headerlink" title="二、 PromiseKit:"></a>二、 <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>:</h3><ol>
<li>首先，让我们看看创建<code>Promise</code>的源码</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)promiseWithResolver:(<span class="keyword">void</span> (^)(PMKResolver))block &#123;    <span class="comment">// (2)</span></span><br><span class="line">    PMKPromise *<span class="keyword">this</span> = [<span class="keyword">self</span> alloc];              <span class="comment">// (3)  初始化promise</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_promiseQueue = PMKCreatePromiseQueue();</span><br><span class="line">    <span class="keyword">this</span>-&gt;_handlers = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        block(^(<span class="keyword">id</span> result)&#123;           <span class="comment">// (4)  立即开始原始任务（它传过去的参数还是一个`PMKResolver`类型的block，这个block会在PMKRejecter或者PMKFulfiller类型的block执行回调时执行） "void (^PMKResolver)(id)"</span></span><br><span class="line">            <span class="keyword">if</span> (PMKGetResult(<span class="keyword">this</span>))</span><br><span class="line">                <span class="keyword">return</span> PMKLog(<span class="string">@"PromiseKit: Warning: Promise already resolved"</span>);</span><br><span class="line"></span><br><span class="line">            PMKResolve(<span class="keyword">this</span>, result); <span class="comment">// (7) result为用户在`new:`方法中返回的数据结果,而this则是上面一开始时初始化的那个promise. 执行到这里后接下来会到(8),回调到(9)那个block,这个block中会遍历`handlers`数组中的`handler()` block, </span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="keyword">id</span> e) &#123;</span><br><span class="line">        <span class="comment">// at this point, no pointer to the Promise has been provided</span></span><br><span class="line">        <span class="comment">// to the user, so we can’t have any handlers, so all we need</span></span><br><span class="line">        <span class="comment">// to do is set _result. Technically using PMKSetResult is</span></span><br><span class="line">        <span class="comment">// not needed either, but this seems better safe than sorry.</span></span><br><span class="line">        PMKSetResult(<span class="keyword">this</span>, <span class="built_in">NSErrorFromException</span>(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)new:(<span class="keyword">void</span>(^)(PMKFulfiller, PMKRejecter))block &#123;   <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> promiseWithResolver:^(PMKResolver resolve) &#123;</span><br><span class="line">        <span class="keyword">id</span> rejecter = ^(<span class="keyword">id</span> error)&#123;                    <span class="comment">// (5-1) 失败的block</span></span><br><span class="line">            <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">                error = <span class="built_in">NSErrorFromNil</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsPromise(error) &amp;&amp; [error rejected]) &#123;</span><br><span class="line">                <span class="comment">// this is safe, acceptable and (basically) valid</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!IsError(error)) &#123;</span><br><span class="line">                <span class="keyword">id</span> userInfo = @&#123;<span class="built_in">NSLocalizedDescriptionKey</span>: [error description], PMKUnderlyingExceptionKey: error&#125;;</span><br><span class="line">                error = [<span class="built_in">NSError</span> errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(error);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> fulfiller = ^(<span class="keyword">id</span> result)&#123;                  <span class="comment">// (5-2) 成功的block</span></span><br><span class="line">            <span class="keyword">if</span> (IsError(result))</span><br><span class="line">                PMKLog(<span class="string">@"PromiseKit: Warning: PMKFulfiller called with NSError."</span>);</span><br><span class="line">            resolve(result);       <span class="comment">// (6) 当用户执行`PMKFulfiller`类型的block时,会回调到这里,此方法执行(4)中的那个参数block,即执行(7)</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        block(fulfiller, rejecter);                   <span class="comment">// (5-3) 把成功和失败的block作为参数，执行回调原任务（e.g demo中的网络请求任务）</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> PMKResolve(PMKPromise *<span class="keyword">this</span>, <span class="keyword">id</span> result) &#123;</span><br><span class="line">    <span class="keyword">void</span> (^set)(<span class="keyword">id</span>) = ^(<span class="keyword">id</span> r)&#123; <span class="comment">// (9) handle回调执行(10)</span></span><br><span class="line">        <span class="built_in">NSArray</span> *handlers = PMKSetResult(<span class="keyword">this</span>, r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">void</span> (^handler)(<span class="keyword">id</span>) <span class="keyword">in</span> handlers)</span><br><span class="line">            handler(r);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsPromise(result)) &#123;</span><br><span class="line">        PMKPromise *next = result;</span><br><span class="line">        dispatch_barrier_sync(next-&gt;_promiseQueue, ^&#123;</span><br><span class="line">            <span class="keyword">id</span> nextResult = next-&gt;_result;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nextResult == <span class="literal">nil</span>) &#123;  <span class="comment">// ie. pending</span></span><br><span class="line">                [next-&gt;_handlers addObject:^(<span class="keyword">id</span> o)&#123;</span><br><span class="line">                    PMKResolve(<span class="keyword">this</span>, o);</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                set(nextResult);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        set(result); <span class="comment">// (8) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>new:</code>方法时会调用<code>promiseWithResolver:</code>方法，在里面进行一些初始化<code>promise</code>的工作：创建了一个<code>GCD</code>并发队列和一个数组，并立即回调<code>new:</code>后面的那个参数<code>block</code>，即：立即执行，生成一个成功<code>fulfiller</code>和失败<code>rejecter</code>的<code>block</code>，这个<code>block</code>将由用户控制回调操作的时机。</p>
<hr>
<ol start="2">
<li>下面看一下<code>then</code>的实现：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (PMKPromise *(^)(<span class="keyword">id</span>))then &#123;      <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 此处`then`本身就是一个block：（PMKPromise *(^then)(id param)），此方法类似于getter方法</span></span><br><span class="line">    <span class="comment">// 返回一个`(PMKPromise *(^)(id))`类型的block，这个block执行后，返回一个PMKPromise</span></span><br><span class="line">    <span class="comment">// 下面整个都是一个then `block`，当执行then的时候会调用 `self.thenOn(dispatch_get_main_queue(), block)`，返回一个Promise类型的结果</span></span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">id</span> block)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.thenOn(dispatch_get_main_queue(), block);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (PMKResolveOnQueueBlock)thenOn &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> resolved:^(<span class="keyword">id</span> result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPromise(result))</span><br><span class="line">            <span class="keyword">return</span> ((PMKPromise *)result).thenOn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsError(result)) <span class="keyword">return</span> ^(<span class="built_in">dispatch_queue_t</span> q, <span class="keyword">id</span> block) &#123;</span><br><span class="line">            <span class="keyword">return</span> [PMKPromise promiseWithValue:result];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="built_in">dispatch_queue_t</span> q, <span class="keyword">id</span> block) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HACK we seem to expose some bug in ARC where this block can</span></span><br><span class="line">            <span class="comment">// be an NSStackBlock which then gets deallocated by the time</span></span><br><span class="line">            <span class="comment">// we get around to using it. So we force it to be malloc'd.</span></span><br><span class="line">            block = [block <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dispatch_promise_on(q, ^&#123;</span><br><span class="line">                <span class="keyword">return</span> pmk_safely_call_block(block, result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    pending:^(<span class="keyword">id</span> result, PMKPromise *next, <span class="built_in">dispatch_queue_t</span> q, <span class="keyword">id</span> block, <span class="keyword">void</span> (^resolve)(<span class="keyword">id</span>)) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (IsError(result))</span><br><span class="line">            PMKResolve(next, result);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            resolve(pmk_safely_call_block(block, result));  <span class="comment">// (11)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)resolved:(PMKResolveOnQueueBlock(^)(<span class="keyword">id</span> result))mkresolvedCallback</span><br><span class="line">       pending:(<span class="keyword">void</span>(^)(<span class="keyword">id</span> result, PMKPromise *next, <span class="built_in">dispatch_queue_t</span> q, <span class="keyword">id</span> block, <span class="keyword">void</span> (^resolver)(<span class="keyword">id</span>)))mkpendingCallback</span><br><span class="line">&#123;</span><br><span class="line">    __block PMKResolveOnQueueBlock callBlock;</span><br><span class="line">    __block <span class="keyword">id</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_promiseQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ((result = _result)) <span class="comment">// 有结果的情况下直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        callBlock = ^(<span class="built_in">dispatch_queue_t</span> q, <span class="keyword">id</span> block) &#123; <span class="comment">// 此block在`thenOn:`方法赋值时进行回调</span></span><br><span class="line"></span><br><span class="line">            block = [block <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">            __block PMKPromise *next = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            dispatch_barrier_sync(_promiseQueue, ^&#123;</span><br><span class="line">                <span class="keyword">if</span> ((result = _result))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                __block PMKPromiseFulfiller resolver;</span><br><span class="line">                next = [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject) &#123;</span><br><span class="line">                    resolver = ^(<span class="keyword">id</span> o)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (IsError(o)) reject(o); <span class="keyword">else</span> fulfill(o); <span class="comment">// (12)</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;];</span><br><span class="line">                [_handlers addObject:^(<span class="keyword">id</span> value)&#123;</span><br><span class="line">                    mkpendingCallback(value, next, q, block, resolver); <span class="comment">// (10)</span></span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// next can still be `nil` if the promise was resolved after</span></span><br><span class="line">            <span class="comment">// 1) `-thenOn` read it and decided which block to return; and</span></span><br><span class="line">            <span class="comment">// 2) the call to the block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> next ?: mkresolvedCallback(result)(q, block);  <span class="comment">// (2) 如果`next` promise没有生成,则用以前的参数再执行一次. `mkresolvedCallback(result)`返回一个`PMKResolveOnQueueBlock`类型的block`(在这里就相当于生成了一个callBlock),然后立即调用,生成`PMKPromise`类型的`next`,以供后面的链式调用.</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callBlock ?: mkresolvedCallback(result); <span class="comment">// (1) callBlock存在,说明result为nil,现在还没有结果;否则就执行后面的`mkresolvedCallback()` block.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的形参其实就是2个<code>block</code>，一个是<code>resolved</code>的<code>block</code>，还有一个是<code>pending</code>的<code>block</code>。当一个<code>promise</code>经历过<code>resolved</code>之后，可能是<code>fulfill</code>，也可能是<code>reject</code>，之后生成<code>next</code>新的<code>promise</code>，传入到下一个<code>then</code>中，并且状态会变成<code>pending</code>。上面代码中第一个<code>return</code>，如果<code>next</code>为<code>nil</code>，那么意味着<code>promise</code>没有生成，这是会再调用一次<code>mkresolvedCallback</code>，并传入参数<code>result</code>，生成的<code>PMKResolveOnQueueBlock</code>，再次传入<code>(q, block)</code>，直到<code>next</code>的<code>promise</code>生成，并把<code>pendingCallback</code>存入到<code>handler</code>当中。这个<code>handler</code>存了所有待执行的<code>block</code>，如果把这个数组里面的<code>block</code>都执行，那么就相当于依次完成了上面的所有异步操作。第二个<code>return</code>是在<code>callblock</code>为<code>nil</code>的时候，还会再调一次<code>mkresolvedCallback(result)</code>，保证一定要生成<code>next</code>的<code>promise</code>。</p>
<p>这个函数里面的<code>dispatch_barrier_sync</code>这个方法，就是<code>promise</code>后面可以链式调用<code>then</code>的原因，因为这个<code>GCD</code>函数保证了后面的<code>then</code>顺序执行。</p>
<h3 id="三、-Promises"><a href="#三、-Promises" class="headerlink" title="三、 Promises"></a>三、 <a href="https://github.com/google/promises" target="_blank" rel="noopener">Promises</a></h3><blockquote>
<p><code>google</code>出品</p>
</blockquote>
<p>原理： 这个开源库的思路其实与<code>BFTask</code>很相似，每次<code>promise</code>执行then方法时都会创建一个新的<code>promise</code>对象，同时会创建一个观察者（<code>block</code>对象），这个观察者会持有这个新的<code>promise</code>，当（旧）<code>promise</code>对象<code>fulfilled</code>或者<code>rejected</code>的时候，会把<code>fulfilled</code>或者<code>rejected</code>拿到的<code>value</code>给新<code>promise</code>。</p>
<p>先看下promise的初始化方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initPending &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    dispatch_group_enter(FBLPromise.dispatchGroup);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先进入一个单例<code>dispatch_group_t</code>中，为啥用<code>dispatch_group_t</code>呢？因为后面的<code>then</code>方法可以在其他队列处理，而且<code>dispatch_group_t</code>有同步队列的功能，后面作者每次初始化一个<code>promise</code>都会<code>enter</code>到<code>dispatch_group_t</code>中，<code>fulfilled</code>或者<code>rejected</code>时再<code>leave</code>。</p>
<p>接下来看看最重要同时也是精华所在的<code>then</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initPending &#123;     <span class="comment">// (0)</span></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        dispatch_group_enter(FBLPromise.dispatchGroup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FBLPromise *)onQueue:(<span class="built_in">dispatch_queue_t</span>)queue then:(FBLPromiseThenWorkBlock)work &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> chainOnQueue:queue chainedFulfill:work chainedReject:<span class="literal">nil</span>];     <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FBLPromise *)chainOnQueue:(<span class="built_in">dispatch_queue_t</span>)queue</span><br><span class="line">              chainedFulfill:(FBLPromiseChainedFulfillBlock)chainedFulfill</span><br><span class="line">               chainedReject:(FBLPromiseChainedRejectBlock)chainedReject &#123;</span><br><span class="line">    <span class="comment">// 首先new一个新的promise对象</span></span><br><span class="line">    FBLPromise *newPromise = [[FBLPromise alloc] initPending];               <span class="comment">// (2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个block其实就是抽离的一个方法，避免写重复代码。</span></span><br><span class="line">    <span class="comment">// 当promise被fulfilled或者rejected时都会调用；</span></span><br><span class="line">    <span class="comment">// 结合下面方法block中的实现可以看出，如果thenBlock（chainedFulfill）存在，则先执行chainedFulfill这个block（其实就是map一下这个value值）重新生成一个value值（value值也可能不会变化，主要还得看map函数里有没有改变value）；接下来把这个重新赋值的value扔给resolverBlock，resolverBlock会把这个新的value给newPromise，newPromise会调用fulfilled方法，如果此时newPromise也有订阅者(被then过)，则就会把这个新value传递给下一个newNewPromise ...</span></span><br><span class="line">    <span class="comment">// 如果then的时候promise已经结束了，则直接把结果返回给订阅者,即调用thenBlock。</span></span><br><span class="line">    __auto_type resolver = ^(<span class="keyword">id</span> __<span class="keyword">nullable</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[FBLPromise <span class="keyword">class</span>]]) &#123;                     <span class="comment">// (8)</span></span><br><span class="line">            [(FBLPromise *)value observeOnQueue:queue fulfill:^(<span class="keyword">id</span> __<span class="keyword">nullable</span> value) &#123;</span><br><span class="line">                [newPromise fulfill:value];</span><br><span class="line">            &#125; reject:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                [newPromise reject:error];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            [newPromise fulfill:value];                                     <span class="comment">// (8)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    [<span class="keyword">self</span> observeOnQueue:queue fulfill:^(<span class="keyword">id</span> __<span class="keyword">nullable</span> value) &#123;             </span><br><span class="line">        value = chainedFulfill ? chainedFulfill(value) : value;             <span class="comment">// (7)</span></span><br><span class="line">        resolver(value);</span><br><span class="line">    &#125; reject:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">id</span> value = chainedReject ? chainedReject(error) : error;            <span class="comment">// (7)</span></span><br><span class="line">        resolver(value);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeOnQueue:(<span class="built_in">dispatch_queue_t</span>)queue</span><br><span class="line">               fulfill:(FBLPromiseOnFulfillBlock)onFulfill</span><br><span class="line">                reject:(FBLPromiseOnRejectBlock)onReject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;                                                   <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">switch</span> (_state) &#123;</span><br><span class="line">            <span class="comment">// 默认的state，即待处理的事件</span></span><br><span class="line">            <span class="keyword">case</span> FBLPromiseStatePending: &#123;</span><br><span class="line">                <span class="comment">// 如果promise对象还没有观察者数组，new一个</span></span><br><span class="line">                <span class="comment">// 这里为什么需要观察者数组呢？因为一个Promise可以被then很多次</span></span><br><span class="line">                <span class="keyword">if</span> (!_observers) &#123;</span><br><span class="line">                    _observers = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当事件被处理时会执行下面block</span></span><br><span class="line">                __auto_type observer = ^(FBLPromiseState state, <span class="keyword">id</span> __<span class="keyword">nullable</span> resolution) &#123;</span><br><span class="line">                    dispatch_group_async(FBLPromise.dispatchGroup, queue, ^&#123;</span><br><span class="line">                        <span class="keyword">switch</span> (state) &#123;                                    <span class="comment">// (6)</span></span><br><span class="line">                            <span class="keyword">case</span> FBLPromiseStatePending:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> FBLPromiseStateFulfilled:</span><br><span class="line">                                onFulfill(resolution);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> FBLPromiseStateRejected:</span><br><span class="line">                                onReject(resolution);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;;</span><br><span class="line">                [_observers addObject:observer];                            <span class="comment">// (4)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前promise已经结束</span></span><br><span class="line">            <span class="keyword">case</span> FBLPromiseStateFulfilled: &#123;</span><br><span class="line">                dispatch_group_async(FBLPromise.dispatchGroup, queue, ^&#123;</span><br><span class="line">                    onFulfill(<span class="keyword">self</span>-&gt;_value);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前promise已经结束</span></span><br><span class="line">            <span class="keyword">case</span> FBLPromiseStateRejected: &#123;</span><br><span class="line">                dispatch_group_async(FBLPromise.dispatchGroup, queue, ^&#123;</span><br><span class="line">                    onReject(<span class="keyword">self</span>-&gt;_error);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fulfill:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value &#123;</span><br><span class="line">  <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSError</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> reject:(<span class="built_in">NSError</span> *)value];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_state == FBLPromiseStatePending) &#123;</span><br><span class="line">        _state = FBLPromiseStateFulfilled;</span><br><span class="line">        _value = value;</span><br><span class="line">        _pendingObjects = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (FBLPromiseObserver observer <span class="keyword">in</span> _observers) &#123;</span><br><span class="line">          observer(_state, _value);                                         <span class="comment">// (5)</span></span><br><span class="line">        &#125;</span><br><span class="line">        _observers = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 事件结束，leave group</span></span><br><span class="line">        dispatch_group_leave(FBLPromise.dispatchGroup);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reject:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">  <span class="built_in">NSAssert</span>([error isKindOfClass:[<span class="built_in">NSError</span> <span class="keyword">class</span>]], <span class="string">@"Invalid error type."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (![error isKindOfClass:[<span class="built_in">NSError</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="comment">// Give up on invalid error type in Release mode.</span></span><br><span class="line">    <span class="keyword">@throw</span> error;  <span class="comment">// NOLINT</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_state == FBLPromiseStatePending) &#123;</span><br><span class="line">      _state = FBLPromiseStateRejected;</span><br><span class="line">      _error = error;</span><br><span class="line">      _pendingObjects = <span class="literal">nil</span>;</span><br><span class="line">      <span class="keyword">for</span> (FBLPromiseObserver observer <span class="keyword">in</span> _observers) &#123;</span><br><span class="line">        observer(_state, _error);                                          <span class="comment">// (5)</span></span><br><span class="line">      &#125;</span><br><span class="line">      _observers = <span class="literal">nil</span>;</span><br><span class="line">      <span class="comment">// 事件结束，leave group</span></span><br><span class="line">      dispatch_group_leave(FBLPromise.dispatchGroup);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的执行步骤已经在上面做了标注，作者的思路很鲜明，推荐同学们抽时间去学习一下这个库，必定会收获良多！</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://www.jianshu.com/p/f060cfd52f17" target="_blank" rel="noopener">iOS如何优雅的处理“回调地狱Callback hell”(一)——使用PromiseKit</a></li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://www.170mv.com/kw/other.web.ra01.sycdn.kuwo.cn/resource/n2/2011/06/22/3886405066.mp3'></li>
                    
                        <li title='1' data-url='http://www.170mv.com/kw/other.web.rm01.sycdn.kuwo.cn/resource/n3/58/22/824962420.mp3'></li>
                    
                        <li title='2' data-url='http://www.170mv.com/kw/other.web.rm01.sycdn.kuwo.cn/resource/n2/46/8/2541300031.mp3'></li>
                    
                        <li title='3' data-url='http://www.170mv.com/kw/other.web.ra01.sycdn.kuwo.cn/resource/n1/128/70/3/1239173815.mp3'></li>
                    
                        <li title='4' data-url='https://891622172.wodemo.com/down/20180828/218041/%E5%91%A8%E6%9D%B0%E4%BC%A6+-+%E9%BB%84%E9%87%91%E7%94%B2.mp3'></li>
                    
                        <li title='5' data-url='http://other.web.re01.sycdn.kuwo.cn/resource/n2/78/26/557358862.mp3'></li>
                    
                        <li title='6' data-url='http://www.170mv.com/kw/other.web.rl01.sycdn.kuwo.cn/resource/n3/12/75/3969672477.mp3'></li>
                    
                        <li title='7' data-url='http://www.170mv.com/kw/other.web.rg01.sycdn.kuwo.cn/resource/n1/82/58/2383694774.mp3'></li>
                    
                        <li title='8' data-url='http://www.170mv.com/kw/rd01.sycdn.kuwo.cn/resource/n2/31/27/3607457927.mp3'></li>
                    
                        <li title='9' data-url='http://www.170mv.com/kw/other.web.ra01.sycdn.kuwo.cn/resource/n1/128/85/83/3499520104.mp3'></li>
                    
                        <li title='10' data-url='http://www.170mv.com/kw/other.web.rn01.sycdn.kuwo.cn/resource/n2/89/30/2262792667.mp3'></li>
                    
                        <li title='11' data-url='http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n2/87/60/3067312003.mp3'></li>
                    
                        <li title='12' data-url='http://www.170mv.com/kw/other.web.rl01.sycdn.kuwo.cn/resource/n2/11/66/703757030.mp3'></li>
                    
                        <li title='13' data-url='http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n2/79/84/580425099.mp3'></li>
                    
                        <li title='14' data-url='http://67.159.62.2/anime_ost/naruto-shippuuden-ed07-single-long-kiss-good-bye/vvflvshi/01.%20Long%20Kiss%20God%20Bye.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='763f906863260a462bc4'
        data-cs='b09ecb713d7df4fdbd123fe84b9f71e077d50b95'
        data-r='faimin.github.io'
        data-o='faimin'
        data-a='faimin'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、-Bolts"><span class="toc-number">1.</span> <span class="toc-text">一、 Bolts:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、-PromiseKit"><span class="toc-number">2.</span> <span class="toc-text">二、 PromiseKit:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、-Promises"><span class="toc-number">3.</span> <span class="toc-text">三、 Promises</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考："><span class="toc-number">4.</span> <span class="toc-text">参考：</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>