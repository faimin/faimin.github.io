<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zero.D.Saber&#39;s Home</title>
  
  <subtitle>困于心，衡于虑，而后作</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-28T12:00:32.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zero.D.Saber</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Gemfile对项目依赖的CocoaPods进行版本控制</title>
    <link href="http://yoursite.com/2018/08/28/%E4%BD%BF%E7%94%A8Gemfile%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%9A%84CocoaPods%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/28/使用Gemfile对项目依赖的CocoaPods进行版本控制/</id>
    <published>2018-08-28T08:38:23.000Z</published>
    <updated>2018-08-28T12:00:32.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h4><p>多人协同开发同一项目时，每个人电脑上的<code>CocoaPods</code> 版本可能不尽相同，这样当某人重新执行<code>pod install</code> 操作后，有可能导致其他人打开项目时报错。对于这种问题我们有解决办法吗？</p><h4 id="A："><a href="#A：" class="headerlink" title="A："></a>A：</h4><p>有， <code>Gemfile</code>可以帮我们以非常简单的方式解决这个问题。</p><hr><h4 id="Gemfile-Usage"><a href="#Gemfile-Usage" class="headerlink" title="Gemfile Usage"></a>Gemfile Usage</h4><p>先贴一下官方文档 <a href="https://guides.cocoapods.org/using/a-gemfile.html" target="_blank" rel="noopener">Using a Gemfile</a> </p><h5 id="大致用法："><a href="#大致用法：" class="headerlink" title="大致用法："></a>大致用法：</h5><ol><li><p>进入到工程目录下，调用<code>bundle init</code>命令，会创建一个<code>Gemfile</code>文件，此操作类似于<code>pod init</code>;</p></li><li><p>编辑刚才创建的<code>Gemfile</code>文件，在里面添加<code>gem &quot;cocoapods&quot;, &#39;1.5.0&#39;</code>，这样就指定了<code>CocoaPods</code>的版本了；在国内建议修改<code>source</code>源为：<code>source &quot;https://gems.ruby-china.org&quot;</code>，否则更新会很慢。</p></li><li><p>最后执行<code>bundle exec pod update</code> 或者<code>bundle exec pod install</code>命令即可，这样就会使用<code>Gemfile</code>内的版本安装了，不受你电脑上的<code>cocoapods</code>版本影响，比如你电脑上是<code>1.5.0</code>版本的，也可以用<code>1.4.0</code>版本的<code>pod</code>安装；这里需要说明的一点是，如果你直接调用<code>pod install</code> 或者 <code>pod uodate</code>，则默认使用的还是你本机上的<code>cocoapods</code>版本。</p></li></ol><p>为了方便使用，可以把以上命令封装到一个脚本中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!bin/sh</span><br><span class="line">rm -rf Podfile.lock</span><br><span class="line">rm -rf Pods</span><br><span class="line"></span><br><span class="line">bundle install</span><br><span class="line">bundle exec pod update --no-repo-update</span><br></pre></td></tr></table></figure><p>以上脚本可以根据需要自行修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Q：&quot;&gt;&lt;a href=&quot;#Q：&quot; class=&quot;headerlink&quot; title=&quot;Q：&quot;&gt;&lt;/a&gt;Q：&lt;/h4&gt;&lt;p&gt;多人协同开发同一项目时，每个人电脑上的&lt;code&gt;CocoaPods&lt;/code&gt; 版本可能不尽相同，这样当某人重新执行&lt;code&gt;pod 
      
    
    </summary>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>Code Tips</title>
    <link href="http://yoursite.com/2018/08/17/Code-Tips/"/>
    <id>http://yoursite.com/2018/08/17/Code-Tips/</id>
    <published>2018-08-16T16:32:47.000Z</published>
    <updated>2018-08-28T11:28:37.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>C</code> &amp;&amp; <code>Objective-C</code>代码技巧 </p></blockquote><hr><h4 id="1-GNU-C的赋值扩展："><a href="#1-GNU-C的赋值扩展：" class="headerlink" title="1. GNU C的赋值扩展："></a>1. <code>GNU C</code>的赋值扩展：</h4><pre><code>即使用`({...})`的形式。这种形式的语句可以类似很多脚本语言，在顺次执行之后，会将最后一次的表达式的值作为返回值。</code></pre><blockquote><p>注意：这个不是懒加载</p></blockquote>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RETURN_VALUE_RECEIVER = &#123;(</span><br><span class="line">     <span class="comment">// do whatever you want</span></span><br><span class="line">     ...</span><br><span class="line">     RETURN_VALUE; <span class="comment">// 返回值</span></span><br><span class="line">)&#125;;</span><br></pre></td></tr></table></figure><p>   <a href="https://github.com/romaonthego/REMenu" target="_blank" rel="noopener">REMenu</a> 这个开源库中就使用了这种语法，如下：</p>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_titleLabel = (&#123;</span><br><span class="line">   <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:titleFrame];</span><br><span class="line">   label.isAccessibilityElement = <span class="literal">NO</span>;</span><br><span class="line">   label.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</span><br><span class="line">   label.textAlignment = (<span class="built_in">NSInteger</span>)<span class="keyword">self</span>.item.textAlignment == <span class="number">-1</span> ? <span class="keyword">self</span>.menu.textAlignment : <span class="keyword">self</span>.item.subtitleTextAlignment;</span><br><span class="line">   label.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">   label.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>;</span><br><span class="line">   label;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>   使用这种语法的其中一个优点是结构鲜明紧凑，而且由于不用担心块里面的变量名污染外面变量名的问题。</p><h4 id="2-case语句中使用范围表达式："><a href="#2-case语句中使用范围表达式：" class="headerlink" title="2. case语句中使用范围表达式："></a>2. <code>case</code>语句中使用范围表达式：</h4><blockquote><p><code>GCC</code>对<code>C11</code>标准的语法扩展</p></blockquote><p>   比如，<code>case 1 ... 5</code> 就表示值如果在 <code>1~5</code> 的范围内则满足条件。<br>   这里，省略号 <code>...</code> 就作为一个范围操作符，<strong>其左右两个操作数之间至少要用一个空白符进行分割</strong>，如果写成 <code>1...5</code> 这种形式会引发词法解析错误。范围操作符的操作数可以是任一整数类型，包括字符类型。<br>   另外，范围操作符的做操作数的值应该小于或等于右操作数，否则该范围表达式就会是一个空条件范围，永远不成立。</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="comment">// 这条case语句是合法的，并且与case 1等效 </span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> ... <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这条case语句中的范围操作符的左操作数⼤于右操作数， </span></span><br><span class="line">        <span class="comment">// 因此它是⼀个空条件范围，这条case语句下的逻辑永远不会被执⾏ </span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> ... <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Hello, world!"</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使⽤const修饰的对象也可作为范围操作符的操作数 </span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span> ... c:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Wow!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'A'</span>; </span><br><span class="line">    <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">        <span class="comment">// 从'A'到'Z'的ASCII码范围 </span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span> ... <span class="string">'Z'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The letter is: %c\n"</span>, ch);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从'0'到'9'的ASCII码范围 </span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'0'</span> ... <span class="string">'9'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The digit is: %c\n"</span>, ch);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用-auto-type做类型推导："><a href="#3-使用-auto-type做类型推导：" class="headerlink" title="3. 使用__auto_type做类型推导："></a>3. 使用<code>__auto_type</code>做类型推导：</h4><blockquote><p><code>GCC</code>对<code>C11</code>标准的语法扩展</p></blockquote>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> var auto</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> let auto const</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> var __auto_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> let const __auto_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><pre><code>例如：</code></pre>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let block = ^<span class="built_in">NSString</span> *(<span class="built_in">NSString</span> *name, <span class="built_in">NSUInteger</span> age) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ + %ld"</span>, name, age];</span><br><span class="line">&#125;;</span><br><span class="line">let result = block(<span class="string">@"foo"</span>, <span class="number">100</span>);  <span class="comment">// no warning</span></span><br></pre></td></tr></table></figure><h4 id="4-结构体的初始化："><a href="#4-结构体的初始化：" class="headerlink" title="4. 结构体的初始化："></a>4. 结构体的初始化：</h4>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加(CGRect)强转也不会warning</span></span><br><span class="line">GRect rect1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">CGRect</span> rect2 = &#123;.origin.x=<span class="number">5</span>, .size=&#123;<span class="number">10</span>, <span class="number">10</span>&#125;&#125;; <span class="comment">// &#123;5, 0, 10, 10&#125;</span></span><br><span class="line"><span class="built_in">CGRect</span> rect3 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// &#123;1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-数组的下标初始化："><a href="#5-数组的下标初始化：" class="headerlink" title="5. 数组的下标初始化："></a>5. 数组的下标初始化：</h4>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> numbers[] = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">3</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">12306</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// &#123;0, 3, 2, 1, 0, 12306&#125;</span></span><br></pre></td></tr></table></figure><pre><code>**这个特性可以用来做枚举值和字符串的映射**</code></pre>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, Type)&#123;</span><br><span class="line">    Type1,</span><br><span class="line">    Type2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *TypeNameMapping[] = &#123;</span><br><span class="line">    [Type1] = <span class="string">@"Type1"</span>,</span><br><span class="line">    [Type2] = <span class="string">@"Type2"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>又如 `UITableView+FDIndexPathHeightCache`中的例子：</code></pre>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All methods that trigger height cache's invalidation</span></span><br><span class="line">SEL selectors[] = &#123;</span><br><span class="line">    <span class="keyword">@selector</span>(reloadData),</span><br><span class="line">    <span class="keyword">@selector</span>(insertSections:withRowAnimation:),</span><br><span class="line">    <span class="keyword">@selector</span>(deleteSections:withRowAnimation:),</span><br><span class="line">    <span class="keyword">@selector</span>(reloadSections:withRowAnimation:),</span><br><span class="line">    <span class="keyword">@selector</span>(moveSection:toSection:),</span><br><span class="line">    <span class="keyword">@selector</span>(insertRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">    <span class="keyword">@selector</span>(deleteRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">    <span class="keyword">@selector</span>(reloadRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">    <span class="keyword">@selector</span>(moveRowAtIndexPath:toIndexPath:)</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; <span class="keyword">sizeof</span>(selectors) / <span class="keyword">sizeof</span>(SEL); ++index) &#123;</span><br><span class="line">    SEL originalSelector = selectors[index];</span><br><span class="line">    SEL swizzledSelector = <span class="built_in">NSSelectorFromString</span>([<span class="string">@"fd_"</span> stringByAppendingString:<span class="built_in">NSStringFromSelector</span>(originalSelector)]);</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-自带提示的keypath宏："><a href="#6-自带提示的keypath宏：" class="headerlink" title="6. 自带提示的keypath宏："></a>6. 自带提示的<code>keypath</code>宏：</h4>   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define keypath2(OBJ, PATH) \</span></span><br><span class="line"> (((<span class="keyword">void</span>)(<span class="literal">NO</span> &amp;&amp; ((<span class="keyword">void</span>)OBJ.PATH, <span class="literal">NO</span>)), <span class="meta"># PATH))</span></span><br></pre></td></tr></table></figure><h4 id="7-逗号表达式："><a href="#7-逗号表达式：" class="headerlink" title="7. 逗号表达式："></a>7. 逗号表达式：</h4><pre><code>逗号表达式取后值，但前值的表达式参与运算，可用`void`忽略编译器警告</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = ((void)(1+2), 2); // a == 2</span><br></pre></td></tr></table></figure><pre><code>于是上面的`keypath`宏的输出结果是`#PATH`也就是一个`c`字符串 </code></pre><h4 id="8-C函数重载标示符："><a href="#8-C函数重载标示符：" class="headerlink" title="8. C函数重载标示符："></a>8. <code>C</code>函数重载标示符：</h4><blockquote><p><a href="https://github.com/rickytan/RTRootNavigationController/blob/master/RTRootNavigationController/Classes/RTRootNavigationController.m" target="_blank" rel="noopener">RTRootNavigationController</a> 中有用到这个技巧</p></blockquote>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute((overloadable)) NSInteger ZD_SumFunc(NSInteger a, NSInteger b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">__attribute((overloadable)) NSInteger ZD_SumFunc(NSInteger a, NSInteger b, NSInteger c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ol><li><p><a href="http://blog.sunnyxx.com/2014/08/02/objc-weird-code/" target="_blank" rel="noopener">objc非主流代码技巧</a></p></li><li><p><a href="https://pspdfkit.com/blog/2017/even-swiftier-objective-c/" target="_blank" rel="noopener">Even Swiftier Objective-C</a></p></li><li><p><a href="http://www.jb51.net/books/620682.html" target="_blank" rel="noopener">《C语言编程魔法书》</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt; &amp;amp;&amp;amp; &lt;code&gt;Objective-C&lt;/code&gt;代码技巧 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&quot;1-GNU-C的赋值扩展：&quot;&gt;&lt;a href=&quot;#1-GNU-C的赋值扩展
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Block捕获外部变量原理探究</title>
    <link href="http://yoursite.com/2018/08/17/Block%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/08/17/Block捕获外部变量原理探究/</id>
    <published>2018-08-16T16:28:03.000Z</published>
    <updated>2018-08-28T11:25:13.173Z</updated>
    
    <content type="html"><![CDATA[<p>在此之前先介绍一下<strong>block 基本语法</strong>：</p><p><img src="http://olmn3rwny.bkt.clouddn.com/20170330193208_8X7KiF_Screenshot.jpeg" alt="block语法"></p><details open><br><summary>Block Syntax Code</summary><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block as a local variable</span></span><br><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block as a property</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) returnType (^blockName)(parameterTypes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block as a method parameter</span></span><br><span class="line">- (<span class="keyword">void</span>)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block as an argument to a method call</span></span><br><span class="line">[someObject someMethodThatTakesABlock: ^returnType (parameters) &#123;...&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block as typedef</span></span><br><span class="line"><span class="keyword">typedef</span> returnType (^TypeName)(parameterTypes);</span><br><span class="line">TypeName blockName = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure><br><br></details><p>对<code>Object-C</code>文件执行 <code>xcrun -sdk iphonesimulator clang -rewrite-objc fileName.m</code> 操作来获取伪代码，仅供技术探究。</p><p>先把<code>__block_impl</code>结构体拿出来放在最前面，最终block调用时都会被强转成这种类型，下面好多地方会用到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>isa指针：指向一个类对象，在非GC模式下有三种类型：_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock；</li><li>Flags：block的负载信息（引用计数和类型信息），按位存储；</li><li>Reserved：保留变量；</li><li>FuncPtr：指向block函数地址的指针。</li><li>descriptor：是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。</li></ul></blockquote><p>接下来进入正题：</p><blockquote><p>P.S：以下<code>Objective-C</code>的代码都处在ARC环境下</p></blockquote><h3 id="1、不加-block的情况"><a href="#1、不加-block的情况" class="headerlink" title="1、不加__block的情况:"></a>1、不加__block的情况:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">[mutArr addObject:@<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>clang</code>操作后的<code>C++</code>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义block的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  NSMutableArray *mutArr;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSMutableArray *_mutArr, <span class="keyword">int</span> flags=<span class="number">0</span>) : mutArr(_mutArr) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为调用`block`时执行的方法</span></span><br><span class="line"><span class="comment">// 此`mutArr`是在最初定义`block`时 为结构体传进去的局部变量`mutArr`的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="comment">// bound by copy:这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。</span></span><br><span class="line">  NSMutableArray *mutArr = __cself-&gt;mutArr; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">   ((<span class="keyword">void</span> (*)(id, SEL, ObjectType))(<span class="keyword">void</span> *)objc_msgSend)((id)mutArr, sel_registerName(<span class="string">"addObject:"</span>), (id)((NSNumber *(*)(Class, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)(objc_getClass(<span class="string">"NSNumber"</span>), sel_registerName(<span class="string">"numberWithInt:"</span>), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的copy函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;mutArr, (<span class="keyword">void</span>*)src-&gt;mutArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;mutArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"> </span><br><span class="line">  NSMutableArray *mutArr = ((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"array"</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可以看出block变量实际上就是一个指向结构体`__main_block_impl_0`的指针,而结构体的第三个元素是局部变量mutArr的值</span></span><br><span class="line">  <span class="comment">// 此处捕获的直接就是`mutArr`局部变量</span></span><br><span class="line">  <span class="keyword">void</span>(*block)() = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, mutArr, <span class="number">570425344</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面调用`block`的方法实质其实是: 指向结构体的指针`block`访问其`FuncPtr`元素(即,在定义block时为`FuncPtr`元素传进去的`__main_block_func_0`方法)</span></span><br><span class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="2、添加-block的情况"><a href="#2、添加-block的情况" class="headerlink" title="2、添加__block的情况:"></a>2、添加__block的情况:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">__block <span class="built_in">NSMutableArray</span> *mutArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">[mutArr addObject:@<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[mutArr addObject:<span class="string">@"hello"</span>];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>clang</code>后的<code>C++</code>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由下面的代码可知: `__block`的作用就是定义一个新的结构体来包裹原来的变量</span></span><br><span class="line"><span class="comment">// 定义一个保存变量的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_mutArr_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_mutArr_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> NSMutableArray *mutArr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// block 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">// 包含捕获的局部变量的结构体指针</span></span><br><span class="line">  __Block_byref_mutArr_0 *mutArr; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_mutArr_0 *_mutArr, <span class="keyword">int</span> flags=<span class="number">0</span>) : mutArr(_mutArr-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在block内部对`mutArr`操作 (block回调时执行的函数)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="comment">// 拿到 包含捕获的局部变量 的结构体指针</span></span><br><span class="line">   __Block_byref_mutArr_0 *mutArr = __cself-&gt;mutArr; <span class="comment">// bound by ref</span></span><br><span class="line">   <span class="comment">// 通过上面的结构体指针一步步拿到`mutArr`数组</span></span><br><span class="line">   ((<span class="keyword">void</span> (*)(id, SEL, ObjectType))(<span class="keyword">void</span> *)objc_msgSend)((id)(mutArr-&gt;__forwarding-&gt;mutArr), sel_registerName(<span class="string">"addObject:"</span>), (id)((NSNumber *(*)(Class, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)(objc_getClass(<span class="string">"NSNumber"</span>), sel_registerName(<span class="string">"numberWithInt:"</span>), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;mutArr, (<span class="keyword">void</span>*)src-&gt;mutArr, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;mutArr, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">  __attribute__((__blocks__(byref))) __Block_byref_mutArr_0 mutArr = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_mutArr_0 *)&amp;mutArr, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_mutArr_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"array"</span>))&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 与不加__block差不多,`block`变量还是一个指向`__main_block_impl_0`结构体的指针,区别在于第三个参数变了. 第三个参数是包含局部变量`mutArr`的结构体指针.</span></span><br><span class="line">  <span class="comment">// 即block捕获的是持有`mutArr`的结构体指针</span></span><br><span class="line">  <span class="keyword">void</span>(*block)() = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_mutArr_0 *)&amp;mutArr, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在block外部对`mutArr`操作</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 此处对`mutArr`数组对象进行操作,获取`mutArr`也是和`block`内部的获取方法一样,</span></span><br><span class="line"><span class="comment">// 都是通过持有`mutArr`的结构体一步步获取到`mutArr`数组,</span></span><br><span class="line"><span class="comment">// 所以,在block内外,操作的都是同一个`mutArr`对象.都是通过包含`mutArr`对象的`__Block_byref_mutArr_0`结构体对其进行间接操作处理的</span></span><br><span class="line"><span class="comment">// 这也就是为什么添加`__block`后还能改变原来的对象的原因</span></span><br><span class="line">  ((<span class="keyword">void</span> (*)(id, SEL, ObjectType))(<span class="keyword">void</span> *)objc_msgSend)((id)(mutArr.__forwarding-&gt;mutArr), sel_registerName(<span class="string">"addObject:"</span>), (id)(NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_b07809_mi_0);</span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>虽然NSMutableArray前面加不加__block，都不会影响往数组中添加数据，但是当在block中给<code>mutArr</code>重新赋值的时候就有区别了。<br><img src="http://olmn3rwny.bkt.clouddn.com/20180828184027_Pll0EO_blockTest1.jpeg" alt="blockTest1"><br>如果你想对<code>mutArr</code>变量重新赋值一个新的<code>array</code>实例，改变原变量的指针，那么不加<code>_block</code>是不行的，但是如果只是单纯的<code>add</code>一个数据进去实际上改变的是变量所指的那个<code>mutArr</code>内存区域，这样是没有区别的。</p><h3 id="3、静态变量"><a href="#3、静态变量" class="headerlink" title="3、静态变量:"></a>3、静态变量:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *myString = <span class="string">@"111"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">[myString stringByAppendingString:<span class="string">@"222"</span>];</span><br><span class="line"></span><br><span class="line">myString = <span class="string">@"444"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myString);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[myString stringByAppendingString:<span class="string">@"333"</span>];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>clang</code>之后的<code>C++</code>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">// 注意这里, 外面的静态变量被捕获了,不过捕获的是对象的指针</span></span><br><span class="line">  NSString **myString;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSString **_myString, <span class="keyword">int</span> flags=<span class="number">0</span>) : myString(_myString) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSString **myString = __cself-&gt;myString; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过对`myString`指针进行取值操作(*myString),拿到 myString</span></span><br><span class="line">   ((NSString *(*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)(*myString), sel_registerName(<span class="string">"stringByAppendingString:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_1);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 由下面的伪代码可以看出,由于`myString`是指针,所以通过`*`操作来获取到原来的变量,</span></span><br><span class="line"><span class="comment">// 然后再对其进行重新赋值操作</span></span><br><span class="line">(*myString) = (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_121621_mi_2;</span><br><span class="line"></span><br><span class="line">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_2, (*myString));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">  _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;myString, (<span class="keyword">void</span>*)src-&gt;myString, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">  _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;myString, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> NSString *myString = (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_0;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// block捕获的是静态变量的指针</span></span><br><span class="line">  <span class="keyword">void</span>(*block)() = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;myString, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">  ((NSString *(*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)myString, sel_registerName(<span class="string">"stringByAppendingString:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_3);</span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="4、全局变量"><a href="#4、全局变量" class="headerlink" title="4、全局变量:"></a>4、全局变量:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *myString = <span class="string">@"111"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">[myString stringByAppendingString:<span class="string">@"222"</span>];</span><br><span class="line"></span><br><span class="line">myString = <span class="string">@"444"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myString);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[myString stringByAppendingString:<span class="string">@"333"</span>];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>clang</code>操作执行之后的<code>C++</code>伪代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">NSString *myString = (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_0;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block结构体并没有捕获全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三个函数都是在用到全局变量`myString`的时候直接从内存去获取</span></span><br><span class="line">   ((NSString *(*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)myString, sel_registerName(<span class="string">"stringByAppendingString:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_1);</span><br><span class="line"></span><br><span class="line">   myString = (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_2;</span><br><span class="line"></span><br><span class="line">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_3, myString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>(*block)() = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">  ((NSString *(*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)myString, sel_registerName(<span class="string">"stringByAppendingString:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_4);</span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><ol><li><p>局部变量：不加<code>__block</code>，block内部捕获的是局部变量的值，而且如果局部变量是数值类型（比如int）不会有<code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code> 两个函数，如果是引用类型（比如NSArray）则会有这个函数，说明对于值类型变量是直接定义新变量并赋值相同，对于引用类型变量是定义一个新变量并copy它。</p></li><li><p>局部变量：而添加<code>__block</code>后,原来的局部变量会被放入到一个<code>__Block_byref_变量名_0</code>类型的结构体中，然后block内部当捕获局部变量时其实是捕获的是这个结构体的指针，当获取原来的局部变量时(不管是在block内还是block外)，其实都是通过这个结构体或者这个结构体指针来拿到原来的局部变量，再进行操作的。这也就是为什么添加<code>__block</code>后可以对block内捕获的局部变量进行重新赋值等操作。</p></li><li><p>静态变量：block直接捕获的是静态变量的指针，前后都是对指针进行操作。</p></li><li><p>全局变量（或 全局静态变量）：block并没有捕获变量，而是在结构体的执行方法中直接使用了全局变量，是在执行时才去取值，一直都是获取变量的最新值。而且细心点我们可以发现，对于没有捕获全局变量的block中也没有<code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code> 两个函数（用于在调用前后修改相应变量的引用计数），即没有发生copy操作。</p></li><li><p>在ARC环境下：在单独声明block的时候，block还是会在栈上的；当block作为参数返回的时候，block也会自动被移到堆上；在ARC下，只要指针过一下strong指针，或者由函数返回都会把block移动到堆上。</p><blockquote><p><code>__main_block_copy_0</code> 中的 <code>_Block_object_assign</code> 函数相当于<code>retain</code>实例方法，使 block 的成员变量持有捕获到的对象。 <code>__main_block_dispose_0</code> 中的 <code>_Block_object_dispose</code> 函数相当于 <code>release</code> 实例方法，释放 block 的成员变量持有的对象。</p></blockquote><p> Objective-C 中的三中block <code>__NSStackBlock__</code>、<code>__NSMallocBlock</code>、<code>__NSGloballBlock</code> 会在下面的情况下出现：</p></li></ol><table><thead><tr><th></th><th style="text-align:center">ARC</th><th>非ARC</th></tr></thead><tbody><tr><td>捕获外部变量</td><td style="text-align:center"><code>__NSStackBlock__</code> <br> <code>__NSMallocBlock__</code></td><td><code>__NSStackBlock__</code></td></tr><tr><td>未捕获外部变量</td><td style="text-align:center"><code>__NSGlobalBlock__</code></td><td><code>__NSGlobalBlock__</code></td></tr></tbody></table><ul><li>在 ARC 中，捕获了外部变量的block的类型会是<code>__NSStackBlock__</code> 或者 <code>__NSMallocBlock__</code>，如果 block 被赋值给了某个变量，在这个过程中会执行<code>_Block_copy</code>，将原有的 <code>__NSStackBlock__</code> 变成 <code>__NSMallocBlock__</code>；但是如果 block 没有被赋值给某个变量，那它的类型就是<code>__NSStackBlock__</code>；没有捕获外部变量的 block 的类则是 <code>__NSGlobalBlock__</code> ，既不在栈上，也不在堆上，它类似于 C 语言函数一样，会在代码段中。</li><li>在非 ARC 中，捕获了外部变量的 block 的类会是<code>__NSStackBlock__</code>，放置在栈上；没有捕获外部变量的 block 与 ARC 环境下的情况是相同的，类型是<code>__NSGlobalBlock__</code>，放置在代码段中。</li></ul><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h3><ol><li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">谈Objective-C Block的实现</a></li><li><a href="http://draveness.me/block-retain-object" target="_blank" rel="noopener">iOS中的block是如何持有对象的</a></li><li><a href="http://www.jianshu.com/p/a5dd014edb13" target="_blank" rel="noopener">深入分析Objective-C block、weakself、strongself实现原理</a></li><li><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">block-copy</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在此之前先介绍一下&lt;strong&gt;block 基本语法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://olmn3rwny.bkt.clouddn.com/20170330193208_8X7KiF_Screenshot.jpeg&quot; alt=&quot;block
      
    
    </summary>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>解读ReactiveCocoa中的部分函数</title>
    <link href="http://yoursite.com/2018/08/13/%E8%A7%A3%E8%AF%BBReactiveCocoa%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/13/解读ReactiveCocoa中的部分函数/</id>
    <published>2018-08-13T15:11:19.000Z</published>
    <updated>2018-08-28T11:27:56.908Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、bind、flattenMap和map"><a href="#一、bind、flattenMap和map" class="headerlink" title="一、bind、flattenMap和map"></a>一、bind、flattenMap和map</h4><blockquote><p>冷信号与热信号：</p><ol><li><p>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。</p><ol start="2"><li>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。</li><li>冷信号可以理解为<code>点播</code>，每次订阅都从头开始；热信号可以理解为<code>直播</code>，订阅时从当前的状态开始；</li></ol></li></ol></blockquote><hr><blockquote><ul><li><code>map</code>和<code>flatten</code>是基于<code>flattenMap</code>,而<code>flattenMap</code>是基于<code>bind:</code>,所以在此之前先来看看<code>bind</code>函数。</li></ul></blockquote><h5 id="1-bind"><a href="#1-bind" class="headerlink" title="1. bind:"></a>1. bind:</h5><ul><li>具体来看源码（为方便理解，去掉了源代码中<code>RACDisposable</code>, <code>@synchronized</code>, <code>@autoreleasepool</code>相关代码)。当新信号<code>N</code>被外部订阅时，会进入信号<code>N</code>的<code>didSubscribeBlock</code> (1)，之后订阅原信号<code>O</code> (2)，当原信号<code>O</code>有值输出后就用<code>bind</code>函数传入的<code>bindBlock</code>将其变换成中间信号<code>M</code> (3), 并马上对其进行订阅(4)，最后将中间信号<code>M</code>的输出作为新信号<code>N</code>的输出 (5)。即：当新生成的信号被订阅时，源信号也会立即被订阅。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">        RACStreamBindBlock bindingBlock = block(); <span class="comment">// (MARK:此处执行block回调,生成一个bindingBlock)</span></span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;  <span class="comment">// (2)</span></span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">id</span> middleSignal = bindingBlock(x, &amp;stop);  <span class="comment">// (3) map与flatten结果不同，问题就出在这里</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (middleSignal != <span class="literal">nil</span>) &#123;</span><br><span class="line">                RACDisposable *disposable = [middleSignal subscribeNext:^(<span class="keyword">id</span> x) &#123; <span class="comment">// (4)</span></span><br><span class="line">                    [subscriber sendNext:x];  <span class="comment">// (5)</span></span><br><span class="line">                &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                    [subscriber sendError:error];</span><br><span class="line">                &#125; completed:^&#123;</span><br><span class="line">                    [subscriber sendCompleted];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-flattenMap"><a href="#2-flattenMap" class="headerlink" title="2. flattenMap:"></a>2. flattenMap:</h5><p><code>flattenMap</code>其实就是对<code>bind:</code>方法进行了一些安全检查，它最终返回的是<code>bindBlock</code>执行后生成的那个中间<code>signal</code>又被订阅后传递出的值的信号，而<code>map</code>方法返回的是<code>bindBlock</code>的执行结果生成的那个信号，没有再加工处理（即被订阅，再发送值）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)flattenMap:(RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        <span class="comment">/// @return 返回的是RACStreamBindBlock</span></span><br><span class="line">        <span class="comment">/// @discussion</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// 跟`bind：`方法中的代码对应起来如下：</span></span><br><span class="line">        <span class="comment">/// BOOL stop = NO;</span></span><br><span class="line">         <span class="comment">/// id middleSignal = bindingBlock(x, &amp;stop);</span></span><br><span class="line">         <span class="comment">///</span></span><br><span class="line">         <span class="comment">/// 与上面`bind:`函数中的(3)对应起来,</span></span><br><span class="line">         <span class="comment">/// 可以看出bindBlock中的x是原信号被subscribe后传出的值，即对应下面的value</span></span><br><span class="line">         <span class="comment">/// 也即flattenMap中的 block执行后传出的值，</span></span><br><span class="line">         <span class="comment">/// 即上面的(RACStream * (^ block)(id value))中的value</span></span><br><span class="line">         <span class="comment">/// flattenMap:后的那个block其实与bind:后的block基本是一样的，参数都是原信号发出的值，返回值都是RACStream，差别就是一个bool参数，所以说，flattenMap其实就是对bind方法进行了一些安全检查</span></span><br><span class="line">         <span class="comment">/// 综上所述：*flattenMap方法中传进来的那个block参数值就是原信号被订阅后发送的值*</span></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">// 下面这个value并不是flattenMap后面block中的那个value，而是(就近原则)原信号中的值；flattenMap后面那个block中的value的值是原信号发出的值被转换为中间信号后，又被订阅后发出去的值，这里要区分开；</span></span><br><span class="line">            <span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">            <span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-map"><a href="#3-map" class="headerlink" title="3. map:"></a>3. map:</h5><p><code>map</code>: 下面是<code>map</code>方法的源码，可以看出，<code>map</code>只是对<code>flattenMap</code>传出的<code>vaue</code>（即原信号传出的值）进行了<code>mapBlock</code>操作，并没有再进行订阅操作，即并不像<code>bind：</code>一样再次对原信号进行<code>bindBlock</code>后生成的中间信号进行订阅。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -map:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-flatten"><a href="#4-flatten" class="headerlink" title="4. flatten:"></a>4. flatten:</h5><p><code>flatten</code>: 该操作主要作用于信号的信号。原信号<code>O</code>作为信号的信号，在被订阅时输出的数据必然也是个信号<code>(signalValue)</code>，这往往不是我们想要的。当我们执行<code>[O flatten]</code>操作时，因为<code>flatten</code>内部调用了<code>flattenMap</code> (1)，<code>flattenMap</code>里对应的中间信号就是原信号<code>O</code>输出的<code>signalValue</code> (2)。按照之前分析的经验，在<code>flattenMap</code>操作中新信号<code>N</code>输出的结果就是各中间信号<code>M</code>输出的集合。因此在<code>flatten</code>操作中新信号<code>N</code>被订阅时输出的值就是原信号<code>O</code>的各个子信号输出值的集合。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)flatten</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> flattenMap:^(RACSignal *signalValue) &#123; <span class="comment">// (1)</span></span><br><span class="line">            <span class="comment">/// 返回值作为bind:中的中间信号</span></span><br><span class="line">        <span class="keyword">return</span> signalValue; <span class="comment">// (2)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-小结："><a href="#5-小结：" class="headerlink" title="5. 小结："></a>5. <strong>小结：</strong></h5><p>以前一直不理解<code>flatten</code>与<code>map</code>之间的区别，然后经过不断在源码中打断点，一步步跟代码，终于是明白了：<br><code>flatten</code>和<code>map</code>后面的block返回结果其实最终都会变为<code>bind:</code>方法中的中间信号，但是<code>flatten:</code>的<code>block</code>是直接把原信号发出的值返回来作为中间信号的，所以中间信号被订阅，其实就是原信号发出的值又被订阅，这也就是<code>flatten:</code>能拿到信号中的信号中的值的原因。<br>而<code>map:</code>后面的block是把原信号发出的值加工处理了的，又生成了一个新的信号，即<code>map:</code>方法<code>block</code>返回的中间信号已经不是原来的信号中的信号了，而是把原信号发出的值作为它的包含值的一个新的信号，它被订阅时，发送的是原信号发出的那个值，这就是<code>map</code>拿不到原信号中的信号的原因。<br>说白了就是<code>flatten:</code>操作的始终是原来的信号，而<code>map:</code>会生成一个包含原信号发送值的新信号。</p><hr><h4 id="二、multicast"><a href="#二、multicast" class="headerlink" title="二、multicast:"></a>二、multicast:</h4><p>简单分析一下 <code>- (RACMulticastConnection *)multicast:(RACSubject *)subject;</code>方法：</p><ul><li>1、当 <code>RACSignal</code> 类的实例调用 <code>- (RACMulticastConnection *)multicast:(RACSubject *)subject</code> 时，以 <code>self</code> 和 <code>subject</code> 作为构造参数创建一个 <code>RACMulticastConnection</code> 实例。</li><li>2、<code>RACMulticastConnection</code> 构造的时候，保存 <code>source</code> 和 <code>subject</code> 作为成员变量，创建一个 <code>RACSerialDisposable</code> 对象，用于取消订阅。</li><li>3、当 <code>RACMulticastConnection</code> 类的实例调用 <code>- (RACDisposable *)connect</code> 这个方法的时候，判断是否是第一次。如果是的话 用 <code>_signal</code> 这个成员变量（RACSubject类型）来订阅 <code>sourceSignal</code>， 之后返回 <code>self.serialDisposable</code>，否则直接返回 <code>self.serialDisposable</code> 。</li><li>4、<code>RACMulticastConnection</code> 的 <code>signal</code> 只读属性，就是一个热信号，订阅这个热信号就避免了各种副作用的问题。它会在 <code>- (RACDisposable *)connect</code> 第一次调用后，根据 <code>sourceSignal</code> 的订阅结果来传递事件。</li><li>5、想要确保第一次订阅就能成功订阅 <code>sourceSignal</code> ，可以使用 <code>- (RACSignal *)autoconnect</code> 这个方法，它保证了第一个订阅者触发 <code>sourceSignal</code> 的订阅，也保证了当返回的信号所有订阅者都关闭连接后 <code>sourceSignal</code> 被正确关闭连接。</li><li>6、这里面订阅 <code>sourceSignal</code> 是重点，<code>_signal</code>是一个<code>RACSubject</code>类型，它里面维护着一个可变数组，每当它被订阅时，会把所有的<strong>订阅者</strong>保存到这个数组中。当<code>connection.signal</code>（即<code>_signal</code>）被订阅时，其实是<code>_signal</code>被订阅了。由于<code>_signal</code>是<code>RACSubject</code>类型对象，且<code>_signal</code>也是信号，它里面重写了订阅方法，所以会执行它自己的<code>subscribe:</code>方法，执行此方法之前订阅者参数是<code>RACSubscriber</code>类型，但是在这个subscribe方法中，初始化了一个<code>RACPassthroughSubscriber</code>实例对象，使它作为新的订阅者（其实就是对订阅者进行了一层包装），并把它存入了<code>subject</code>维护的那个订阅者数组里（原来的<code>订阅者</code>和<code>信号</code>被<code>RACPassthroughSubscriber</code>实例保存了），所以数组中最终保存的是<code>RACPassthroughSubscriber</code>类型的订阅者，然后它发送消息的时候调的还是它持有的<code>subject</code>对象进行发送消息。</li><li>7、当<code>RACMulticastConnection</code>调用<code>connect</code>方法时，源信号<code>sourceSignal</code>被<code>_signal</code>订阅，即执行<code>[sourceSignal subscribe:subject]</code>方法，然后执行订阅<code>subscribeNext:</code>block回调，在回调中执行<code>sendNext:</code>，由于订阅者是<code>RACSubject</code>类型的实例对象，它里面也会执行<code>sendNext:</code>方法，此方法中会遍历它的数组中的订阅者依次发送消息。</li><li>8、<code>connect</code>时订阅者是<code>RACSubject</code>发送的<code>sendNext:</code>，subject会拿到它那个订阅者数组遍历，取出其中的<code>RACPassthroughSubscriber</code>对象，然后用<code>RACPassthroughSubscriber</code>对象中的真实的订阅者去发送数据。</li></ul><hr><h4 id="三、RACCommand"><a href="#三、RACCommand" class="headerlink" title="三、RACCommand"></a>三、RACCommand</h4><p>不废话，直接上源码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal * (^)(<span class="keyword">id</span> input))signalBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(signalBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    _activeExecutionSignals = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    _signalBlock = [signalBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听`activeExecutionSignals`数组</span></span><br><span class="line">    RACSignal *newActiveExecutionSignals = [[[[[<span class="keyword">self</span></span><br><span class="line">        rac_valuesAndChangesForKeyPath:@keypath(<span class="keyword">self</span>.activeExecutionSignals) options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>]</span><br><span class="line">        reduceEach:^(<span class="keyword">id</span> _, <span class="built_in">NSDictionary</span> *change) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> *signals = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">            <span class="keyword">if</span> (signals == <span class="literal">nil</span>) <span class="keyword">return</span> [RACSignal empty];</span><br><span class="line">            <span class="comment">// 把数组转换为信号发送出去</span></span><br><span class="line">            <span class="keyword">return</span> [signals.rac_sequence signalWithScheduler:RACScheduler.immediateScheduler];</span><br><span class="line">        &#125;]</span><br><span class="line">        concat]            <span class="comment">// 把各个信号中的信号连接起来</span></span><br><span class="line">        publish]            <span class="comment">// 广播出去，可以被多个订阅者订阅</span></span><br><span class="line">        autoconnect];    <span class="comment">// 有订阅了再发送广播</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把上面的信号`map`一下,当出现错误的时候转换成`empty`空信号,并在主线程上传递</span></span><br><span class="line">    _executionSignals = [[[newActiveExecutionSignals</span><br><span class="line">        map:^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="keyword">return</span> [signal catchTo:[RACSignal empty]];</span><br><span class="line">        &#125;]</span><br><span class="line">        deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">        setNameWithFormat:<span class="string">@"%@ -executionSignals"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先通过`ignoreValues`方法屏蔽掉`sendNext:`的结果，只保留`sendError:`和`sendCompleted`结果，然后再通过`catch:`方法拿到所有的`sendError:`结果，发送给订阅者。</span></span><br><span class="line">    <span class="comment">// 此处用的是`flattenMap`，可以直接获取到错误信息。</span></span><br><span class="line">    RACMulticastConnection *errorsConnection = [[[newActiveExecutionSignals</span><br><span class="line">        flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="keyword">return</span> [[signal</span><br><span class="line">                ignoreValues]</span><br><span class="line">                catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                    <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:error];</span><br><span class="line">                &#125;];</span><br><span class="line">        &#125;]</span><br><span class="line">        deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">        publish];</span><br><span class="line"></span><br><span class="line">    _errors = [errorsConnection.signal setNameWithFormat:<span class="string">@"%@ -errors"</span>, <span class="keyword">self</span>];</span><br><span class="line">    [errorsConnection connect];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据执行信号的数量判断`RACCommand`当前是否正在执行</span></span><br><span class="line">    RACSignal *immediateExecuting = [RACObserve(<span class="keyword">self</span>, activeExecutionSignals) map:^(<span class="built_in">NSArray</span> *activeSignals) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(activeSignals.count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在执行</span></span><br><span class="line">    _executing = [[[[[immediateExecuting</span><br><span class="line">        deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">        <span class="comment">// This is useful before the first value arrives on the main thread.</span></span><br><span class="line">        startWith:@NO]</span><br><span class="line">        distinctUntilChanged]</span><br><span class="line">        replayLast]</span><br><span class="line">        setNameWithFormat:<span class="string">@"%@ -executing"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果允许并发执行，返回`YES`，否则反转`immediateExecuting`信号的结果</span></span><br><span class="line">    RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">        <span class="keyword">if</span>:RACObserve(<span class="keyword">self</span>, allowsConcurrentExecution)</span><br><span class="line">        then:[RACSignal <span class="keyword">return</span>:@YES]</span><br><span class="line">        <span class="keyword">else</span>:[immediateExecuting not]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enabledSignal == <span class="literal">nil</span>) &#123;</span><br><span class="line">        enabledSignal = [RACSignal <span class="keyword">return</span>:@YES];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        enabledSignal = [[[enabledSignal</span><br><span class="line">            startWith:@YES]</span><br><span class="line">            takeUntil:<span class="keyword">self</span>.rac_willDeallocSignal]</span><br><span class="line">            replayLast];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _immediateEnabled = [[RACSignal</span><br><span class="line">        combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">        and];</span><br><span class="line"></span><br><span class="line">    _enabled = [[[[[<span class="keyword">self</span>.immediateEnabled</span><br><span class="line">        take:<span class="number">1</span>]</span><br><span class="line">        concat:[[<span class="keyword">self</span>.immediateEnabled skip:<span class="number">1</span>] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">        distinctUntilChanged]</span><br><span class="line">        replayLast]</span><br><span class="line">        setNameWithFormat:<span class="string">@"%@ -enabled"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时，我们通常会去生成一个RACCommand对象，并传入一个返回signal对象的block。每次RACCommand execute 执行操作时，都会通过传入的这个signal block生成一个执行信号E (1)，并将该信号添加到RACCommand内部信号数组activeExecutionSignals中 (2)，同时将信号E由冷信号转成热信号(3)，最后订阅该热信号(4)，并将其返回(5)。</span></span><br><span class="line">- (RACSignal *)execute:(<span class="keyword">id</span>)input &#123; </span><br><span class="line">    RACSignal *signal = <span class="keyword">self</span>.signalBlock(input); <span class="comment">//（1）</span></span><br><span class="line">    RACMulticastConnection *connection = [[signal subscribeOn:RACScheduler.mainThreadScheduler] multicast:[RACReplaySubject subject]]; <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line">    @weakify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> addActiveExecutionSignal:connection.signal]; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">    [connection.signal subscribeError:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span> removeActiveExecutionSignal:connection.signal];</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span> removeActiveExecutionSignal:connection.signal];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [connection connect]; <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [connection.signal]; <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、其他："><a href="#四、其他：" class="headerlink" title="四、其他："></a>四、其他：</h4><p>说说几个函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是对`allowsConcurrentExecution`属性的处理方法，利用了属性的原子性，防止资源竞争，值得学习</span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowsConcurrentExecution;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *activeExecutionSignals;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The mutable array backing `activeExecutionSignals`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This should only be used while synchronized on `self`.</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_activeExecutionSignals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomic backing variable for `allowsConcurrentExecution`.</span></span><br><span class="line">    <span class="keyword">volatile</span> uint32_t _allowsConcurrentExecution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============================================================</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)allowsConcurrentExecution &#123;</span><br><span class="line">    <span class="keyword">return</span> _allowsConcurrentExecution != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAllowsConcurrentExecution:(<span class="built_in">BOOL</span>)allowed &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:@keypath(<span class="keyword">self</span>.allowsConcurrentExecution)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">        <span class="comment">// 以下函数类似于 `||`  </span></span><br><span class="line">        <span class="comment">// 只要前者和后者有一个为真，那么后者就为真；即：不管`_allowsConcurrentExecution`是否等于1，它最终都会变为`1`，因为前者是1；</span></span><br><span class="line">        OSAtomicOr32Barrier(<span class="number">1</span>, &amp;_allowsConcurrentExecution);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以下函数类似于 `&amp;&amp;`  </span></span><br><span class="line">        <span class="comment">// 前后二者必须都为真，后者才会变为真；即：不管`_allowsConcurrentExecution`等于0还是1，它最终都会变为`0`，因为前者是0</span></span><br><span class="line">        OSAtomicAnd32Barrier(<span class="number">0</span>, &amp;_allowsConcurrentExecution);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动调用KVO，通知监听者 `allowsConcurrentExecution`属性改变了</span></span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:@keypath(<span class="keyword">self</span>.allowsConcurrentExecution)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//========================数组属性================================</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)activeExecutionSignals &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [_activeExecutionSignals <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addActiveExecutionSignal:(RACSignal *)signal &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>([signal isKindOfClass:RACSignal.class]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSIndexSet</span> *indexes = [<span class="built_in">NSIndexSet</span> indexSetWithIndex:_activeExecutionSignals.count];</span><br><span class="line">        [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeInsertion</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">        [_activeExecutionSignals addObject:signal];</span><br><span class="line">        [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeInsertion</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeActiveExecutionSignal:(RACSignal *)signal &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>([signal isKindOfClass:RACSignal.class]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前数组中获取到要移除的对象的indexSets，如果不存在直接返回</span></span><br><span class="line">        <span class="built_in">NSIndexSet</span> *indexes = [_activeExecutionSignals indexesOfObjectsPassingTest:^ <span class="built_in">BOOL</span> (RACSignal *obj, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj == signal;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indexes.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 手动调用KVO，通知监听者 `activeExecutionSignals` 数组的改变</span></span><br><span class="line">        [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">        [_activeExecutionSignals removeObjectsAtIndexes:indexes];</span><br><span class="line">        [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span> valuesAtIndexes:indexes forKey:@keypath(<span class="keyword">self</span>.activeExecutionSignals)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h4><h5 id="附1：部分函数的图表解释"><a href="#附1：部分函数的图表解释" class="headerlink" title="附1：部分函数的图表解释"></a>附1：部分函数的图表解释</h5><blockquote><p><img src="http://img0.tuicool.com/QbyMjyR.png" alt="CombineLatest"><br><img src="http://img2.tuicool.com/JBrMn2r.png" alt="Zip"><br><img src="http://img0.tuicool.com/Nr2AriV.png" alt="操作结果"><br><img src="http://img1.tuicool.com/U3Mzym3.png" alt="Merge"><br><img src="http://img0.tuicool.com/faIv6bu.png" alt="Concat"></p></blockquote><h5 id="附2：ReactiveCocoa和RxSwift-API图"><a href="#附2：ReactiveCocoa和RxSwift-API图" class="headerlink" title="附2：ReactiveCocoa和RxSwift API图"></a>附2：<code>ReactiveCocoa</code>和<code>RxSwift</code> API图</h5><blockquote><p>引用自<a href="https://github.com/aiqiuqiu/FRPCheatSheeta" target="_blank" rel="noopener">FRPCheatSheeta</a></p></blockquote><p><strong>1. ReactiveCocoa-ObjC</strong><br><img src="http://ww1.sinaimg.cn/large/006tNbRwjw1f69ss3l0y4j31jf1cpwtm.jpg" alt="ReactiveCocoa-Objc"></p><p><strong>2. ReactiveCocoa-Swift</strong><br><img src="http://ww4.sinaimg.cn/large/006tNbRwjw1f69u9n630vj31kw10nk1g.jpg" alt="ReactiveCocoaV4.x-Swift.png"></p><p><strong>3. RxSwift</strong><br><img src="http://ww2.sinaimg.cn/large/006tNbRwjw1f69u2fugtjj317k1n1tis.jpg" alt="RXSwift.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ul><li><a href="http://www.jianshu.com/p/d262f2c55fbe" target="_blank" rel="noopener">RAC核心元素与信号流</a> </li><li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</a> </li><li><a href="http://www.tuicool.com/sites/NRbMbqa" target="_blank" rel="noopener">Halfrost’s Field分析ReactiveCocoa的系列文章</a></li><li><a href="http://www.tuicool.com/articles/QJrqeam" target="_blank" rel="noopener">Reactive Cocoa中的@weakify、@strongify的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、bind、flattenMap和map&quot;&gt;&lt;a href=&quot;#一、bind、flattenMap和map&quot; class=&quot;headerlink&quot; title=&quot;一、bind、flattenMap和map&quot;&gt;&lt;/a&gt;一、bind、flattenMap和map&lt;/
      
    
    </summary>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
      <category term="RAC" scheme="http://yoursite.com/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/13/hello-world/"/>
    <id>http://yoursite.com/2018/08/13/hello-world/</id>
    <published>2018-08-13T14:32:47.000Z</published>
    <updated>2018-08-28T11:32:22.397Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
