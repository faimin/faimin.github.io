[{"categories":["实现原理"],"content":"探索block变量捕获的原理","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"探索block捕获外界变量的原理 在此之前先介绍一下block 基本语法： BlockSyntax Block Syntax // Block as a local variable returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; // Block as a property @property (nonatomic, copy) returnType (^blockName)(parameterTypes); // Block as a method parameter - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; // Block as an argument to a method call [someObject someMethodThatTakesABlock: ^returnType (parameters) {...}]; // Block as typedef typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; 对Object-C文件执行 xcrun -sdk iphonesimulator clang -fobjc-arc -fobjc-runtime=ios -rewrite-objc fileName.m 操作来获取伪代码，仅供技术探究。 先把__block_impl结构体拿出来放在最前面，最终block调用时都会被强转成这种类型，下面好多地方会用到。 struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; isa指针：指向一个类对象，在非GC模式下有三种类型：_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock； Flags：block的负载信息（引用计数和类型信息），按位存储； Reserved：保留变量； FuncPtr：指向block函数地址的指针。 descriptor：是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。 接下来进入正题： p.s：以下Objective-C的代码都处在ARC环境下 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:0:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"1、不加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; block(); } } 执行clang操作后的C++代码: // 定义block的结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSMutableArray *mutArr; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableArray *_mutArr, int flags=0) : mutArr(_mutArr) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 以下为调用`block`时执行的方法 // 此`mutArr`是在最初定义`block`时 为结构体传进去的局部变量`mutArr`的值 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // bound by copy:这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。 NSMutableArray *mutArr = __cself-\u003emutArr; // bound by copy ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)mutArr, sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } // block的copy函数 static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; NSMutableArray *mutArr = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); // 可以看出block变量实际上就是一个指向结构体`__main_block_impl_0`的指针,而结构体的第三个元素是局部变量mutArr的值 // 此处捕获的直接就是`mutArr`局部变量 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, mutArr, 570425344)); // 下面调用`block`的方法实质其实是: 指向结构体的指针`block`访问其`FuncPtr`元素(即,在定义block时为`FuncPtr`元素传进去的`__main_block_func_0`方法) ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:1:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"2、添加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { __block NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; [mutArr addObject:@\"hello\"]; block(); } } 执行clang后的C++代码: // 由下面的代码可知: `__block`的作用就是定义一个新的结构体来包裹原来的变量 // 定义一个保存变量的结构体 （被__block标记的变量会被转化为这种格式的结构体对象） struct __Block_byref_mutArr_0 { void *__isa; __Block_byref_mutArr_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSMutableArray *mutArr; }; // block 结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 包含捕获的局部变量的结构体指针 __Block_byref_mutArr_0 *mutArr; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_mutArr_0 *_mutArr, int flags=0) : mutArr(_mutArr-\u003e__forwarding) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 在block内部对`mutArr`操作 (block回调时执行的函数) static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 拿到 包含捕获的局部变量 的结构体指针 __Block_byref_mutArr_0 *mutArr = __cself-\u003emutArr; // bound by ref // 通过上面的结构体指针一步步拿到`mutArr`数组 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr-\u003e__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; // 这里可以看到结构体中的 __forwarding 指针其实指向的就是其自身 __attribute__((__blocks__(byref))) __Block_byref_mutArr_0 mutArr = {(void*)0,(__Block_byref_mutArr_0 *)\u0026mutArr, 33554432, sizeof(__Block_byref_mutArr_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\"))}; // 与不加__block差不多,`block`变量还是一个指向`__main_block_impl_0`结构体的指针,区别在于第三个参数变了. 第三个参数是包含局部变量`mutArr`的结构体指针. // 即block捕获的是持有`mutArr`的结构体指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, (__Block_byref_mutArr_0 *)\u0026mutArr, 570425344)); // 在block外部对`mutArr`操作 // // 此处对`mutArr`数组对象进行操作,获取`mutArr`也是和`block`内部的获取方法一样, // 都是通过持有`mutArr`的结构体一步步获取到`mutArr`数组, // // 这里要经过 __forwarding 来获取`mutArr`的原因是： // __block 标记的变量有可能被copy到堆上，__forwarding 的作用就是在被copy到堆上时修改指向，使栈和堆上的 __forwarding 都指向堆上的那个副本，这样就保证了block内外操作的都是同一份内存。 // 具体的copy实现可以参见下面的 `_Block_byref_copy` 函数 // // 所以,在block内外,操作的都是同一个`mutArr`对象.都是通过包含`mutArr`对象的`__Block_byref_mutArr_0`结构体对其进行间接操作处理的 // 这也就是为什么添加`__block`后还能改变原来的对象的原因 // // PS: 当我们用__block 标记一个变量以后，当我们用到这个变量时都不是直接使用这个变量了，而是变成了通过`__Block_byref`来操作这个变量 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr.__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)(NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_b07809_mi_0); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; // __block 变量被copy到堆上时的具体实现 static struct Block_byref *_Block_byref_copy(const void *arg) { struct Block_byref *src = (struct Block_byref *)arg; if ((src-\u003eforwarding-","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:2:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"3、静态变量: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { static NSString *myString = @\"111\"; void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang之后的C++代码： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 注意这里, 外面的静态变量被捕获了,不过捕获的是对象的指针 NSString **myString; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString **_myString, int flags=0) : myString(_myString) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString **myString = __cself-\u003emyString; // bound by copy // 通过对`myString`指针进行取值操作(*myString),拿到 myString ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)(*myString), sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_1); // 由下面的伪代码可以看出,由于`myString`是指针,所以通过`*`操作来获取到原来的变量, // 然后再对其进行重新赋值操作 (*myString) = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_121621_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_2, (*myString)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emyString, (void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; static NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_0; // block捕获的是静态变量的指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, \u0026myString, 570425344)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_3); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:3:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"4、全局变量: #import \u003cFoundation/Foundation.h\u003e NSString *myString = @\"111\"; int main(int argc, char *argv[]) { @autoreleasepool { void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang操作执行之后的C++伪代码: NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_0; // block结构体并没有捕获全局变量 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 下面三个函数都是在用到全局变量`myString`的时候直接从内存去获取 ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_1); myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_3, myString); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_4); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:4:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"总结: 局部变量： 不加__block: block内部捕获的是局部变量的值，而且如果局部变量是数值类型（比如int）不会有__main_block_copy_0 和 __main_block_dispose_0 两个函数，如果是引用类型（比如NSArray）则会有这个函数，说明对于值类型变量是直接定义新变量并赋值相同，对于引用类型变量是定义一个新变量并copy这个对象的指针。 添加__block: 原来的局部变量会被放入到一个__Block_byref_变量名_0类型的结构体中，然后block内部当捕获局部变量时其实是捕获的是这个结构体的指针，当获取原来的局部变量时(不管是在block内还是block外)，其实都是通过这个结构体或者这个结构体指针来拿到原来的局部变量再进行操作的。这也就是为什么添加__block后可以对block内捕获的局部变量进行重新赋值等操作。 静态变量： block直接捕获的是静态变量的指针，前后都是对指针进行操作。 全局变量（或 全局静态变量）： block并没有捕获变量，而是在结构体的执行方法中直接使用了全局变量，是在执行时才去取值，一直都是获取变量的最新值。而且细心点我们可以发现，对于没有捕获全局变量的block中也没有__main_block_copy_0 和 __main_block_dispose_0 两个函数（用于在调用前后修改相应变量的引用计数），即没有发生copy操作。 其他 ARC环境下：在单独声明block的时候，block还是会在栈上的；当block作为参数返回的时候，block也会自动被移到堆上；在ARC下，只要指针过一下strong指针，或者由函数返回都会把block移动到堆上。 __main_block_copy_0 中的 _Block_object_assign 函数相当于retain实例方法，使 block 的成员变量持有捕获到的对象。 __main_block_dispose_0 中的 _Block_object_dispose 函数相当于 release 实例方法，释放 block 的成员变量持有的对象。 Objective-C 中的3种block： __NSStackBlock__、__NSMallocBlock、__NSGloballBlock 会在下面的情况下出现： 条件 ARC MRC 捕获外部变量 __NSStackBlock__ __NSMallocBlock__ __NSStackBlock__ 未捕获外部变量 __NSGlobalBlock__ __NSGlobalBlock__ 在 ARC 中，捕获了外部变量的block的类型会是__NSStackBlock__ 或者 __NSMallocBlock__，如果 block 被赋值给了某个变量，在这个过程中会执行_Block_copy，将原有的 __NSStackBlock__ 变成 __NSMallocBlock__；但是如果 block 没有被赋值给某个变量，那它的类型就是__NSStackBlock__；没有捕获外部变量的 block 的类则是 __NSGlobalBlock__ ，既不在栈上，也不在堆上，它类似于 C 语言函数一样，会在代码段中。 在MRC中，捕获了外部变量的 block 的类会是__NSStackBlock__，放置在栈上；没有捕获外部变量的 block 与 ARC 环境下的情况是相同的，类型是__NSGlobalBlock__，放置在代码段中。 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:5:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"推荐文章： 比我写的好 Block本质 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:6:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"参考文章: 谈Objective-C Block的实现 iOS中的block是如何持有对象的 深入分析Objective-C block、weakself、strongself实现原理 block-copy ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:7:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"简析几个 Promise 开源库的实现 Promise思想的开源库其实有很多，这里仅简单分析下Bolts、PromiseKit、promises ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:0:0","tags":["ios","Promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"一、 Bolts Facebook出品 BFTask原理： 每个BFTask自己都维护着一个任务数组，当task执行continueWithBlock:后（会生成一个新的BFTask），continueWithBlock:带的那个block会被加入到任务数组中，每当有结果返回时，会执行trySetResult:方法，这个方法中会拿到task它自己维护的那个任务数组，然后取出其中的所有任务block，然后遍历执行。 /// 内部维护的任务数组 @property (nonatomic, strong) NSMutableArray *callbacks; /// `continueWithBlock:`方法 - (BFTask *)continueWithExecutor:(BFExecutor *)executor block:(BFContinuationBlock)block cancellationToken:(nullable BFCancellationToken *)cancellationToken { // 创建一个新的`BFTaskCompletionSource`，创建它时，它里面会`new`一个`task`对象，最后`return`的也是这个`task` // 这个不是单例方法，所以此处创建的`task`是一个新对象 BFTaskCompletionSource *tcs = [BFTaskCompletionSource taskCompletionSource]; // (1) // 创建一个任务`block`，后面会把执行这个`block`的操作加入到数组中，当回调时会执行这个`block`里面的操作 // P.S. 下面附一张把这个block折叠后的图片 dispatch_block_t executionBlock = ^{ //(N.0) if (cancellationToken.cancellationRequested) { [tcs cancel]; return; } // 把当前类（`task`对象）作为参数进行回调 //(N.1) id result = nil; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wdeprecated-declarations\" if (BFTaskCatchesExceptions()) { @try { result = block(self); } @catch (NSException *exception) { NSLog(@\"[Bolts] Warning: `BFTask` caught an exception in the continuation block.\" @\" This behavior is discouraged and will be removed in a future release.\" @\" Caught Exception: %@\", exception); tcs.exception = exception; return; } } else { result = block(self); } #pragma clang diagnostic pop // 如果回调结果返回的是`BFTask`类型 if ([result isKindOfClass:[BFTask class]]) { // 下面`block`中的`task`就是上面的`result` id (^setupWithTask) (BFTask *) = ^id(BFTask *task) { //(N.3) if (cancellationToken.cancellationRequested || task.cancelled) { [tcs cancel]; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wdeprecated-declarations\" } else if (task.exception) { tcs.exception = task.exception; #pragma clang diagnostic pop } else if (task.error) { tcs.error = task.error; } else { tcs.result = task.result; } return nil; }; BFTask *resultTask = (BFTask *)result; /// 如果`continueWithBlock:`中的`block`回调返回的`task`是`complete`状态，则直接到 (N.3)，把任务的结果传递到上面新创建的那个`BFTask`对象的`result`属性中,否则就继续执行`continueWithBlock:`来监测任务状态 if (resultTask.completed) { setupWithTask(resultTask); //(N.2) } else { [resultTask continueWithBlock:setupWithTask]; //(N.4) } } else { tcs.result = result; } }; // 如果是未完成状态，则把操作加入到数组中，延后执行；否则就立即执行 BOOL completed; @synchronized(self.lock) { //(2.0) completed = self.completed; if (!completed) { // 把任务添加到数组中 [self.callbacks addObject:[^{ [executor execute:executionBlock]; } copy]]; } } if (completed) { //(2.1) [executor execute:executionBlock]; } return tcs.task; } ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:1:0","tags":["ios","Promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"二、 PromiseKit 首先，让我们看看创建Promise的源码 + (instancetype)promiseWithResolver:(void (^)(PMKResolver))block { // (2) PMKPromise *this = [self alloc]; // (3) 初始化promise this-\u003e_promiseQueue = PMKCreatePromiseQueue(); this-\u003e_handlers = [NSMutableArray new]; @try { block(^(id result){ // (4) 立即开始原始任务（它传过去的参数还是一个`PMKResolver`类型的block，这个block会在PMKRejecter或者PMKFulfiller类型的block执行回调时执行） \"void (^PMKResolver)(id)\" if (PMKGetResult(this)) return PMKLog(@\"PromiseKit: Warning: Promise already resolved\"); PMKResolve(this, result); // (7) result为用户在`new:`方法中返回的数据结果,而this则是上面一开始时初始化的那个promise. 执行到这里后接下来会到(8),回调到(9)那个block,这个block中会遍历`handlers`数组中的`handler()` block, }); } @catch (id e) { // at this point, no pointer to the Promise has been provided // to the user, so we can’t have any handlers, so all we need // to do is set _result. Technically using PMKSetResult is // not needed either, but this seems better safe than sorry. PMKSetResult(this, NSErrorFromException(e)); } return this; } + (instancetype)new:(void(^)(PMKFulfiller, PMKRejecter))block { // (1) return [self promiseWithResolver:^(PMKResolver resolve) { id rejecter = ^(id error){ // (5-1) 失败的block if (error == nil) { error = NSErrorFromNil(); } else if (IsPromise(error) \u0026\u0026 [error rejected]) { // this is safe, acceptable and (basically) valid } else if (!IsError(error)) { id userInfo = @{NSLocalizedDescriptionKey: [error description], PMKUnderlyingExceptionKey: error}; error = [NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:userInfo]; } resolve(error); }; id fulfiller = ^(id result){ // (5-2) 成功的block if (IsError(result)) PMKLog(@\"PromiseKit: Warning: PMKFulfiller called with NSError.\"); resolve(result); // (6) 当用户执行`PMKFulfiller`类型的block时,会回调到这里,此方法执行(4)中的那个参数block,即执行(7) }; block(fulfiller, rejecter); // (5-3) 把成功和失败的block作为参数，执行回调原任务（e.g demo中的网络请求任务） }]; } static void PMKResolve(PMKPromise *this, id result) { void (^set)(id) = ^(id r){ // (9) handle回调执行(10) NSArray *handlers = PMKSetResult(this, r); for (void (^handler)(id) in handlers) handler(r); }; if (IsPromise(result)) { PMKPromise *next = result; dispatch_barrier_sync(next-\u003e_promiseQueue, ^{ id nextResult = next-\u003e_result; if (nextResult == nil) { // ie. pending [next-\u003e_handlers addObject:^(id o){ PMKResolve(this, o); }]; } else set(nextResult); }); } else set(result); // (8) } 调用new:方法时会调用promiseWithResolver:方法，在里面进行一些初始化promise的工作：创建了一个GCD并发队列和一个数组，并立即回调new:后面的那个参数block，即：立即执行，生成一个成功fulfiller和失败rejecter的block，这个block将由用户控制回调操作的时机。 下面看一下then的实现： - (PMKPromise *(^)(id))then { // 1 // 此处`then`本身就是一个block：（PMKPromise *(^then)(id param)），此方法类似于getter方法 // 返回一个`(PMKPromise *(^)(id))`类型的block，这个block执行后，返回一个PMKPromise // 下面整个都是一个then `block`，当执行then的时候会调用 `self.thenOn(dispatch_get_main_queue(), block)`，返回一个Promise类型的结果 return ^(id block){ return self.thenOn(dispatch_get_main_queue(), block); }; } - (PMKResolveOnQueueBlock)thenOn { return [self resolved:^(id result) { if (IsPromise(result)) return ((PMKPromise *)result).thenOn; if (IsError(result)) return ^(dispatch_queue_t q, id block) { return [PMKPromise promiseWithValue:result]; }; return ^(dispatch_queue_t q, id block) { // HACK we seem to expose some bug in ARC where this block can // be an NSStackBlock which then gets deallocated by the time // we get around to using it. So we force it to be malloc'd. block = [block copy]; return dispatch_promise_on(q, ^{ return pmk_safely_call_block(block, result); }); }; } pending:^(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolve)(id)) { if (IsError(result)) PMKResolve(next, result); else dispatch_async(q, ^{ resolve(pmk_safely_call_block(block, result)); // (11) }); }]; } - (id)resolved:(PMKResolveOnQueueBlock(^)(id result))mkresolvedCallback pending:(void(^)(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolver)(id)))mkpendingCallback { __block PMKResolveOnQueueBlock callBlock; __block id result; dispatch_sync(_promiseQueue, ^{ if ((result = _result)) // 有结果的情况下直接返回 retur","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:2:0","tags":["ios","Promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"三、 Promises google出品 原理： 这个开源库的思路其实与BFTask很相似，每次promise执行then方法时都会创建一个新的promise对象，同时会创建一个观察者（block对象），这个观察者会持有这个新的promise，当（旧）promise对象fulfilled或者rejected的时候，会把fulfilled或者rejected拿到的value给新promise。 先看下promise的初始化方法: - (instancetype)initPending { self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self; } 首先进入一个单例dispatch_group_t中，为啥用dispatch_group_t呢？因为后面的then方法可以在其他队列处理，而且dispatch_group_t有同步队列的功能，后面作者每次初始化一个promise都会enter到dispatch_group_t中，fulfilled或者rejected时再leave。 接下来看看最重要同时也是精华所在的then方法： - (instancetype)initPending { // (0) self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self; } - (FBLPromise *)onQueue:(dispatch_queue_t)queue then:(FBLPromiseThenWorkBlock)work { return [self chainOnQueue:queue chainedFulfill:work chainedReject:nil]; // (1) } - (FBLPromise *)chainOnQueue:(dispatch_queue_t)queue chainedFulfill:(FBLPromiseChainedFulfillBlock)chainedFulfill chainedReject:(FBLPromiseChainedRejectBlock)chainedReject { // 首先new一个新的promise对象 FBLPromise *newPromise = [[FBLPromise alloc] initPending]; // (2) // 这个block其实就是抽离的一个方法，避免写重复代码。 // 当promise被fulfilled或者rejected时都会调用； // 结合下面方法block中的实现可以看出，如果thenBlock（chainedFulfill）存在，则先执行chainedFulfill这个block（其实就是map一下这个value值）重新生成一个value值（value值也可能不会变化，主要还得看map函数里有没有改变value）；接下来把这个重新赋值的value扔给resolverBlock，resolverBlock会把这个新的value给newPromise，newPromise会调用fulfilled方法，如果此时newPromise也有订阅者(被then过)，则就会把这个新value传递给下一个newNewPromise ... // 如果then的时候promise已经结束了，则直接把结果返回给订阅者,即调用thenBlock。 __auto_type resolver = ^(id __nullable value) { if ([value isKindOfClass:[FBLPromise class]]) { // (8) [(FBLPromise *)value observeOnQueue:queue fulfill:^(id __nullable value) { [newPromise fulfill:value]; } reject:^(NSError *error) { [newPromise reject:error]; }]; } else { [newPromise fulfill:value]; // (8) } }; [self observeOnQueue:queue fulfill:^(id __nullable value) { value = chainedFulfill ? chainedFulfill(value) : value; // (7) resolver(value); } reject:^(NSError *error) { id value = chainedReject ? chainedReject(error) : error; // (7) resolver(value); }]; return promise; } - (void)observeOnQueue:(dispatch_queue_t)queue fulfill:(FBLPromiseOnFulfillBlock)onFulfill reject:(FBLPromiseOnRejectBlock)onReject { @synchronized(self) { // (3) switch (_state) { // 默认的state，即待处理的事件 case FBLPromiseStatePending: { // 如果promise对象还没有观察者数组，new一个 // 这里为什么需要观察者数组呢？因为一个Promise可以被then很多次 if (!_observers) { _observers = [[NSMutableArray alloc] init]; } // 当事件被处理时会执行下面block __auto_type observer = ^(FBLPromiseState state, id __nullable resolution) { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ switch (state) { // (6) case FBLPromiseStatePending: break; case FBLPromiseStateFulfilled: onFulfill(resolution); break; case FBLPromiseStateRejected: onReject(resolution); break; } }); }; [_observers addObject:observer]; // (4) break; } // 当前promise已经结束 case FBLPromiseStateFulfilled: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onFulfill(self-\u003e_value); }); break; } // 当前promise已经结束 case FBLPromiseStateRejected: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onReject(self-\u003e_error); }); break; } } } } - (void)fulfill:(nullable id)value { if ([value isKindOfClass:[NSError class]]) { [self reject:(NSError *)value]; } else { @synchronized(self) { if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateFulfilled; _value = value; _pendingObjects = nil; for (FBLPromiseObserver observer in _observers) { observer(_state, _value); // (5) } _observers = nil; // 事件结束，leave group dispatch_group_leave(FBLPromise.dispatchGroup); } } } } - (void)reject:(NSError *)error { NSAssert([error isKindOfClass:[NSError class]], @\"Invalid error type.\"); if (![error isKindOfClass:[NSError class]]) { // Give up on invalid error type in Release mode. @throw error; // NOLINT } @synchronized(self) { if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateRejected; _error = error; _pendingObjects = nil; for (FBLPromiseObserver observer in ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:3:0","tags":["ios","Promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"参考： iOS如何优雅的处理“回调地狱Callback hell”(一)——使用PromiseKit ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:4:0","tags":["ios","Promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"}]