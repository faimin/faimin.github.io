[{"categories":["实现原理"],"content":"探索block变量捕获的原理","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"探索block捕获外界变量原理 在此之前先介绍一下block 基本语法： Block Syntax // Block as a local variable returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; // Block as a property @property (nonatomic, copy) returnType (^blockName)(parameterTypes); // Block as a method parameter - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; // Block as an argument to a method call [someObject someMethodThatTakesABlock: ^returnType (parameters) {...}]; // Block as typedef typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; 对Object-C文件执行 xcrun -sdk iphonesimulator clang -fobjc-arc -fobjc-runtime=ios -rewrite-objc fileName.m 操作来获取伪代码，仅供技术探究。 先把__block_impl结构体拿出来放在最前面，最终block调用时都会被强转成这种类型，下面好多地方会用到。 struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; isa指针：指向一个类对象，在非GC模式下有三种类型：_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock； Flags：block的负载信息（引用计数和类型信息），按位存储； Reserved：保留变量； FuncPtr：指向block函数地址的指针。 descriptor：是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。 接下来进入正题： p.s：以下Objective-C的代码都处在ARC环境下 ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:0:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"1、不加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; block(); } } 执行clang操作后的C++代码: // 定义block的结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSMutableArray *mutArr; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableArray *_mutArr, int flags=0) : mutArr(_mutArr) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 以下为调用`block`时执行的方法 // 此`mutArr`是在最初定义`block`时 为结构体传进去的局部变量`mutArr`的值 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // bound by copy:这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。 NSMutableArray *mutArr = __cself-\u003emutArr; // bound by copy ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)mutArr, sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } // block的copy函数 static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; NSMutableArray *mutArr = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); // 可以看出block变量实际上就是一个指向结构体`__main_block_impl_0`的指针,而结构体的第三个元素是局部变量mutArr的值 // 此处捕获的直接就是`mutArr`局部变量 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, mutArr, 570425344)); // 下面调用`block`的方法实质其实是: 指向结构体的指针`block`访问其`FuncPtr`元素(即,在定义block时为`FuncPtr`元素传进去的`__main_block_func_0`方法) ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:1:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"2、添加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { __block NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; [mutArr addObject:@\"hello\"]; block(); } } 执行clang后的C++代码: // 由下面的代码可知: `__block`的作用就是定义一个新的结构体来包裹原来的变量 // 定义一个保存变量的结构体 （被__block标记的变量会被转化为这种格式的结构体对象） struct __Block_byref_mutArr_0 { void *__isa; __Block_byref_mutArr_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSMutableArray *mutArr; }; // block 结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 包含捕获的局部变量的结构体指针 __Block_byref_mutArr_0 *mutArr; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_mutArr_0 *_mutArr, int flags=0) : mutArr(_mutArr-\u003e__forwarding) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 在block内部对`mutArr`操作 (block回调时执行的函数) static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 拿到 包含捕获的局部变量 的结构体指针 __Block_byref_mutArr_0 *mutArr = __cself-\u003emutArr; // bound by ref // 通过上面的结构体指针一步步拿到`mutArr`数组 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr-\u003e__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; // 这里可以看到结构体中的 __forwarding 指针其实指向的就是其自身 __attribute__((__blocks__(byref))) __Block_byref_mutArr_0 mutArr = {(void*)0,(__Block_byref_mutArr_0 *)\u0026mutArr, 33554432, sizeof(__Block_byref_mutArr_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\"))}; // 与不加__block差不多,`block`变量还是一个指向`__main_block_impl_0`结构体的指针,区别在于第三个参数变了. 第三个参数是包含局部变量`mutArr`的结构体指针. // 即block捕获的是持有`mutArr`的结构体指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, (__Block_byref_mutArr_0 *)\u0026mutArr, 570425344)); // 在block外部对`mutArr`操作 // // 此处对`mutArr`数组对象进行操作,获取`mutArr`也是和`block`内部的获取方法一样, // 都是通过持有`mutArr`的结构体一步步获取到`mutArr`数组, // // 这里要经过 __forwarding 来获取`mutArr`的原因是： // __block 标记的变量有可能被copy到堆上，__forwarding 的作用就是在被copy到堆上时修改指向，使栈和堆上的 __forwarding 都指向堆上的那个副本，这样就保证了block内外操作的都是同一份内存。 // 具体的copy实现可以参见下面的 `_Block_byref_copy` 函数 // // 所以,在block内外,操作的都是同一个`mutArr`对象.都是通过包含`mutArr`对象的`__Block_byref_mutArr_0`结构体对其进行间接操作处理的 // 这也就是为什么添加`__block`后还能改变原来的对象的原因 // // PS: 当我们用__block 标记一个变量以后，当我们用到这个变量时都不是直接使用这个变量了，而是变成了通过`__Block_byref`来操作这个变量 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr.__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)(NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_b07809_mi_0); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; // __block 变量被copy到堆上时的具体实现 static struct Block_byref *_Block_byref_copy(const void *arg) { struct Block_byref *src = (struct Block_byref *)arg; if ((src-\u003eforwarding-","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:2:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"3、静态变量: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { static NSString *myString = @\"111\"; void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang之后的C++代码： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 注意这里, 外面的静态变量被捕获了,不过捕获的是对象的指针 NSString **myString; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString **_myString, int flags=0) : myString(_myString) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString **myString = __cself-\u003emyString; // bound by copy // 通过对`myString`指针进行取值操作(*myString),拿到 myString ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)(*myString), sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_1); // 由下面的伪代码可以看出,由于`myString`是指针,所以通过`*`操作来获取到原来的变量, // 然后再对其进行重新赋值操作 (*myString) = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_121621_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_2, (*myString)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emyString, (void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; static NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_0; // block捕获的是静态变量的指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, \u0026myString, 570425344)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_3); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:3:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"4、全局变量: #import \u003cFoundation/Foundation.h\u003e NSString *myString = @\"111\"; int main(int argc, char *argv[]) { @autoreleasepool { void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang操作执行之后的C++伪代码: NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_0; // block结构体并没有捕获全局变量 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 下面三个函数都是在用到全局变量`myString`的时候直接从内存去获取 ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_1); myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_3, myString); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_4); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:4:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"总结: 局部变量：不加__block，block内部捕获的是局部变量的值，而且如果局部变量是数值类型（比如int）不会有__main_block_copy_0 和 __main_block_dispose_0 两个函数，如果是引用类型（比如NSArray）则会有这个函数，说明对于值类型变量是直接定义新变量并赋值相同，对于引用类型变量是定义一个新变量并copy它。 局部变量：而添加__block后,原来的局部变量会被放入到一个__Block_byref_变量名_0类型的结构体中，然后block内部当捕获局部变量时其实是捕获的是这个结构体的指针，当获取原来的局部变量时(不管是在block内还是block外)，其实都是通过这个结构体或者这个结构体指针来拿到原来的局部变量，再进行操作的。这也就是为什么添加__block后可以对block内捕获的局部变量进行重新赋值等操作。 静态变量：block直接捕获的是静态变量的指针，前后都是对指针进行操作。 全局变量（或 全局静态变量）：block并没有捕获变量，而是在结构体的执行方法中直接使用了全局变量，是在执行时才去取值，一直都是获取变量的最新值。而且细心点我们可以发现，对于没有捕获全局变量的block中也没有__main_block_copy_0 和 __main_block_dispose_0 两个函数（用于在调用前后修改相应变量的引用计数），即没有发生copy操作。 在ARC环境下：在单独声明block的时候，block还是会在栈上的；当block作为参数返回的时候，block也会自动被移到堆上；在ARC下，只要指针过一下strong指针，或者由函数返回都会把block移动到堆上。 __main_block_copy_0 中的 _Block_object_assign 函数相当于retain实例方法，使 block 的成员变量持有捕获到的对象。 __main_block_dispose_0 中的 _Block_object_dispose 函数相当于 release 实例方法，释放 block 的成员变量持有的对象。 Objective-C 中的三中block __NSStackBlock__、__NSMallocBlock、__NSGloballBlock 会在下面的情况下出现： ARC 非ARC 捕获外部变量 __NSStackBlock__ __NSMallocBlock__ __NSStackBlock__ 未捕获外部变量 __NSGlobalBlock__ __NSGlobalBlock__ 在 ARC 中，捕获了外部变量的block的类型会是__NSStackBlock__ 或者 __NSMallocBlock__，如果 block 被赋值给了某个变量，在这个过程中会执行_Block_copy，将原有的 __NSStackBlock__ 变成 __NSMallocBlock__；但是如果 block 没有被赋值给某个变量，那它的类型就是__NSStackBlock__；没有捕获外部变量的 block 的类则是 __NSGlobalBlock__ ，既不在栈上，也不在堆上，它类似于 C 语言函数一样，会在代码段中。 在非 ARC 中，捕获了外部变量的 block 的类会是__NSStackBlock__，放置在栈上；没有捕获外部变量的 block 与 ARC 环境下的情况是相同的，类型是__NSGlobalBlock__，放置在代码段中。 ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:5:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"推荐文章： 比我写的好 Block本质 ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:6:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"参考文章: 谈Objective-C Block的实现 iOS中的block是如何持有对象的 深入分析Objective-C block、weakself、strongself实现原理 block-copy ","date":"2018-08-17","objectID":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:7:0","tags":["ios","block"],"title":"Block捕获原理探究","uri":"/faimin/faimin.github.io/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"}]