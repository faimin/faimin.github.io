[{"categories":["实现原理"],"content":"Runtime AutoreleasePoolPage 、SideTableMap、AssociationsManager 是在map_images-\u003emap_images_nolock-\u003earr_init() 函数中初始化的； 一个类最多能添加64个分类； 为什么会有一块干净的内存和一块脏内存呢？ 这是因为iOS运行时会导致不断对内存进行增删改查，会对内存的操作比较严重，为了防止对原始数据的修改，所以把原来的干净内存copy一份到rw中，有了rw为什么还要rwe（脏内存），这是因为不是所有的类进行动态的插入、删除。当我们添加一个属性，一个方法会对内存改动很大，会对内存的消耗很有影响，所以我们只要对类进行动态处理了，就会生成一个rwe。 为什么category会覆盖原来的方法？ 在map_images方法的 attachCategories -\u003e attachLists 分类附加到原来的类的方法列表时，会先重新开辟一个新的数组，把原来的方法列表倒序遍历添加到新数组的后面，接着再正序遍历，把分类的方法添加到新数组的前面（方法列表的顺序与原来的顺序一致）； methodLists 类和category实现load对加载的影响 只有类和分类都实现load方法，才会发生在load_image阶段分类方法整合到所属类的方法列表中的操作; 只有类或者分类中实现load的时候，类的方法和分类方法都是直接在编译期存放到class_ro_t中的baseMethods中的。那这种情况怎么能保证分类方法在原始类方法前面的？这应该是编译器自己在编译期做的处理，让分类方法地址比原始类的方法地址要低（方法排序用的是升序排序）。 而对于类和分类都实现load的场景，即在load_image阶段把分类方法整合到类的方法列表中的情况是如何进行二分查找的呢？其实整合后的方法列表是个二维数组，内部存的是排好序的一维方法列表（methodizeClass阶段preparemethod进行的方法升序排序），方法查找时先是顺序遍历二维数组，再在有序的一维方法列表中进行二分查找。 综上所述，不要在类和分类中同时实现load方法也是提升启动速度的一个点，当然，不用load最好了。 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"为什么执行load方法时没有触发initialize？ 一定明确initialize是在首次发消息时才会触发，而load的执行是通过函数指针的方式调用的，没有走消息发送机制，所以不会触发initialize。 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"Weak weak_table_t 是全局保存弱引用的哈希表，它是通过对object地址做hash计算，然后从8个SideTable数组中取出其中一张，然后再从SideTable中读取到weak_table。weak_table_t 是以 object 地址为 key，以 weak_entry_t 为 value。 weak_entry_t 是用来存储所有指向某个对象的弱引用变量的地址的，里面有个weak_referrer_t数组，它存储的其实是弱引用的指针，即指针的指针，这么做的目的是可以把弱引用置为nil。 weak_entry_t 中有2种结构，当存储的弱引用数量\u003c= 4个的时候用的其实是个定长数组，\u003e 4的时候才会转为哈希数组。（这里使用哈希数组的原因应该是为了处理B弱引用A，然后B先释放了，这时那个弱引用可能也要置为nil，用hash数组的话查询速度会比较快）。往weak_entry_t 中添加弱引用变量时，即更新weak_referrer_t采用的是定向寻址法； 往weak_table 中插入weak_entry_t时，先是对object地址取hash作为它的index，如果这个index下的位置不为空，则通过一个算法（index = (index+1) \u0026 weak_table-\u003emask）重新计算生成一个新的index再读取对应的位置，直到找到一个空位置，然后把weak_entry_t放进去，同时更新元素数量。这种插入方式其实也是定向寻址法。 hash 函数，与 mask 做与操作，防止 index 越界; size_t begin = hash_pointer(referent) \u0026 weak_table-\u003emask; weak_hash_insert weak_table_t 还有一个扩容和缩容的处理，当前使用容量占到 总容量（mask + 1） 3/4 的时候会进行扩容处理，扩大到现有总容量（mask + 1）的2倍。 当总容量超过1024，而实际使用的空间低于总空间的 1/16 时则会进行容量压缩，缩到现有总容量的1/8 （为什么是八分之一？是为了保证总容量是现有使用容量的2倍）。 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"@synchronized原理 先从当前线程的TLS中尝试获取SyncData（本身是个单向链表），如果存在并且SyncData中的object与传进来的object相同，则说明找到对应的SyncData了。更新锁数量（lockCount），并返回SyncData。 （注意：一条线程的TLS中只能存唯一一个SyncData，假如已经存在了但是object并不与自己传进来的一致，则创建新的SyncData后并不会更新到TLS中，而是保存到 pthread_data 中，有点先入为主的意思） 从pthread_data中获取SyncCache（里面存着一个SyncCacheItem数组，SyncCacheItem存的是SyncData），如果存在则遍历SyncCacheItem数组，如果cacheItem中的syncData中的object与传进来的object相同，则更新 item-\u003elockCount ，然后返回SyncData。 走到这里就说明没有从thread cache中找到合适的SyncData。这时就会从全局StripMap\u003cSyncList\u003e sDataLists 表中读取，先通过对象object的hash值取出一个SyncList，接着拿到SyncList中的SyncData链表，然后遍历整个链表。 a. 如果发现与object匹配的SyncData则更新SyncData中的threadCount数量，然后把找到的这个SyncData保存到TLS或者pthread_data中的SyncCache里面； b. 如果遍历到最后也没发现匹配的，则找到链表中第一个未使用（SyncData中的threadCount = 0）的SyncData，进行复用。这个SyncData也会和上面一样进行缓存； c. 如果没找到匹配的，也没找到未使用的，则创建一个新的SyncData。这个新的SyncData会先保存到SyncList中，然后也会和上面一样保存到TLS或者pthread_data中一份，即新创建的有2份缓存。 synchronized ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:4:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"Associate 原理 所有的关联对象都是由AssociationsManager管理的，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象。这相当于把所有对象的关联对象都存在一个全局hashMap里面，hashMap的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个hashMap的value又是一个ObjectAssociationsMap，里面保存了关联对象的key和对应的value值。runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有会调用_object_remove_assocations做关联对象的清理工作。 在set和get时，即对内部的map进行操作时都会用manager中的spinlock（底层其实还是unfair_lock），所以set、get时一般情况下是线程安全的。但是可能是为了追求性能，set时把旧对象的释放放到了锁外，atomic get时为了保证线程安全，会retain一下访问对象，在锁外又autorelease了一下，如果不执行retain操作可能会出现数据竞争。可以参考下这篇文章: AssociatedObject 源码分析：如何实现线程安全？ Associate ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:5:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"GCD 可创建的最大线程数是 255 thread_pool_size = DISPATCH_WORKQ_MAX_PTHREAD_COUNT 255 自定义串行队列是overcommit的，并行队列不是overcommit的 自定义队列的目标队列在初始化时传参为NULL，然后会为其从_dispatch_root_queues 中获取一个根目标队列；当 tq 为 NULL，即入参目标队列为 DISPATCH_TARGET_QUEUE_DEFAULT（值是 NULL） 时， 根据 qos 和 overcommit 从 _dispatch_root_queues 全局的根队列数组中获取一个根队列作为新队列的目标队列 if (!tq) { tq = _dispatch_get_root_queue( qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, overcommit == _dispatch_queue_attr_overcommit_enabled)-\u003e_as_dq; if (unlikely(!tq)) { // 如果未取得目标队列则 crash DISPATCH_CLIENT_CRASH(qos, \"Invalid queue attribute\"); } } dispatch_sync a. 首先将任务加入队列 b. 执行任务block c. 将任务移出队列 d. sync里面的处理最终执行的是barrier的内部函数 e. 会死锁的原因：执行时会检查当前线程的状态（是否正在等待），然后与当前的线程的ID（_dispatch_tid_self()）做比较，相等的话则判定为死锁。（相关处理在 __DISPATCH_WAIT_FOR_QUEUE__ 函数中） dispatch_async a. 将异步任务（dispatch_queue 、 block）封装为 dispatch_continuation_t 类型 b. 然后执行 _dispatch_continuation_async -\u003e dx_push递归重定向到根队列，然后通过创建线程执行 dx_invoke 执行block回调； dispatch_barrier_async a. 和dispatch_async 流程一样，只是里面有一个while循环，等队列中的barrier前面的任务执行完，才执行后面的； b. 这里有个优化是：封装成 dispatch_continuation_s 结构时，会先从当前线程的TLS中获取一下，获取不到再从堆上创建新的 dispatch_group a. dispatch_group内部维护着一个数值，初始值为0，enter时减4，leave时加4 https://juejin.cn/post/6902346229868019719#heading-4 b. 等待用的是while循环，而不是信号量 dispatch_semaphore_t a. dispatch_semaphore_wait 时里面其实是起了一个do-while 循环，不断的去查询原子变量的值，不满足条件时会一直循环，借此阻塞流程的进行。有点像dispatch_once dispatch_group_async 内部其实是对dispatch_async 和 dispatch_group_enter / dispatch_group_leave 的封装 线程池复用原理 线程创建后从队列里取出任务执行，任务执行后使用信号量使其等待5秒钟，如果在这期间再有GCD任务过来，会先尝试唤醒线程，让它继续工作，否则等待超时后线程会自动结束，被系统销毁。（不是tableview中的复用池机制） ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:6:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"NSTimer timer添加到runloop的过程： 如果是commonMode ，会被添加到runloop持有的一个_commonModeItems 集合中， 然后调用 __CFRunLoopAddItemToCommonModes 函数，把timer添加到runloopMode对象持有的_timers数组中 ，同时也会把modeName添加到runloopTimer的 _rlModes 中，记录runloopTimer都能在哪种runloop mode下执行； 如果是普通mode，则先获取这个runloopMode对象，把runloopMode的name添加到runloopTimer持有的 _rlModes集合中，然后调用 __CFRepositionTimerInMode 函数，把runloopTimer插入runloopMode持有的 _timers 数组中（如果数组中已经存在了，则先做移除操作）； 上面添加完成后，会调用 __CFRepositionTimerInMode 函数，然后调用 __CFArmNextTimerInMode，再调用 mk_timer_arm 函数把 CFRunLoopModeRef 的 _timerPort 和一个时间点注册到系统中，等待着 mach_msg 发消息唤醒休眠中的 runloop 起来执行到达时间的计时器。（macOS 和 iOS 下都是使用 mk_timer 来唤醒 runloop）； 每次计时器都会调用 __CFArmNextTimerInMode 函数注册计时器的下次回调，休眠中的runloop 通过当前runloop mode的 _timerPort 端口唤醒，然后在本次runloop循环中在 _CFRunloopDoTimers 函数中循环调用 __CFRunLoopDoTimer 函数，执行达到触发时间的timer的 _callout 函数。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-\u003e_callout, rlt, context_info); 是执行计时器的 _callout 函数。 NSTimer 不准时问题 通过上面的 NSTimer 执行流程可看到计时器的触发回调完全依赖 runloop 的运行（macOS 和 iOS 下都是使用 mk_timer 来唤醒 runloop），使用 NSTimer 之前必须注册到 run loop，但是 run loop 为了节省资源并不会在非常准确的时间点调用计时器，如果一个任务执行时间较长（例如本次 run loop 循环中 source0 事件执行时间过长或者计时器自身回调执行时间过长，都会导致计时器下次正常时间点的回调被延后或者延后时间过长的话则直接忽略这次回调（计时器回调执行之前会判断当前的执行状态 !__CFRunLoopTimerIsFiring(rlt)，如果是计时器自身回调执行时间过长导致下次回调被忽略的情况大概与此标识有关 ）），那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer 提供了一个 tolerance 属性用于设置宽容度，即当前时间点已经过了计时器的本次触发点，但是超过的时间长度小于 tolerance 的话，那么本次计时器回调还可以正常执行，不过是不准时的延后执行。 tolerance 的值默认是 0，最大值的话是计时器间隔时间_interval 的一半，可以根据自身的情况酌情设置 tolerance 的值，（其实还是觉得如果自己的计时器不准时了还是应该从自己写的代码中找原因，自己去找该优化的点，或者是主线实在优化不动的话就把计时器放到子线程中去））。 （NSTimer 不是一种实时机制，以 main run loop 来说它负责了所有的主线程事件，例如 UI 界面的操作，负责的运算使当前 run loop 持续的时间超过了计时器的间隔时间，那么计时器下一次回调就被延后，这样就造成 timer 的不准时，计时器有个属性叫做 tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果延后时间过长的话会直接导致计时器本次回调被忽略。） ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:7:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["工具"],"content":"平时收集整理的一些工具","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"简介 个人平时收藏的一些Mac平台的工具，绝大多数都是开源免费的，而且很多都支持homebrew安装。 ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:1:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"包管理 Homebrew：Mac端的包管理工具，PC端的有Scoop、Chocolate、Winget，我个人推荐Scoop，因为可以指定路径 ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:2:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"终端 iTerm2 WindTerm - 跨平台 Tabby - 跨平台 Neovide - Neovim ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:3:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"系统优化 Lemon Cleaner AppCleaner ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:4:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"系统监控 Stats eul MenuMeters ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:5:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"下载 Motrix Free Download Manager you-get - 网站视频下载命令工具，如果需要视频合并功能，需要额外安装ffmpeg ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:6:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Office LibreOffice ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:7:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"流程图 Draw.io asciiflow tlddraw ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:8:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Markdown MarkText ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:9:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"播放器 我愿称之为Mac端最强 IINA ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:10:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"截图 shottr Snipaste ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:11:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"窗口管理 Rectangle ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:12:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"压缩解压缩 The Unarchiver Keka ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:13:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"屏幕保护 Brooklyn ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:14:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"防火墙 Lulu ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:15:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"翻译 Bob分为社区版和AppStore版，从社区第一个版本就开始用，后来有了商店版后我就买了。想白嫖的可以继续使用社区版，使用homebrew安装即可。 Bob ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:16:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"状态栏图标折叠 HiddenBar ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:17:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"TouchBar Pock MTMR ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:18:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Quick Look glance - All-in-one Quick Look plugin SouceCodeSyntaxHighlight QLMarkdown ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:19:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"邮件 Spark ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:20:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"键盘 KeyCastr - 显示当前按键 Tickys - 模拟机械键盘的声音 ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:21:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"屏幕录制 LICEcap Kap GIFCapture ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:22:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"直播 obs-studio ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:23:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"视频编辑 shotcut ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:24:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"格式转码 handbrake ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:25:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"NTFS NTFSTool mounty ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:26:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Hosts iHosts ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:27:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"RSS NetNewsWire ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:28:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"U盘系统制作 Rufus etcher ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:29:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"数据恢复 KeychainCracker ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:30:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"代理 ClashX ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:31:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"收费软件推荐 可以到这里找**特（破）别（解）**版 Alfred - 小帽子 插件 PopClip Xee - 图片预览 Kaleidoscope - 文件diff ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:32:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"搜索引擎 SearXNG Neeva You Yandex Qwant ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:33:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"开发工具 LLVM Lookin Chisel - lldb插件 injectionIII - 可见即所得 DevCleaner - 清理Xcode缓存 OpenSim - 读取模拟器沙盒 HTTPToolKit-Desktop dSYMTools LSUnusedResources - 检测无用资源 检测无用代码 periphery WBBlades Pecker Stencil Sitrep czkawka ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:34:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Mach-O MachOView MachO-Explorer XMachOViewer MachOExplorer MachO-Kit LinkMap bloaty - 对比文件体积变化 ipsw ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:35:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"逆向 比较有名的可能是IDA和Hopper Disassembler Ghidra Frida Cutter Hashcat ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:36:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Hex HexFriend ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:37:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"命令行 fig starship - prompt nushell atuin - shell history fd - 文件搜索 dust - du lsd - ls exa - ls bat - cat thefuck ipatool - 下载IPA文件 HTTPie - 查看网络 zsh-autosuggestions ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:38:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"JSON -\u003e Model Json2Property quicktype-xcode ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:39:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"快捷打开终端 [OpenInTerminal)[https://github.com/Ji4n1ng/OpenInTerminal] [FinderGo)[https://github.com/onmyway133/FinderGo] [Go2Shell)[http://zipzapmac.com/Go2Shell] [Alfred插件)[http://www.packal.org/workflow/terminalfinder] ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:40:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"图片压缩 ImageSmith是刚发布时我白嫖到的，现在已恢复原价，不过很好用；免费版推荐Imagenie ImageSmith - 收费但推荐 Imagenie Crunch - 只支持PNG TinyPNG4Mac ImageOptim ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:41:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"推送 Knuff Pusher Easy APNs Provider PushNotifications ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:42:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Git Fork GitUI LazyGit 开源的还有Xit、GitUp，收费的有Tower、Sublime Merge、GitKraken ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:43:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"数据库 SQLiteBrowser DBeaver ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:44:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"WWDC WWDC ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:45:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"自动化 Hammerspoon ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:46:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"Xcode版本管理 xcode-install xcodes xcinfo ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:47:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"VSCode插件 Shades of Purple - 主题 Code Runner CodeLLDB clangd Error Lens GitLens Git Graph Path Intellisense Project Manager Thunder Client CodeSnap Comment Tranlate Markdown Editor Image Preview Paste JSON as Code Todo Tree shellman Hex Editor Better Comments Swift 如果没有代码联想，可能是因为sourcekit-lsp与本机Swift不在同一目录下。在/usr/local/bin下建立一个sourcekit-lsp的软链接可以解决：ls -s $(xcrun --find sourcekit-lsp) /usr/local/bin/sourcekit-lsp。 如果断点调试无法显示变量，检查下是否安装了llvm，如果是那可能默认用的是llvm的lldb。把CodeLLDB的lldb指定为Xcode的lldb，或者在.zshrc中用Xcode版本覆盖llvm版本： export PATH=\"/Applications/Xcode.app/Contents/Developer/usr/bin:$PATH\" 函数参数没有代码提示的问题 关闭阻止选项 snippets_prevent_suggestions ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:48:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":["工具"],"content":"软件站 open-source-mac-os-apps AlternativeTo 麦氪搜 MacWk Xclient ","date":"2022-08-29","objectID":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/:49:0","tags":["工具"],"title":"我的收藏","uri":"/%E6%88%91%E7%9A%84%E6%94%B6%E8%97%8F/"},{"categories":[],"content":"我 符现超，菜鸡程序员一枚 ","date":"2022-08-26","objectID":"/about/whoami/:1:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":[],"content":"技术栈 有向全栈发展的想法，正在修行中 Objective-C Swift Lua 会点C++、Shell ","date":"2022-08-26","objectID":"/about/whoami/:2:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":[],"content":"兴趣爱好 喜欢热血系和治愈系动漫 喜欢收藏各种工具 爱瞎折腾 喜欢尝试新技术 喜欢想办法解决项目中的问题 ","date":"2022-08-26","objectID":"/about/whoami/:3:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":[],"content":"优缺点 处女座，有点小强迫症；乡下人，踏实稳重，能吃苦； ","date":"2022-08-26","objectID":"/about/whoami/:4:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":["实现原理"],"content":"记录Swift语言中自己的一些疑惑","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"分析Swift利器 swiftc xxx.swift -emit-silgen | xcrun swift-demangle \u003e xxxxSILGen.sil ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:1:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"值类型线程安全？ 不要人云亦云，这个说法是有问题的，你想想假如我们有个变量 var i = 1，多线程修改时不需要加锁？ 在未优化状态下值类型其实默认是在堆上分配的，只是在SIL优化阶段，编译器会根据上下文把大部分值类型改为在栈上分配，在栈上分配的情况是才是线程安全的，因为每个线程都有自己的栈空间，不需要考虑线程安全问题。但是对于被捕获的这种情况是没办法优化的，你想想如果放到栈上在出作用域后不就被释放了嘛，所以这种情况不会优化到栈上，而是继续留在堆上，也就是说这种场景下多线程操作值类型是不安全的，需要加锁来防止数据竞争。 那值类型的安全性体现在哪里呢？ 显式捕获：这种情况会发生值类型的拷贝操作，即生成一份新的变量，所以是安全的 函数传参时值类型会发生拷贝，所以是安全的 let 标记的变量是不允许修改的，所以这种也是安全的 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:2:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"闭包 OC中的block默认会捕获外界变量，我们要想修改捕获的值需要添加__block。 但Swift不一样，Swift中默认是可以修改外界捕获的变量的，除非你显式捕获外界变量。 这是为什么呢？原因是Swift捕获外界上下文变量时会在堆上开辟一块内存project_box，然后上下文变量会被包装成project_box(先被HeapObject包装一下，HeapObject再被Box包装一下，最后捕获的是Box，即捕获的上下文存储在堆空间)，这个project_box会被放到闭包的参数列表后面传递进来。变量属于是被间接捕获的，有点类似于OC中的__block原理。当然，并不是所有的外界变量捕获都是经过包装过的，只有在闭包内发生修改的变量才会被包装。 struct HeapObject { var Kind: UInt64 var refcount: UInt64 } // 负责包装的结构体,也就是用来包装捕获需要更新的值 struct Box { var refCounted: HeapObject // 这个捕获的值的类型根据捕获的值进行分配，此处规范操作是写泛型 // var value: Int var value: \u003cT\u003e } 而显式捕获，比如捕获全局变量的场景，经过编译后可以发现，其实是把被捕获的变量作为闭包函数的参数放到了原有闭包函数的后面，而值类型的函数参数在传参过程中会发生拷贝操作。 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:3:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"Lazy 这里的lazy指的是高阶函数前面的lazy，而非属性声明中的lazy。 使用lazy后再执行高阶函数，返回的其实是一个lazy对象，比如对一个数组进行XX操作，返回的是 LazyXXSequence 类型，这个类型中会保存原函数的操作行为和原始数据，只有在对这个lazy类型进行操作时才会真正进行函数操作。 swift_lazy ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:4:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"参考文章 从 SIL 角度看 Swift 中的值类型与引用类型 从 SIL 看 Swift 函数派发机制 iOS下的闭包下篇-Closure Swift 性能优化(2)——协议与泛型的实现 Swift 泛型底层实现原理 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:5:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["混编"],"content":"CocoaPods组件中Swift与Objective-C混编","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"前言 本文是笔者在解决混编时的一些记录，有些东西可能已经发生了变化。而且由于只是随手记录，写的比较乱，各位看官见谅~~~ 笔者负责的业务是以pod模块的形式存在于工程中的，所以以下调研的方案只针对于pod中的混编场景，在MM主工程混编几乎是无缝的，没什么可说的。。。 推荐大家浏览下 CocoaPods（podfile \u0026 podspec） 的 API，没几个，花费不了几分钟，但是却能帮助大家少踩很多的坑，一本万利~ ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:1:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"前期方案 暂时采用折中方案，把Swift独立成一个pod，然后业务pod再引用Swift pod。目的是减少依赖，避免引用不规范的repo。 如果打算在同一pod中混编，只要把你依赖的库都支持module即可，而且需要修改一下你们引用外部repo头文件的形式，比如 #import \"SDWebImage.h\" 改为 #import \u003cSDWebImage/SDWebImage.h\u003e 在MM主工程中创建个新的Swift文件（空文件即可），让Xcode自动生成一个bridge-header，目的是营造一个Swift环境（之前一直想不修改主工程而只在pod中营造，但是很遗憾，最后以失败告终）； 由于混编pod中依赖的repo需要支持module，但是MM中的pod水平参差不齐，大部分都没有支持module，这就限制我们在业务pod中混编时编译失败。而让pod一下子都支持module是一个不太现实的要求，所以我们暂时采用了一种折中的方案； 把Swift单独放一个pod中去，让Swift尽量少的依赖其他repo，然后业务pod再依赖Swift repo来调用Swift代码； ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:2:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"踩坑记录 pod中不支持bridging-header 所以混编pod中要想引用OC的pod需要支持module 混编的Swift库需要打成framework形式才可以编译成功，比如RxCocoa、PromiseKit 限于苹果本身机制和现有二进制方案实现问题，不支持 :modular_headers =\u003e true，所以使用:modular_headers =\u003e true 时临时需要添加参数:use_source_code =\u003e true，切换为代码编译； Swift与OC混编的pod所依赖的库需要改为动态库，比如ZDFlexLayout内部为Swift与OC混编的，依赖了Yoga，需要把Yoga编为动态库。报错如下图 undefine_symbol ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:3:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"注意事项 跨模块引用时需要把要暴露给外部的类或者函数的访问权限设置为 public，并标记为 @objc pod 中引用都是通过 @import 语法 Swift依赖的repo需要module化， 有3种方式： i: 在podfile中让所有的repo开启modular: use_modular_headers! ii: 只给某几个repo开启modular，举个例子：pod 'SDWebImage', :modular_headers =\u003e true iii: 让repo自己开启module支持，需要在podspec中修改下设置：spec.pod_target_xcconfig = { 'DEFINES_MODULE' =\u003e 'YES' } , 这个设置不管你开不开启modular开关，都会自动创建module 如果podspec中不设置DEFINES_MODULE=true，默认是不会生成module的，哪怕你在podspec中设置了module_map也不行，除非你在podfile中手动开启modular_hear你自己的modulemap才会生效 如果你手动创建了modulemap就不要设置DEFINES_MODULE=true了，因为笔者发现开启DEFINES_MODULE后它还会自己再生成一份xxx-umbraller伞文件。 笔者推荐让CocoaPods帮我们创建modulemap，如非你特别懂modulemap，不建议自己手动创建。 只需要把Swift用到的OC类放到umbrella中（后面说控制方法） ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:4:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"CocoaPods 骚操作： 用踩坑中提到的RxCocoa做例子，为了编译成功，我们需要把它打成动态库，而其他的保持不变，这种需求我们可以在 pre_install 阶段动态修改编译模式； pre_install do |installer| $dynamic_framework = ['RxSwift', 'RxCocoa', 'RxRelay'] #以framework形式存在的pod Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if $dynamic_framework.include?(pod.name) def pod.build_type; Pod::BuildType.dynamic_framework end end end end 上面操作是把dynamic_framework数组中的repo编译为framework，其他未指定的默认还是静态库 ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:5:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"同一混编pod内OC调用Swift 在头文件中引入 #import \u003cmodule-name\u003e-Swift.h\"，然后就可以调用Swift类了 oc_import_swift ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:6:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"同一混编pod内Swift调用OC 同一pod中，把oc类引用放入umbrella中（默认就有了），然后需要这个文件能被找到。 一种方式是修改此文件的membership为public，目的是为了把它移到public header中去（默认是project的） 修改起来成本比较高，不推荐 member_ship header 第二种方式是把这个文件的路径包含搜索路径中，可以通过设置podspec中的 spec.header_dir参数 header_dir 可以是任意名字, 笔者一般会设置为./，即当前文件夹 这个选项也不是万能的，你会发现就算设置了这个选项，也会出现报错的问题。建议业务方的pod如无必要，把类都放到private_header_files 中，减少umbrella 中的头文件数量。 如下设置 header_dir_set 静态库中的import需要是全路径的，而动态库中的搜索路径会被flatten，所以动态库不会出现此问题 不过这里有点需要注意的是，设置 header_dir 后需要同时设置 module_name，否则 modulename 默认会取 header_dir 的值。。。 其实官方文档上都有提到，惭愧 module_name ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:7:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"为什么能够混编？ 能够互相调用的类都需要集成NSObject Swift中的类和OC中的类底层元数据（class metadata）是共用的 // objc4-818.2 // objc-runtime-new.h typedef struct objc_class *Class; typedef struct objc_object *id; struct objc_object { private: isa_t isa; // ... }; struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // ... }; struct swift_class_t : objc_class { uint32_t flags; uint32_t instanceAddressOffset; uint32_t instanceSize; uint16_t instanceAlignMask; uint16_t reserved; uint32_t classSize; uint32_t classAddressOffset; void *description; // ... void *baseAddress() { return (void *)((uint8_t *)this - classAddressOffset); } }; ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:8:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"后续 需要平台制定规范，推动pod库的改造，以达到无缝混编 ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:9:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"Podspec 贴一下我的Swift podspec，没什么特别的，仅仅指定了一下Swift兼容的版本而已，仅供参考，按需修改 Pod::Spec.new do |spec| spec.name = \"ABC\" spec.version = \"0.0.1\" spec.summary = \"坑\" spec.description = \u003c\u003c-DESC 大坑 DESC spec.homepage = \"https://foo/bar/abc\" spec.license = \"MIT\" spec.platform = :ios, \"10.0\" spec.source = { :git =\u003e \"https://foo/bar/abc.git\", :tag =\u003e \"#{spec.version}\" } spec.swift_versions = ['5.1''] spec.source_files = \"Source/**/*.{h,m,swift}\" spec.module_name = spec.name spec.header_dir = \"./\" spec.pod_target_xcconfig = { 'DEFINES_MODULE' =\u003e 'YES', #'SWIFT_OBJC_BRIDGING_HEADER' =\u003e \"$(PODS_ROOT)/#{spec.name}/KLiaoMarrySwift-Bridging-Header.h\" } spec.dependency 'RxSwift' spec.dependency 'RxCocoa' spec.dependency 'Cartography', '~\u003e 4.0.0' spec.dependency 'ZDFlexLayoutKit' end ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:10:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"解惑 1. Xcode9 \u0026 Cocopoads 1.5 之后，不是已经支持把Swift编译为静态库了吗，为什么会报错呢？ 第三方库对于把混编pod编译为静态库支持的不好，这不是苹果的锅，而是三方库的锅，像 Kingfisher、RxCocoa都有问题 这两个库笔者已经提了pr 来解决这个问题，现已合入主分支，从 RxCocoa 6.1.0、Kingfisher 6.1.0 开始都已支持编译为静态库; RxCocoa #2281 Kingfisher #1608 2. 为什么改为动态库就可以正常编译通过了？ 静态库需要使用绝对路径引用，而动态库强制把头文件平铺了，所以动态库能引到，静态库引不到 可以自己验证一下，改成 #import \"\u003cmodule-name\u003e/xxxx.h\" 之后你再编译一下 3. 为什么设置 header_dir 编译就不报错了？ 默认情况下使用的是普通的header ，设置header_dir之后，pod会以header_dir为名创建一个文件夹，然后把所有public出来的头文件引用放里面，umbrella引用头文件的时候其实指向的都是这里； 见源码 header_dir_code 4. pod中没有bridging-header为什么swift还能引用oc类？ pod中umbrella文件，它的作用其实就相当于是主工程中的bridging-header。 优化 podspec中设置的source_files路径下的文件默认都是public的，而public的头文件默认都会放到umbrella中，这样很容易导致umbrella中头文件过多，尤其是业务pod，影响编译速度。 我们可以把文件默认设置为private_header_files，然后只需把给swift用的头文件设置为public，尽量减少头文件数量。 spec.subspec 'Room' do |s| publicHeaders = Dir[\"Source/Room/PublicHeaders/*.h\"] privateHeaders = Dir[\"Source/Room/**/*.{h}\"] - publicHeaders s.source_files = 'Source/Room/**/*.{h,m,swift}' s.public_header_files = publicHeaders s.private_header_files = privateHeaders end ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:11:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"参考 importing_objective-c_into_swift importing_swift_into_objective-c https://www.rubydoc.info/gems/cocoapods-core/Pod/BuildType https://github.com/CocoaPods/CocoaPods/pull/7724 PromiseKit.podspec 6.15.3 ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:12:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["Jenkins"],"content":"Jenkins踩坑记录","date":"2020-04-18","objectID":"/jenkins_note/","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"1、homebrew安装的Jenkins无法通过IP访问 这是因为brew把jenkins启动的监听地址设置为了127.0.0.1，改为0.0.0.0即可实现访问 jenkins配置所在路径：~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist jenkins_config_address ","date":"2020-04-18","objectID":"/jenkins_note/:1:0","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"2、jenkins脚本中无法使用pod、brew等命令 需要在脚本开头添加 -l #!/usr/bin/env sh -l export LANG=en_US.UTF-8 export LANGUAGE=en_US.UTF-8 export LC_ALL=en_US.UTF-8 ","date":"2020-04-18","objectID":"/jenkins_note/:2:0","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"3、构建中生成的数据无法传递给构建阶段 解决：把数据写入文件，然后通过Jenkins种的FILE获取 写文件 # 创建下载地址日志文件 download_urls=\"${EXPORT_DIR}/DownLoadURLs.log\" if [[ ! -f ${download_urls} ]]; then touch ${download_urls} fi # 清空文件 echo \"\" \u003e ${download_urls} echo \"包名称：${application_name} \u003cbr/\u003e\" \u003e\u003e ${download_urls} 读文件 Jenkins打包结果：\u003cbr/\u003e\u003chr/\u003e ${FILE, path=\"${PACKAGE_DIR}/${branch}/Package/DownLoadURLs.log\"} \u003cbr/\u003e\u003chr/\u003e 项目名称：$PROJECT_NAME\u003cbr/\u003e\u003chr/\u003e 构建编号：$BUILD_NUMBER\u003cbr/\u003e\u003chr/\u003e 构建状态：$BUILD_STATUS\u003cbr/\u003e\u003chr/\u003e 触发原因：${CAUSE}\u003cbr/\u003e\u003chr/\u003e 构建日志地址：\u003ca href=\"${BUILD_URL}console\"\u003e${BUILD_URL}console/\u003c/a\u003e\u003cbr/\u003e\u003chr/\u003e 构建地址：\u003ca href=\"$BUILD_URL\"\u003e$BUILD_URL\u003c/a\u003e\u003cbr/\u003e\u003chr/\u003e 变更集:${JELLY_SCRIPT,template=\"html\"}\u003cbr/\u003e\u003chr/\u003e ","date":"2020-04-18","objectID":"/jenkins_note/:3:0","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"4、自动输入 比如自动输入 Y # 输入一次 echo Y # 输入任意次 yes Y ","date":"2020-04-18","objectID":"/jenkins_note/:4:0","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"5、填充密码 使用echo 加 -S 解决 echo \"密码\" | sudo -S gem install cocoapods ","date":"2020-04-18","objectID":"/jenkins_note/:5:0","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"6、从构建日志中过滤日志 比如修改构建名称和构建描述 # 构建名称（编号 + 分支 + 当前登录用户） ${BUILD_NUMBER}_${branch##*/}_${BUILD_LOG_MULTILINE_REGEX,showTruncatedLines=\"false\", maxMatches=1,regex=\"Started by user.*\"} # 从构建日志中提取描述 ${BUILD_LOG_MULTILINE_REGEX,showTruncatedLines=\"false\", regex=\"BID:.*|Version:.*|commitId:.*\"} 获取登录用户名的另一种方式，需要打开Set jenkins user build variables #${BUILD_NUMBER}_${PROJECT_BRANCH}_${BUILD_USER} ","date":"2020-04-18","objectID":"/jenkins_note/:6:0","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"Jenkins插件推荐 插件镜像： http://mirror.esuni.jp/jenkins/updates/update-center.json Blue Ocean Pipeline Priority Sorter Plugin Extented Choice Parameter Plugin-In Git Parameter Plug-In List Git Branches Parameter Environment Injector Credentials Plugin CocoaPods Jenkins Integration Keychains and Provisioning Profiles Management Xcode Integration Safe Restart Plugin ","date":"2020-04-18","objectID":"/jenkins_note/:6:1","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"Shell Tips： 执行出错时自动执行后面的命令（||）： xcodebuild archive || echo \"执行失败\" 设置默认值：PROJECT_DIR=${project_path:-$WORKSPACE} #如果参数未设置取默认值 ","date":"2020-04-18","objectID":"/jenkins_note/:6:2","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["Jenkins"],"content":"参考资料： Updating Homebrew’s “httpListenAddress” Default for Jenkins Shell 十三问 ","date":"2020-04-18","objectID":"/jenkins_note/:6:3","tags":["jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["实现原理"],"content":"简析几个 Promise 开源库的实现 Promise思想的开源库其实有很多，这里仅简单分析下Bolts、PromiseKit、promises ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:0:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"一、 Bolts Facebook出品 BFTask原理： 每个BFTask自己都维护着一个任务数组，当task执行continueWithBlock:后（会生成一个新的BFTask），continueWithBlock:带的那个block会被加入到任务数组中，每当有结果返回时，会执行trySetResult:方法，这个方法中会拿到task它自己维护的那个任务数组，然后取出其中的所有任务block，然后遍历执行。 /// 内部维护的任务数组 @property (nonatomic, strong) NSMutableArray *callbacks; /// `continueWithBlock:`方法 - (BFTask *)continueWithExecutor:(BFExecutor *)executor block:(BFContinuationBlock)block cancellationToken:(nullable BFCancellationToken *)cancellationToken { // 创建一个新的`BFTaskCompletionSource`，创建它时，它里面会`new`一个`task`对象，最后`return`的也是这个`task` // 这个不是单例方法，所以此处创建的`task`是一个新对象 BFTaskCompletionSource *tcs = [BFTaskCompletionSource taskCompletionSource]; // (1) // 创建一个任务`block`，后面会把执行这个`block`的操作加入到数组中，当回调时会执行这个`block`里面的操作 // P.S. 下面附一张把这个block折叠后的图片 dispatch_block_t executionBlock = ^{ //(N.0) if (cancellationToken.cancellationRequested) { [tcs cancel]; return; } // 把当前类（`task`对象）作为参数进行回调 //(N.1) id result = nil; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wdeprecated-declarations\" if (BFTaskCatchesExceptions()) { @try { result = block(self); } @catch (NSException *exception) { NSLog(@\"[Bolts] Warning: `BFTask` caught an exception in the continuation block.\" @\" This behavior is discouraged and will be removed in a future release.\" @\" Caught Exception: %@\", exception); tcs.exception = exception; return; } } else { result = block(self); } #pragma clang diagnostic pop // 如果回调结果返回的是`BFTask`类型 if ([result isKindOfClass:[BFTask class]]) { // 下面`block`中的`task`就是上面的`result` id (^setupWithTask) (BFTask *) = ^id(BFTask *task) { //(N.3) if (cancellationToken.cancellationRequested || task.cancelled) { [tcs cancel]; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wdeprecated-declarations\" } else if (task.exception) { tcs.exception = task.exception; #pragma clang diagnostic pop } else if (task.error) { tcs.error = task.error; } else { tcs.result = task.result; } return nil; }; BFTask *resultTask = (BFTask *)result; /// 如果`continueWithBlock:`中的`block`回调返回的`task`是`complete`状态，则直接到 (N.3)，把任务的结果传递到上面新创建的那个`BFTask`对象的`result`属性中,否则就继续执行`continueWithBlock:`来监测任务状态 if (resultTask.completed) { setupWithTask(resultTask); //(N.2) } else { [resultTask continueWithBlock:setupWithTask]; //(N.4) } } else { tcs.result = result; } }; // 如果是未完成状态，则把操作加入到数组中，延后执行；否则就立即执行 BOOL completed; @synchronized(self.lock) { //(2.0) completed = self.completed; if (!completed) { // 把任务添加到数组中 [self.callbacks addObject:[^{ [executor execute:executionBlock]; } copy]]; } } if (completed) { //(2.1) [executor execute:executionBlock]; } return tcs.task; } ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:1:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"二、 PromiseKit 首先，让我们看看创建Promise的源码 + (instancetype)promiseWithResolver:(void (^)(PMKResolver))block { // (2) PMKPromise *this = [self alloc]; // (3) 初始化promise this-\u003e_promiseQueue = PMKCreatePromiseQueue(); this-\u003e_handlers = [NSMutableArray new]; @try { block(^(id result){ // (4) 立即开始原始任务（它传过去的参数还是一个`PMKResolver`类型的block，这个block会在PMKRejecter或者PMKFulfiller类型的block执行回调时执行） \"void (^PMKResolver)(id)\" if (PMKGetResult(this)) return PMKLog(@\"PromiseKit: Warning: Promise already resolved\"); PMKResolve(this, result); // (7) result为用户在`new:`方法中返回的数据结果,而this则是上面一开始时初始化的那个promise. 执行到这里后接下来会到(8),回调到(9)那个block,这个block中会遍历`handlers`数组中的`handler()` block, }); } @catch (id e) { // at this point, no pointer to the Promise has been provided // to the user, so we can’t have any handlers, so all we need // to do is set _result. Technically using PMKSetResult is // not needed either, but this seems better safe than sorry. PMKSetResult(this, NSErrorFromException(e)); } return this; } + (instancetype)new:(void(^)(PMKFulfiller, PMKRejecter))block { // (1) return [self promiseWithResolver:^(PMKResolver resolve) { id rejecter = ^(id error){ // (5-1) 失败的block if (error == nil) { error = NSErrorFromNil(); } else if (IsPromise(error) \u0026\u0026 [error rejected]) { // this is safe, acceptable and (basically) valid } else if (!IsError(error)) { id userInfo = @{NSLocalizedDescriptionKey: [error description], PMKUnderlyingExceptionKey: error}; error = [NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:userInfo]; } resolve(error); }; id fulfiller = ^(id result){ // (5-2) 成功的block if (IsError(result)) PMKLog(@\"PromiseKit: Warning: PMKFulfiller called with NSError.\"); resolve(result); // (6) 当用户执行`PMKFulfiller`类型的block时,会回调到这里,此方法执行(4)中的那个参数block,即执行(7) }; block(fulfiller, rejecter); // (5-3) 把成功和失败的block作为参数，执行回调原任务（e.g demo中的网络请求任务） }]; } static void PMKResolve(PMKPromise *this, id result) { void (^set)(id) = ^(id r){ // (9) handle回调执行(10) NSArray *handlers = PMKSetResult(this, r); for (void (^handler)(id) in handlers) handler(r); }; if (IsPromise(result)) { PMKPromise *next = result; dispatch_barrier_sync(next-\u003e_promiseQueue, ^{ id nextResult = next-\u003e_result; if (nextResult == nil) { // ie. pending [next-\u003e_handlers addObject:^(id o){ PMKResolve(this, o); }]; } else set(nextResult); }); } else set(result); // (8) } 调用new:方法时会调用promiseWithResolver:方法，在里面进行一些初始化promise的工作：创建了一个GCD并发队列和一个数组，并立即回调new:后面的那个参数block，即：立即执行，生成一个成功fulfiller和失败rejecter的block，这个block将由用户控制回调操作的时机。 下面看一下then的实现： - (PMKPromise *(^)(id))then { // 1 // 此处`then`本身就是一个block：（PMKPromise *(^then)(id param)），此方法类似于getter方法 // 返回一个`(PMKPromise *(^)(id))`类型的block，这个block执行后，返回一个PMKPromise // 下面整个都是一个then `block`，当执行then的时候会调用 `self.thenOn(dispatch_get_main_queue(), block)`，返回一个Promise类型的结果 return ^(id block){ return self.thenOn(dispatch_get_main_queue(), block); }; } - (PMKResolveOnQueueBlock)thenOn { return [self resolved:^(id result) { if (IsPromise(result)) return ((PMKPromise *)result).thenOn; if (IsError(result)) return ^(dispatch_queue_t q, id block) { return [PMKPromise promiseWithValue:result]; }; return ^(dispatch_queue_t q, id block) { // HACK we seem to expose some bug in ARC where this block can // be an NSStackBlock which then gets deallocated by the time // we get around to using it. So we force it to be malloc'd. block = [block copy]; return dispatch_promise_on(q, ^{ return pmk_safely_call_block(block, result); }); }; } pending:^(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolve)(id)) { if (IsError(result)) PMKResolve(next, result); else dispatch_async(q, ^{ resolve(pmk_safely_call_block(block, result)); // (11) }); }]; } - (id)resolved:(PMKResolveOnQueueBlock(^)(id result))mkresolvedCallback pending:(void(^)(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolver)(id)))mkpendingCallback { __block PMKResolveOnQueueBlock callBlock; __block id result; dispatch_sync(_promiseQueue, ^{ if ((result = _result)) // 有结果的情况下直接返回 retur","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:2:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"三、 Promises google出品 原理： 这个开源库的思路其实与BFTask很相似，每次promise执行then方法时都会创建一个新的promise对象，同时会创建一个观察者（block对象），这个观察者会持有这个新的promise，当（旧）promise对象fulfilled或者rejected的时候，会把fulfilled或者rejected拿到的value给新promise。 先看下promise的初始化方法: - (instancetype)initPending { self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self; } 首先进入一个单例dispatch_group_t中，为啥用dispatch_group_t呢？因为后面的then方法可以在其他队列处理，而且dispatch_group_t有同步队列的功能，后面作者每次初始化一个promise都会enter到dispatch_group_t中，fulfilled或者rejected时再leave。 接下来看看最重要同时也是精华所在的then方法： - (instancetype)initPending { // (0) self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self; } - (FBLPromise *)onQueue:(dispatch_queue_t)queue then:(FBLPromiseThenWorkBlock)work { return [self chainOnQueue:queue chainedFulfill:work chainedReject:nil]; // (1) } - (FBLPromise *)chainOnQueue:(dispatch_queue_t)queue chainedFulfill:(FBLPromiseChainedFulfillBlock)chainedFulfill chainedReject:(FBLPromiseChainedRejectBlock)chainedReject { // 首先new一个新的promise对象 FBLPromise *newPromise = [[FBLPromise alloc] initPending]; // (2) // 这个block其实就是抽离的一个方法，避免写重复代码。 // 当promise被fulfilled或者rejected时都会调用； // 结合下面方法block中的实现可以看出，如果thenBlock（chainedFulfill）存在，则先执行chainedFulfill这个block（其实就是map一下这个value值）重新生成一个value值（value值也可能不会变化，主要还得看map函数里有没有改变value）；接下来把这个重新赋值的value扔给resolverBlock，resolverBlock会把这个新的value给newPromise，newPromise会调用fulfilled方法，如果此时newPromise也有订阅者(被then过)，则就会把这个新value传递给下一个newNewPromise ... // 如果then的时候promise已经结束了，则直接把结果返回给订阅者,即调用thenBlock。 __auto_type resolver = ^(id __nullable value) { if ([value isKindOfClass:[FBLPromise class]]) { // (8) [(FBLPromise *)value observeOnQueue:queue fulfill:^(id __nullable value) { [newPromise fulfill:value]; } reject:^(NSError *error) { [newPromise reject:error]; }]; } else { [newPromise fulfill:value]; // (8) } }; [self observeOnQueue:queue fulfill:^(id __nullable value) { value = chainedFulfill ? chainedFulfill(value) : value; // (7) resolver(value); } reject:^(NSError *error) { id value = chainedReject ? chainedReject(error) : error; // (7) resolver(value); }]; return promise; } - (void)observeOnQueue:(dispatch_queue_t)queue fulfill:(FBLPromiseOnFulfillBlock)onFulfill reject:(FBLPromiseOnRejectBlock)onReject { @synchronized(self) { // (3) switch (_state) { // 默认的state，即待处理的事件 case FBLPromiseStatePending: { // 如果promise对象还没有观察者数组，new一个 // 这里为什么需要观察者数组呢？因为一个Promise可以被then很多次 if (!_observers) { _observers = [[NSMutableArray alloc] init]; } // 当事件被处理时会执行下面block __auto_type observer = ^(FBLPromiseState state, id __nullable resolution) { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ switch (state) { // (6) case FBLPromiseStatePending: break; case FBLPromiseStateFulfilled: onFulfill(resolution); break; case FBLPromiseStateRejected: onReject(resolution); break; } }); }; [_observers addObject:observer]; // (4) break; } // 当前promise已经结束 case FBLPromiseStateFulfilled: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onFulfill(self-\u003e_value); }); break; } // 当前promise已经结束 case FBLPromiseStateRejected: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onReject(self-\u003e_error); }); break; } } } } - (void)fulfill:(nullable id)value { if ([value isKindOfClass:[NSError class]]) { [self reject:(NSError *)value]; } else { @synchronized(self) { if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateFulfilled; _value = value; _pendingObjects = nil; for (FBLPromiseObserver observer in _observers) { observer(_state, _value); // (5) } _observers = nil; // 事件结束，leave group dispatch_group_leave(FBLPromise.dispatchGroup); } } } } - (void)reject:(NSError *)error { NSAssert([error isKindOfClass:[NSError class]], @\"Invalid error type.\"); if (![error isKindOfClass:[NSError class]]) { // Give up on invalid error type in Release mode. @throw error; // NOLINT } @synchronized(self) { if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateRejected; _error = error; _pendingObjects = nil; for (FBLPromiseObserver observer in ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:3:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"参考： iOS如何优雅的处理“回调地狱Callback hell”(一)——使用PromiseKit ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:4:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"探索block变量捕获的原理","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"探索block捕获外界变量的原理 在此之前先介绍一下block 基本语法： BlockSyntax Block Syntax // Block as a local variable returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; // Block as a property @property (nonatomic, copy) returnType (^blockName)(parameterTypes); // Block as a method parameter - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; // Block as an argument to a method call [someObject someMethodThatTakesABlock: ^returnType (parameters) {...}]; // Block as typedef typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; 对Object-C文件执行 xcrun -sdk iphonesimulator clang -fobjc-arc -fobjc-runtime=ios -rewrite-objc fileName.m 操作来获取伪代码，仅供技术探究。 先把__block_impl结构体拿出来放在最前面，最终block调用时都会被强转成这种类型，下面好多地方会用到。 struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; isa指针：指向一个类对象，在非GC模式下有三种类型：_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock； Flags：block的负载信息（引用计数和类型信息），按位存储； Reserved：保留变量； FuncPtr：指向block函数地址的指针。 descriptor：是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。 接下来进入正题： p.s：以下Objective-C的代码都处在ARC环境下 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:0:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"1、不加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; block(); } } 执行clang操作后的C++代码: // 定义block的结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSMutableArray *mutArr; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableArray *_mutArr, int flags=0) : mutArr(_mutArr) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 以下为调用`block`时执行的方法 // 此`mutArr`是在最初定义`block`时 为结构体传进去的局部变量`mutArr`的值 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // bound by copy:这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。 NSMutableArray *mutArr = __cself-\u003emutArr; // bound by copy ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)mutArr, sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } // block的copy函数 static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; NSMutableArray *mutArr = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); // 可以看出block变量实际上就是一个指向结构体`__main_block_impl_0`的指针,而结构体的第三个元素是局部变量mutArr的值 // 此处捕获的直接就是`mutArr`局部变量 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, mutArr, 570425344)); // 下面调用`block`的方法实质其实是: 指向结构体的指针`block`访问其`FuncPtr`元素(即,在定义block时为`FuncPtr`元素传进去的`__main_block_func_0`方法) ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:1:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"2、添加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { __block NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; [mutArr addObject:@\"hello\"]; block(); } } 执行clang后的C++代码: // 由下面的代码可知: `__block`的作用就是定义一个新的结构体来包裹原来的变量 // 定义一个保存变量的结构体 （被__block标记的变量会被转化为这种格式的结构体对象） struct __Block_byref_mutArr_0 { void *__isa; __Block_byref_mutArr_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSMutableArray *mutArr; }; // block 结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 包含捕获的局部变量的结构体指针 __Block_byref_mutArr_0 *mutArr; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_mutArr_0 *_mutArr, int flags=0) : mutArr(_mutArr-\u003e__forwarding) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 在block内部对`mutArr`操作 (block回调时执行的函数) static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 拿到 包含捕获的局部变量 的结构体指针 __Block_byref_mutArr_0 *mutArr = __cself-\u003emutArr; // bound by ref // 通过上面的结构体指针一步步拿到`mutArr`数组 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr-\u003e__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; // 这里可以看到结构体中的 __forwarding 指针其实指向的就是其自身 __attribute__((__blocks__(byref))) __Block_byref_mutArr_0 mutArr = {(void*)0,(__Block_byref_mutArr_0 *)\u0026mutArr, 33554432, sizeof(__Block_byref_mutArr_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\"))}; // 与不加__block差不多,`block`变量还是一个指向`__main_block_impl_0`结构体的指针,区别在于第三个参数变了. 第三个参数是包含局部变量`mutArr`的结构体指针. // 即block捕获的是持有`mutArr`的结构体指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, (__Block_byref_mutArr_0 *)\u0026mutArr, 570425344)); // 在block外部对`mutArr`操作 // // 此处对`mutArr`数组对象进行操作,获取`mutArr`也是和`block`内部的获取方法一样, // 都是通过持有`mutArr`的结构体一步步获取到`mutArr`数组, // // 这里要经过 __forwarding 来获取`mutArr`的原因是： // __block 标记的变量有可能被copy到堆上，__forwarding 的作用就是在被copy到堆上时修改指向，使栈和堆上的 __forwarding 都指向堆上的那个副本，这样就保证了block内外操作的都是同一份内存。 // 具体的copy实现可以参见下面的 `_Block_byref_copy` 函数 // // 所以,在block内外,操作的都是同一个`mutArr`对象.都是通过包含`mutArr`对象的`__Block_byref_mutArr_0`结构体对其进行间接操作处理的 // 这也就是为什么添加`__block`后还能改变原来的对象的原因 // // PS: 当我们用__block 标记一个变量以后，当我们用到这个变量时都不是直接使用这个变量了，而是变成了通过`__Block_byref`来操作这个变量 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr.__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)(NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_b07809_mi_0); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; // __block 变量被copy到堆上时的具体实现 static struct Block_byref *_Block_byref_copy(const void *arg) { struct Block_byref *src = (struct Block_byref *)arg; if ((src-\u003eforwarding-","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:2:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"3、静态变量: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { static NSString *myString = @\"111\"; void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang之后的C++代码： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 注意这里, 外面的静态变量被捕获了,不过捕获的是对象的指针 NSString **myString; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString **_myString, int flags=0) : myString(_myString) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString **myString = __cself-\u003emyString; // bound by copy // 通过对`myString`指针进行取值操作(*myString),拿到 myString ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)(*myString), sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_1); // 由下面的伪代码可以看出,由于`myString`是指针,所以通过`*`操作来获取到原来的变量, // 然后再对其进行重新赋值操作 (*myString) = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_121621_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_2, (*myString)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emyString, (void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; static NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_0; // block捕获的是静态变量的指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, \u0026myString, 570425344)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_3); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:3:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"4、全局变量: #import \u003cFoundation/Foundation.h\u003e NSString *myString = @\"111\"; int main(int argc, char *argv[]) { @autoreleasepool { void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang操作执行之后的C++伪代码: NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_0; // block结构体并没有捕获全局变量 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 下面三个函数都是在用到全局变量`myString`的时候直接从内存去获取 ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_1); myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_3, myString); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_4); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:4:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"总结: 局部变量： 不加__block: block内部捕获的是局部变量的值，而且如果局部变量是数值类型（比如int）不会有__main_block_copy_0 和 __main_block_dispose_0 两个函数，如果是引用类型（比如NSArray）则会有这个函数，说明对于值类型变量是直接定义新变量并赋值相同，对于引用类型变量是定义一个新变量并copy这个对象的指针。 添加__block: 原来的局部变量会被放入到一个__Block_byref_变量名_0类型的结构体中，然后block内部当捕获局部变量时其实是捕获的是这个结构体的指针，当获取原来的局部变量时(不管是在block内还是block外)，其实都是通过这个结构体或者这个结构体指针来拿到原来的局部变量再进行操作的。这也就是为什么添加__block后可以对block内捕获的局部变量进行重新赋值等操作。 静态变量： block直接捕获的是静态变量的指针，前后都是对指针进行操作。 全局变量（或 全局静态变量）： block并没有捕获变量，而是在结构体的执行方法中直接使用了全局变量，是在执行时才去取值，一直都是获取变量的最新值。而且细心点我们可以发现，对于没有捕获全局变量的block中也没有__main_block_copy_0 和 __main_block_dispose_0 两个函数（用于在调用前后修改相应变量的引用计数），即没有发生copy操作。 其他 ARC环境下：在单独声明block的时候，block还是会在栈上的；当block作为参数返回的时候，block也会自动被移到堆上；在ARC下，只要指针过一下strong指针，或者由函数返回都会把block移动到堆上。 __main_block_copy_0 中的 _Block_object_assign 函数相当于retain实例方法，使 block 的成员变量持有捕获到的对象。 __main_block_dispose_0 中的 _Block_object_dispose 函数相当于 release 实例方法，释放 block 的成员变量持有的对象。 Objective-C 中的3种block： __NSStackBlock__、__NSMallocBlock、__NSGloballBlock 会在下面的情况下出现： 条件 ARC MRC 捕获外部变量 __NSStackBlock__ __NSMallocBlock__ __NSStackBlock__ 未捕获外部变量 __NSGlobalBlock__ __NSGlobalBlock__ 在 ARC 中，捕获了外部变量的block的类型会是__NSStackBlock__ 或者 __NSMallocBlock__，如果 block 被赋值给了某个变量，在这个过程中会执行_Block_copy，将原有的 __NSStackBlock__ 变成 __NSMallocBlock__；但是如果 block 没有被赋值给某个变量，那它的类型就是__NSStackBlock__；没有捕获外部变量的 block 的类则是 __NSGlobalBlock__ ，既不在栈上，也不在堆上，它类似于 C 语言函数一样，会在代码段中。 在MRC中，捕获了外部变量的 block 的类会是__NSStackBlock__，放置在栈上；没有捕获外部变量的 block 与 ARC 环境下的情况是相同的，类型是__NSGlobalBlock__，放置在代码段中。 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:5:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"推荐文章： 比我写的好 Block本质 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:6:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"参考文章: 谈Objective-C Block的实现 iOS中的block是如何持有对象的 深入分析Objective-C block、weakself、strongself实现原理 block-copy ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:7:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["Tips"],"content":"代码技巧","date":"2018-07-11","objectID":"/codetips/","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"1. GNU-C的赋值扩展 即使用({...})的形式。这种形式的语句可以类似很多脚本语言，在顺次执行之后，会将最后一次的表达式的值作为返回值。 注意：这个不是懒加载 RETURN_VALUE_RECEIVER = {( // do whatever you want ... RETURN_VALUE; // 返回值 )}; REMenu 这个开源库中就使用了这种语法，如下： _titleLabel = ({ UILabel *label = [[UILabel alloc] initWithFrame:titleFrame]; label.isAccessibilityElement = NO; label.contentMode = UIViewContentModeCenter; label.textAlignment = (NSInteger)self.item.textAlignment == -1 ? self.menu.textAlignment : self.item.subtitleTextAlignment; label.backgroundColor = [UIColor clearColor]; label.autoresizingMask = UIViewAutoresizingFlexibleWidth; label; }); 使用这种语法的其中一个优点是结构鲜明紧凑，而且由于不用担心块里面的变量名污染外面变量名的问题。 ","date":"2018-07-11","objectID":"/codetips/:1:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"2. case语句中使用范围表达式 GCC对C11标准的语法扩展 比如，case 1 ... 5 就表示值如果在 1~5 的范围内则满足条件。 这里，省略号 ... 就作为一个范围操作符，其左右两个操作数之间至少要用一个空白符进行分割，如果写成 1...5 这种形式会引发词法解析错误。范围操作符的操作数可以是任一整数类型，包括字符类型。 另外，范围操作符的做操作数的值应该小于或等于右操作数，否则该范围表达式就会是一个空条件范围，永远不成立。 #include \u003cstdio.h\u003e int main(int argc, const char * argv[]) { int a = 1; const int c = 10; switch(a) { // 这条case语句是合法的，并且与case 1等效 case 1 ... 1: printf(\"a = %d\\n\", a); break; // 这条case语句中的范围操作符的左操作数⼤于右操作数， // 因此它是⼀个空条件范围，这条case语句下的逻辑永远不会被执⾏ case 2 ... 1: puts(\"Hello, world!\"); break; // 使⽤const修饰的对象也可作为范围操作符的操作数 case 8 ... c: puts(\"Wow!\"); break; default: break; } char ch = 'A'; switch(ch) { // 从'A'到'Z'的ASCII码范围 case 'A' ... 'Z': printf(\"The letter is: %c\\n\", ch); break; // 从'0'到'9'的ASCII码范围 case '0' ... '9': printf(\"The digit is: %c\\n\", ch); break; default: break; } } ","date":"2018-07-11","objectID":"/codetips/:2:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"3. __auto_type GCC对C11标准的语法扩展 #if defined(__cplusplus) #define var auto #define let auto const #else #define var __auto_type #define let const __auto_type #endif 例如： let block = ^NSString *(NSString *name, NSUInteger age) { return [NSString stringWithFormat:@\"%@ + %ld\", name, age]; }; let result = block(@\"foo\", 100); // no warning ","date":"2018-07-11","objectID":"/codetips/:3:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"4. 结构体的初始化 // 不加(CGRect)强转也不会warning GRect rect1 = {1, 2, 3, 4}; CGRect rect2 = {.origin.x=5, .size={10, 10}}; // {5, 0, 10, 10} CGRect rect3 = {1, 2}; // {1, 2, 0, 0} ","date":"2018-07-11","objectID":"/codetips/:4:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"5. 数组的下标初始化 const int numbers[] = { [1] = 3, [2] = 2, [3] = 1, [5] = 12306 }; // {0, 3, 2, 1, 0, 12306} 这个特性可以用来做枚举值和字符串的映射 typedef NS_ENUM(NSInteger, Type){ Type1, Type2 }; const NSString *TypeNameMapping[] = { [Type1] = @\"Type1\", [Type2] = @\"Type2\" }; 又如 UITableView+FDIndexPathHeightCache中的例子： // All methods that trigger height cache's invalidation SEL selectors[] = { @selector(reloadData), @selector(insertSections:withRowAnimation:), @selector(deleteSections:withRowAnimation:), @selector(reloadSections:withRowAnimation:), @selector(moveSection:toSection:), @selector(insertRowsAtIndexPaths:withRowAnimation:), @selector(deleteRowsAtIndexPaths:withRowAnimation:), @selector(reloadRowsAtIndexPaths:withRowAnimation:), @selector(moveRowAtIndexPath:toIndexPath:) }; for (NSUInteger index = 0; index \u003c sizeof(selectors) / sizeof(SEL); ++index) { SEL originalSelector = selectors[index]; SEL swizzledSelector = NSSelectorFromString([@\"fd_\" stringByAppendingString:NSStringFromSelector(originalSelector)]); Method originalMethod = class_getInstanceMethod(self, originalSelector); Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); } ","date":"2018-07-11","objectID":"/codetips/:5:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"6. 自带提示的keypath宏 #define keypath2(OBJ, PATH) \\ (((void)(NO \u0026\u0026 ((void)OBJ.PATH, NO)), # PATH)) ","date":"2018-07-11","objectID":"/codetips/:6:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"7. 逗号表达式 逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告 int a = ((void)(1+2), 2); // a == 2 于是上面的keypath宏的输出结果是#PATH也就是一个c字符串 ","date":"2018-07-11","objectID":"/codetips/:7:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"8. C函数重载标示符 RTRootNavigationController 中有用到这个技巧 __attribute((overloadable)) NSInteger ZD_SumFunc(NSInteger a, NSInteger b) { return a + b; } __attribute((overloadable)) NSInteger ZD_SumFunc(NSInteger a, NSInteger b, NSInteger c) { return a + b + c; } ","date":"2018-07-11","objectID":"/codetips/:8:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"9. 参数个数 // 最多支持10个参数 #define COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8, _a9, _a10, RESULT, ...) RESULT #define COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) int count = COUNT_PARMS(1,2,3,4,5,6); // 预处理时count == 6 ","date":"2018-07-11","objectID":"/codetips/:9:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"10. 同名全局变量或者全局函数共存 // 下面二者可以并存 NSDictionary *ZDInfoDict = nil; __attribute__((weak)) NSDictionary *ZDInfoDict = nil; ","date":"2018-07-11","objectID":"/codetips/:10:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"11. 偷梁换柱 class Test { dynamic func foo() { print(\"bar\") } } extension Test { @_dynamicReplacement(for: foo()) func new_foo() { print(\"bar new\") foo() // calls previous implementation } } Test().foo() // bar new 有2点需要说明： 标注dynamic关键字 在工程中运行，playground不支持 ","date":"2018-07-11","objectID":"/codetips/:11:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"12. 移花接木 @_silgen_name(\"backtrace\") internal func swift_backtrace(_ callstacks: UnsafeMutableRawPointer, _ counts: Int) -\u003e Int @_silgen_name(\"backtrace_symbols\") internal func swift_backtrace_symbols(_ callstacks: UnsafeRawPointer, _ counts: Int) -\u003e UnsafeMutablePointer\u003cUnsafePointer\u003cCChar\u003e\u003e? //------------------------------------------------ static func callstack() -\u003e [String] { var callstack = [UnsafeMutableRawPointer?](repeating: nil, count: 128) let frames = swift_backtrace(\u0026callstack, callstack.count) var callstackArr: [String] = [] if let symbols = swift_backtrace_symbols(\u0026callstack, frames) { for frame in 0..\u003cframes { let symbol = String(cString: symbols[frame]) callstackArr.append(symbol) } free(symbols) os_log(\"堆栈信息 =\u003e %@\", log: .apmLog, type: .info, callstackArr) } return callstackArr } ","date":"2018-07-11","objectID":"/codetips/:12:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"13. Swift类名解析 # xcrun swift-demangle _TtC11NewWolfKill22WKRoomControlMenuModel $ xcrun swift-demangle \u003cyour-mangled-symbol\u003e ","date":"2018-07-11","objectID":"/codetips/:13:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"14. 队列校验 methodThatCallsBackOnMain(completion: { result in // 确保在主队列中调用 dispatchPrecondition(.onQueue(.main)) // process `result` // ... }) ","date":"2018-07-11","objectID":"/codetips/:14:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"15. Assert assert会导致程序退出，下面这种方式不会使程序退出而只是让IDE断在指定位置，类似于打断点那种效果 // 适用于所有架构 __builtin_debugtrap() 如果是模拟器，可以使用内联汇编的方式 asm(\"int3\") 如果是win平台，可以用 __debugbreak() 贴段样例： // MARK: - ZDAssert #if DEBUG #ifndef ZDAssert #define ZDAssert(condition, format, ...) do { \\ _Pragma(\"clang diagnostic push\") \\ _Pragma(\"clang diagnostic ignored \\\"-Wobjc-literal-conversion\\\"\") \\ if (condition) break; \\ if (format) printf(\"\\n%s\\n\\n\", [[NSString stringWithFormat:format, ##__VA_ARGS__] UTF8String]); \\ _Pragma(\"clang diagnostic pop\") \\ __builtin_debugtrap(); \\ } while(0); #endif #else #ifndef ZDAssert #define ZDAssert(condition, format, ...) #endif #endif 这里建议加上一个条件–只在调试期间起作用，因为在非调试阶段执行到这个trap程序会挂掉，代码如下： import Darwin // See http://developer.apple.com/library/mac/#qa/qa1361/_index.html @objc public class func isDebuggerAttached() -\u003e Bool { var info = kinfo_proc() var mib = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()] var size = MemoryLayout\u003ckinfo_proc\u003e.stride let junk = sysctl(\u0026mib, u_int(mib.count), \u0026info, \u0026size, nil, 0) assert(junk == 0) let isDebuggerAttaced = info.kp_proc.p_flag \u0026 P_TRACED != 0 return isDebuggerAttaced } ","date":"2018-07-11","objectID":"/codetips/:15:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"16. 保证对象的生命周期 Swift withExtendedLifetime() var owningReference = Instance() ... withExtendedLifetime(owningReference) { dosomething(...) } // Assuming: No stores to owned occur for the dynamic lifetime of // the withExtendedLifetime invocation. Objective-C 在 Objective-C ARC 中你可以使用 __attribute__((objc_precise_lifetime)) 或者 NS_VALID_UNTIL_END_OF_SCOPE 来标注变量以达到类似的效果。 ","date":"2018-07-11","objectID":"/codetips/:16:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"17. 区间判断 判断某一个值x是否在区间[min, max]内 第一个 (x - minx) 如果 x \u003c minx 的话，得到的结果 \u003c 0 ，即高位为 1，第二个判断同理，如果超过范围，高位也为 1，两个条件进行比特或运算以后，只有两个高位都是 0 ，最终才为真 if (( (x - minx) | (maxx - x) ) \u003e= 0) ... ","date":"2018-07-11","objectID":"/codetips/:17:0","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"参考 objc非主流代码技巧 Even Swiftier Objective-C 《C语言编程魔法书》 GCC中的弱符号与强符号 swift: SIL 30-tips-to-make-you-a-better-ios-developer C/C++调试技巧-debugbreak Swift 中的 ARC 机制: 从基础到进阶 C语言有什么奇淫技巧 ","date":"2018-07-11","objectID":"/codetips/:17:1","tags":["iOS","tips"],"title":"Code Tips","uri":"/codetips/"},{"categories":["Tips"],"content":"CocoaPods笔记 ","date":"2016-11-21","objectID":"/cocoapods_tips/:0:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"1、The master repo requires CocoaPods 1.0.0 - (currently using 0.38.2) 参考：http://blog.cocoapods.org/Sharding/ 安装1.0之前（e.g：v0.38.2）版本的pod sudo gem install cocoapods -v 0.38.2 之后在执行pod setup时，由于pod工具已经升级到1.xx版本了，pod算法以及Specs库中的文件结构已经改变，所以它会默认拉取新版本的Specs库，这样就会出现旧版本pod新版本Specs库的情况，当执行pod install的时候会发生找不到xxx第三方库的情况。 解决此问题的方案是需要在Podfile中指定source源地址： source \"https://github.com/CocoaPods/Old-Specs\" 并把本地的Specs库切换到旧版本： cd ~/.cocoapods/repos/master/ git fetch origin master git checkout v0.32.1 最后，在执行pod install的时候需要添加上--no-repo-update标识，因为1.0之前的pod版本在执行pod install的时候会默认先更新升级本地Specs库文件。 以下2张图分别是旧版本的spec库和新版本spec库的结构，大家可以对比一下二者的结构： oldSpec newSpec ","date":"2016-11-21","objectID":"/cocoapods_tips/:1:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"2、File not found with include; use “quoates” instead 在target中手动设置Always Search User Paths为YES，也可以通过pod动态设置（推荐） post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['ALWAYS_SEARCH_USER_PATHS'] = 'YES' end end end ","date":"2016-11-21","objectID":"/cocoapods_tips/:2:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"3、Cannot create __weak reference in file using manual reference counting https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2761 @mdiep 对出现此问题的原因的解释：In Xcode 7.3, __weak causes errors in files compiled as -fno-objc-arc. Since RAC uses __weak, you cannot use it in those files without setting the Weak References in Manual Retain Release setting to YES. If you’re using a .pch that imports RAC, you’re more likely to see this error. 错误样式如下图所示 reactiveCocoa_issue_2761 有3种解决办法： 1）修改源码：把.h文件中报错的__weak标识删除（不能删除.m文件中的，否则会发生内存问题） 2）在引入ReactiveCocoa的地方添加macro判断标识： #if __has_feature(objc_arc) #import \u003cReactiveCocoa/ReactiveCocoa.h\u003e #endif 3）设置工程文件：设置Weak References in Manual Retain Release为YES weak reference in manual ","date":"2016-11-21","objectID":"/cocoapods_tips/:3:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"4、“The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a .swift-version file to set the version for you Pod. For example to use Swift 2.3, run: echo \"2.3\" \u003e .swift-version:” 如下图所示： SwiftVersionError 解决办法： 把pod的引用方式由:git方式改为指定版本号的方式。 ","date":"2016-11-21","objectID":"/cocoapods_tips/:4:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"5、在pod的pch文件中添加引用时，比如 s.prefix_header_contents = '#import \"DDDefine.h\"' 不能添加自己工程中的文件，执行pod lib lint时，它会一直报找不到你想引入的文件的错误。 但是你可以在这里添加其他pod中的文件，或者iOS自己API中的库文件。 ","date":"2016-11-21","objectID":"/cocoapods_tips/:5:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"6、CocoaPods卸载 有的时候不小心把podSpec升级到了1.x 版本，然后pod search就不能用了，然后通过切换分支checkout到v0.32.1，但是pod search还是报错： $ pod search ZDTableView [!] Unable to load a specification for the plugin `/Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-deintegrate-1.0.0.beta.1` ――― MARKDOWN TEMPLATE ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― Command /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/pod search ZDTableView Report * What did you do? * What did you expect to happen? * What happened instead? Stack CocoaPods : 0.38.2 Ruby : ruby 2.2.1p85 (2015-02-26 revision 49769) [x86_64-darwin14] RubyGems : 2.4.8 Host : Mac OS X 10.12.2 (16C67) Xcode : 8.2.1 (8C1002) Git : git version 2.11.0 Ruby lib dir : /Users/fuxianchao/.rvm/rubies/ruby-2.2.1/lib Repositories : cocoapods - https://github.com/CocoaPods/Old-Specs @ 6e256ccc84aad851d401fabb79b2c0f9e09bb875 DDSpec - http://10.255.223.213/ios-code/DDSpec.git @ 941bed4b0c03090e13ecb7ee16a1eafa77969785 master - https://github.com/CocoaPods/Specs.git @ 2d939ca0abb4172b9ef087d784b43e0696109e7c Plugins cocoapods-keys : 1.7.0 cocoapods-playgrounds : 0.1.0 cocoapods-plugins : 0.4.2 cocoapods-search : 1.0.0.beta.1 cocoapods-stats : 0.5.3 cocoapods-trunk : 0.6.4 cocoapods-try : 0.4.5 Error NoMethodError - undefined method `all' for Pod::Platform:Class /Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-search-1.0.0.beta.1/lib/cocoapods-search/command/search.rb:34:in `initialize' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:334:in `new' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:334:in `parse' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:330:in `parse' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:308:in `run' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-0.38.2/lib/cocoapods/command.rb:48:in `run' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-0.38.2/bin/pod:44:in `\u003ctop (required)\u003e' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/pod:23:in `load' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/pod:23:in `\u003cmain\u003e' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/ruby_executable_hooks:15:in `eval' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/ruby_executable_hooks:15:in `\u003cmain\u003e' ――― TEMPLATE END ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― [!] Oh no, an error occurred. Search for existing GitHub issues similar to yours: https://github.com/CocoaPods/CocoaPods/search?q=undefined+method+%60all%27+for+Pod%3A%3APlatform%3AClass\u0026type=Issues If none exists, create a ticket, with the template displayed above, on: https://github.com/CocoaPods/CocoaPods/issues/new Be sure to first read the contributing guide for details on how to properly submit a ticket: https://github.com/CocoaPods/CocoaPods/blob/master/CONTRIBUTING.md Don't forget to anonymize any private data! 这时候我的做法通常就是卸载pod ，然后重新安装。 $ which pod //得到path $ sudo rm -rf \u003cpath\u003e // 循环遍历卸载pod组件（如果是安装在了用户目录下，那就去掉命令中的sudo） $ for i in `gem list | grep pod | awk '{print $1}'`; do sudo gem uninstall $i; done 有的时候对于新系统直接调用gem install cocoapods 是不行的，提示错误，此种情况就用下面的命令： // 安装指定版本的pod sudo gem install -n /usr/local/bin cocoapods -v 1.2.0 // 卸载 sudo gem uninstall -n /usr/local/bin cocoapods -v 1.2.0 ","date":"2016-11-21","objectID":"/cocoapods_tips/:6:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"7、Library not found for -lAFNetworking 这种情况的解决方案是设置project -\u003e build setting -\u003e library search patchs 里添加 $(inherited) 标识。 ","date":"2016-11-21","objectID":"/cocoapods_tips/:7:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"8、Cannot synthesize weak property because the current deployment target does not support weak refernces refer: http://stackoverflow.com/questions/37160688/set-deployment-target-for-cocoapodss-pod 解决方案： post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if target.name == 'DDKit' config.build_settings['ENABLE_STRICT_OBJC_MSGSEND'] = 'NO' elsif target.name == 'PulsingHalo' config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '9.2' end end end end 或者错误提示为：Cannot synthesize weak property in file using manual reference counting post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if target.name == 'ReactiveCocoa' config.build_settings['CLANG_ENABLE_OBJC_WEAK'] = 'YES' end end end end ","date":"2016-11-21","objectID":"/cocoapods_tips/:8:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"9、Cocoapods debug 我们可以用 pry 来调试 podfile ，即调试 ruby，使用之前先安装 gem install pry 接下来在 podfile 中导入 require 'pry'，然后在你想打断点调试的地方添加一行代码 binding.pry，这样就可以在每次执行pod install or pod update 的时候断在这句代码的位置，我们就可以调试了； ","date":"2016-11-21","objectID":"/cocoapods_tips/:9:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"10、自动添加modulemap的支持 如果我们想以@import的方式引用一个不支持modulemap的repo，那么我们可以让CocoaPods自动生成modulemap，语法如下： pod 'MLFilterKit', '1.9.705', :modular_headers =\u003e true 这个可以解决部分repo中 @import 报错的问题； ","date":"2016-11-21","objectID":"/cocoapods_tips/:10:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"11、为CocoaPods开启增量编译模式： 开启增量编译模式后，post_install、pre_install 中的某些设置会报错，因为工程配置的层级结构发生了变化； install! 'cocoapods', :generate_multiple_pod_projects =\u003e true, :incremental_installation =\u003e true ","date":"2016-11-21","objectID":"/cocoapods_tips/:11:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"12、静态库和动态库共存的设置： # https://www.rubydoc.info/gems/cocoapods/Pod # https://github.com/facebook/flipper/issues/254 # https://github.com/facebook/flipper/blob/master/docs/getting-started.md $dynamic_framework = ['LayoutInspector', 'PromiseKit', 'Yoga', 'YogaKit'] pre_install do |installer| # installer.pod_targets.each do |pod| # if $dynamic_framework.include?(pod.name) # pod.instance_variable_set(:@host_requires_frameworks, true) # end # end Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if not $dynamic_framework.include?(pod.name) def pod.build_type; #Pod::Target::BuildType.static_library Pod::BuildType.static_library end end end end pre_install do |installer| $dynamic_framework = ['RxSwift'] Pod::Installer::Xcode::TargetValidator.send(:define_method,:verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if $dynamic_framework.include?(pod.name) def pod.build_type; Pod::BuildType.dynamic_framework end end end end ","date":"2016-11-21","objectID":"/cocoapods_tips/:12:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"13、使用Ruby快速设置头文件 https://github.com/mxcl/PromiseKit/blob/6.15.3/PromiseKit.podspec s.subspec 'CorePromise' do |ss| hh = Dir['Sources/*.h'] - Dir['Sources/*+Private.h'] cc = Dir['Sources/*.swift'] - ['Sources/SwiftPM.swift'] cc \u003c\u003c 'Sources/{after,AnyPromise,GlobalState,dispatch_promise,hang,join,PMKPromise,when,race}.m' cc += hh ss.source_files = cc ss.public_header_files = hh ss.preserve_paths = 'Sources/AnyPromise+Private.h', 'Sources/PMKCallVariadicBlock.m', 'Sources/NSMethodSignatureForBlock.m' end ","date":"2016-11-21","objectID":"/cocoapods_tips/:13:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"参考： podspec 语法指南 podfile 语法指南 开启 Cocoapods 新选项，加快项目索引速度 Flipper ","date":"2016-11-21","objectID":"/cocoapods_tips/:13:1","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods Tips","uri":"/cocoapods_tips/"},{"categories":["实现原理"],"content":"简析`ReactiveCocoa`中的几个函数","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"简析ReactiveCocoa中的几个函数 ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:0:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"flattenMap 与 map 推荐文章： RAC 核心元素与信号流 细说 ReactiveCocoa 的冷信号与热信号（三）：怎么处理冷信号与热信号 map 和 flatten 是基于 flattenMap, 而 flattenMap 是基于 bind:, 所以在此之前先来看看 bind 函数。 具体来看源码（为方便理解，去掉了源代码中 RACDisposable, @synchronized, @autoreleasepool 相关代码 )。当新信号 N 被外部订阅时，会进入信号 N 的 didSubscribeBlock (1)，之后订阅原信号 O (2)，当原信号 O 有值输出后就用 bind 函数传入的 bindBlock 将其变换成中间信号 M (3), 并马上对其进行订阅 (4)，最后将中间信号 M 的输出作为新信号 N 的输出 (5)。即：当新生成的信号被订阅时，源信号也会立即被订阅。 - (RACSignal *)bind:(RACStreamBindBlock (^)(void))block { return [RACSignal createSignal:^(id\u003cRACSubscriber\u003e subscriber) {// (1) RACStreamBindBlock bindingBlock = block(); // (MARK: 此处执行 block 回调, 生成一个 bindingBlock) [self subscribeNext:^(id x) {// (2) BOOL stop = NO; id middleSignal = bindingBlock(x, \u0026stop); // (3) map 与 flatten 结果不同，问题就出在这里 if (middleSignal != nil) { RACDisposable *disposable = [middleSignal subscribeNext:^(id x) {// (4) [subscriber sendNext:x]; // (5) } error:^(NSError *error) { [subscriber sendError:error]; } completed:^{ [subscriber sendCompleted]; }]; } } error:^(NSError *error) { [subscriber sendError:error]; } completed:^{ [subscriber sendCompleted]; }]; return nil }]; } flattenMap 其实就是对 bind: 方法进行了一些安全检查，它最终返回的是 bindBlock 执行后生成的那个中间 signal 又被订阅后传递出的值的信号，而 map 方法返回的是 bindBlock 的执行结果生成的那个信号，没有再加工处理（即被订阅，再发送值） - (instancetype)flattenMap:(RACStream * (^)(id value))block { Class class = self.class; return [[self bind:^{ /// @return 返回的是 RACStreamBindBlock /// @discussion /// /// 跟 `bind：` 方法中的代码对应起来如下： /// BOOL stop = NO; /// id middleSignal = bindingBlock(x, \u0026stop); /// /// 与上面 `bind:` 函数中的 (3) 对应起来, /// 可以看出 bindBlock 中的 x 是原信号被 subscribe 后传出的值，即对应下面的 value /// 也即 flattenMap block 中执行后传出的值， /// 即上面的 (RACStream * (^ block)(id value)) 中的 value /// flattenMap: 后的那个 block 其实与 bind: 后的 block 基本是一样的，参数都是原信号发出的值，返回值都是 RACStream，差别就是一个 bool 参数，所以说，flattenMap 其实就是对 bind 方法进行了一些安全检查 /// 综上所述：*flattenMap 方法中传进来的那个 block 参数值就是原信号被订阅后发送的值* return ^(id value, BOOL *stop) { // 下面这个 value 并不是 flattenMap 后面 block 中的那个 value（原信号被订阅后发出去的值），而是原信号发出的值被转换为中间信号后，又被订阅后发出去的值。 id stream = block(value) ?: [class empty]; NSCAssert([stream isKindOfClass:RACStream.class], @\"Value returned from -flattenMap: is not a stream: %@\", stream); return stream; }; }] setNameWithFormat:@\"[%@] -flattenMap:\", self.name]; } map: 下面是 map 方法的源码，可以看出，map 只是对 flattenMap 传出的 vaue（即原信号传出的值）进行了 mapBlock 操作，并没有再进行订阅操作，即并不像 bind： 一样再次对原信号进行 bindBlock 后生成的中间信号进行订阅。 - (instancetype)map:(id (^)(id value))block { NSCParameterAssert(block != nil); Class class = self.class; return [[self flattenMap:^(id value) { return [class return:block(value)]; }] setNameWithFormat:@\"[%@] -map:\", self.name]; } flatten: 该操作主要作用于信号的信号。原信号 O 作为信号的信号，在被订阅时输出的数据必然也是个信号 (signalValue)，这往往不是我们想要的。当我们执行 [O flatten] 操作时，因为 flatten 内部调用了 flattenMap (1)，flattenMap 里对应的中间信号就是原信号 O 输出的 signalValue (2)。按照之前分析的经验，在 flattenMap 操作中新信号 N 输出的结果就是各中间信号 M 输出的集合。因此在 flatten 操作中新信号 N 被订阅时输出的值就是原信号 O 的各个子信号输出值的集合。 - (instancetype)flatten { return [self flattenMap:^(RACSignal *signalValue) {// (1) /// 返回值作为 bind: 中的中间信号 return signalValue; // (2) }; } 小结： flatten 与 map 之间的区别：flatten 和 map 后面的 block 返回结果其实最终都会变为 bind: 方法中的中间信号，但是 flatten: 的 block 是直接把原信号发出的值返回来作为中间信号的，所以中间信号被订阅，其实就是原信号发出的值又被订阅，这也就是 flatten: 能拿到信号中的信号中的值的原因。 而 map: 后面的 block 是把原信号发出的值加工处理了的，又生成了一个新的信号，即 map: 方法 block 返回的中间信号已经不是原来的信号中的信号了，而是把原信号发出的值作为它的包含值的一个新的信号，它被订阅时，发送的是原信号发出的那个值，这就是 map 拿不到原信号中的信号的原因。 说白了就是 flatten: 操作的始终是原来的信号，而 map: 会生成一个包含原信号发送值的新信号。 ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:1:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"multicast - (RACMulticastConnection *)multicast:(RACSubject *)subject; 当 RACSignal 类的实例调用 - (RACMulticastConnection *)multicast:(RACSubject *)subject 时，以 self 和 subject 作为构造参数创建一个 RACMulticastConnection 实例。 RACMulticastConnection 构造的时候，保存 source 和 subject 作为成员变量，创建一个 RACSerialDisposable 对象，用于取消订阅。 当 RACMulticastConnection 类的实例调用 - (RACDisposable *)connect 这个方法的时候，判断是否是第一次。如果是的话 用 _signal 这个成员变量（RACSubject 类型）来订阅 sourceSignal， 之后返回 self.serialDisposable，否则直接返回 self.serialDisposable 。 RACMulticastConnection 的 signal 只读属性，就是一个热信号，订阅这个热信号就避免了各种副作用的问题。它会在 - (RACDisposable *)connect 第一次调用后，根据 sourceSignal 的订阅结果来传递事件。 想要确保第一次订阅就能成功订阅 sourceSignal ，可以使用 - (RACSignal *)autoconnect 这个方法，它保证了第一个订阅者触发 sourceSignal 的订阅，也保证了当返回的信号所有订阅者都关闭连接后 sourceSignal 被正确关闭连接。 这里面订阅 sourceSignal 是重点，_signal 是一个 RACSubject 类型，它里面维护着一个可变数组，每当它被订阅时，会把所有的订阅者保存到这个数组中。当 connection.signal（即 _signal）被订阅时，其实是 _signal 被订阅了。由于 _signal 是 RACSubject 类型对象，且 _signal 也是信号，它里面重写了订阅方法，所以会执行它自己的 subscribe: 方法，执行此方法之前订阅者参数是 RACSubscriber 类型，但是在这个 subscribe 方法中，初始化了一个 RACPassthroughSubscriber 实例对象，使它作为新的订阅者（其实就是对订阅者进行了一层包装），并把它存入了 subject 维护的那个订阅者数组里（原来的 订阅者 和 信号 被 RACPassthroughSubscriber 实例保存了），所以数组中最终保存的是 RACPassthroughSubscriber 类型的订阅者，然后它发送消息的时候调的还是它持有的 subject 对象进行发送消息。 当 RACMulticastConnection 调用 connect 方法时，源信号 sourceSignal 被 _signal 订阅，即执行 [sourceSignal subscribe:subject] 方法，然后执行订阅 subscribeNext:block 回调，在回调中执行 sendNext:，由于订阅者是 RACSubject 类型的实例对象，它里面也会执行 sendNext: 方法，此方法中会遍历它的数组中的订阅者依次发送消息。 connect 时订阅者是 RACSubject 发送的 sendNext:，subject 会拿到它那个订阅者数组遍历，取出其中的 RACPassthroughSubscriber 对象，然后用 RACPassthroughSubscriber 对象中的真实的订阅者去发送数据。 ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:2:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"RACCommand 直接上源码: - (id)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal * (^)(id input))signalBlock { NSCParameterAssert(signalBlock != nil); self = [super init]; if (self == nil) return nil; _activeExecutionSignals = [[NSMutableArray alloc] init]; _signalBlock = [signalBlock copy]; // 监听 `activeExecutionSignals` 数组 RACSignal *newActiveExecutionSignals = [[[[[self rac_valuesAndChangesForKeyPath:@keypath(self.activeExecutionSignals) options:NSKeyValueObservingOptionNew observer:nil] reduceEach:^(id _, NSDictionary *change) { NSArray *signals = change[NSKeyValueChangeNewKey]; if (signals == nil) { return [RACSignal empty]; } // 把数组转换为信号发送出去 return [signals.rac_sequence signalWithScheduler:RACScheduler.immediateScheduler]; }] concat] // 把各个信号中的信号连接起来 publish] // 广播出去，可以被多个订阅者订阅 autoconnect]; // 有订阅了再发送广播 // 把上面的信号 `map` 一下, 当出现错误的时候转换成 `empty` 空信号, 并在主线程上传递 _executionSignals = [[[newActiveExecutionSignals map:^(RACSignal *signal) { return [signal catchTo:[RACSignal empty]]; }] deliverOn:RACScheduler.mainThreadScheduler] setNameWithFormat:@\"%@ -executionSignals\", self]; // 先通过 `ignoreValues` 方法屏蔽掉 `sendNext:` 的结果，只保留 `sendError:` 和 `sendCompleted` 结果，然后再通过 `catch:` 方法拿到所有的 `sendError:` 结果，发送给订阅者。 // 此处用的是 `flattenMap`，可以直接获取到错误信息。 RACMulticastConnection *errorsConnection = [[[newActiveExecutionSignals flattenMap:^(RACSignal *signal) { return [[signal ignoreValues] catch:^(NSError *error) { return [RACSignal return:error]; }]; }] deliverOn:RACScheduler.mainThreadScheduler] publish]; _errors = [errorsConnection.signal setNameWithFormat:@\"%@ -errors\", self]; [errorsConnection connect]; // 根据执行信号的数量判断 `RACCommand` 当前是否正在执行 RACSignal *immediateExecuting = [RACObserve(self, activeExecutionSignals) map:^(NSArray *activeSignals) { return @(activeSignals.count \u003e 0); }]; // 是否正在执行 _executing = [[[[[immediateExecuting deliverOn:RACScheduler.mainThreadScheduler] // This is useful before the first value arrives on the main thread. startWith:@NO] distinctUntilChanged] replayLast] setNameWithFormat:@\"%@ -executing\", self]; // 如果允许并发执行，返回 `YES`，否则反转 `immediateExecuting` 信号的结果 RACSignal *moreExecutionsAllowed = [RACSignal if:RACObserve(self, allowsConcurrentExecution) then:[RACSignal return:@YES] else:[immediateExecuting not]]; if (enabledSignal == nil) { enabledSignal = [RACSignal return:@YES]; } else { enabledSignal = [[[enabledSignal startWith:@YES] takeUntil:self.rac_willDeallocSignal] replayLast]; } _immediateEnabled = [[RACSignal combineLatest:@[enabledSignal, moreExecutionsAllowed]] and]; _enabled = [[[[[self.immediateEnabled take:1] concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]] distinctUntilChanged] replayLast] setNameWithFormat:@\"%@ -enabled\", self]; return self; } // 使用时，我们通常会去生成一个 RACCommand 对象，并传入一个返回 signal 对象的 block。每次 RACCommand execute 执行操作时，都会通过传入的这个 signal block 生成一个执行信号 E (1)，并将该信号添加到 RACCommand 内部信号数组 activeExecutionSignals 中 (2)，同时将信号 E 由冷信号转成热信号 (3)，最后订阅该热信号 (4)，并将其返回 (5)。 - (RACSignal *)execute:(id)input { RACSignal *signal = self.signalBlock(input); //（1） RACMulticastConnection *connection = [[signal subscribeOn:RACScheduler.mainThreadScheduler] multicast:[RACReplaySubject subject]]; // (3) @weakify(self); [self addActiveExecutionSignal:connection.signal]; // (2) [connection.signal subscribeError:^(NSError *error) { @strongify(self); [self removeActiveExecutionSignal:connection.signal]; } completed:^{ @strongify(self); [self removeActiveExecutionSignal:connection.signal]; }]; [connection connect]; // (4) return [connection.signal]; // (5) } 接下来再来简单说说 RACCommand 中用到的几个函数 // 以下是对 `allowsConcurrentExecution` 属性的处理方法，利用了属性的原子性，防止资源竞争，值得学习 @property (atomic, assign) BOOL allowsConcurrentExecution; @property (atomic, copy, readonly) NSArray *activeExecutionSignals; { // The mutable array backing `activeExecutionSignals`. // // This should only be used while synchronized on `self`. NSMutableArray *_activeExecutionSignals; // Atomic backing variable for `allowsConcurrentExecut","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:3:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"推荐 FRPCheatSheeta ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:4:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"}]