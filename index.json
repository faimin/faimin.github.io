[{"categories":["工具"],"content":"工欲善其事，必先利其器","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"简介 个人平时收藏的一些Mac平台开源免费的工具，基本都支持homebrew安装。 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:1:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"搜索引擎 devv Qwant Yandex phind grep.app startpage SearX ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:2:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"软件 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"包管理 Homebrew：Mac端的包管理工具，PC端的有Scoop、Chocolate、Winget ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:1","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"终端 iTerm2 Alacritty WezTerm kitty WindTerm Tabby ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:2","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"nvim Neovim - GUI vimr - GUI NvChad LazyVim ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:3","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"效率 PopClip Alfred alfred-workflows Hammerspoon -------------- 输入法控制 ----------------- local function Chinese() -- 搜狗输入法 hs.keycodes.currentSourceID(\"com.sogou.inputmethod.sogou.pinyin\") -- 简体拼音 --hs.keycodes.currentSourceID(\"com.apple.inputmethod.SCIM.ITABC\") end local function English() -- ABC hs.keycodes.currentSourceID(\"com.apple.keylayout.ABC\") end -- app to expected ime config -- app和对应的输入法 local app2Ime = { { '/Applications/System Preferences.app', 'English' }, { '/System/Library/CoreServices/Finder.app', 'Chinese' }, { '/Applications/iTerm.app', 'Chinese' }, { '/Applications/Visual Studio Code.app', 'Chinese' }, { '/Applications/Xcode.app', 'Chinese' }, { '/Applications/Microsoft Edge.app', 'Chinese' }, { '/Applications/Kim.app', 'Chinese' }, { '/Applications/WeChat.app', 'Chinese' }, { '/Applications/QQ.app', 'Chinese' }, { '/Applications/MarkText.app', 'Chinese' }, { '/Applications/Bob.app', 'Chinese' }, { '/Applications/NeteaseMusic.app', 'Chinese' }, } function updateFocusAppInputMethod() local ime = 'Chinese' local focusAppPath = hs.window.frontmostWindow():application():path() for index, app in pairs(app2Ime) do local appPath = app[1] local expectedIme = app[2] if focusAppPath == appPath then ime = expectedIme break end end if ime == 'English' then English() else Chinese() end end -- helper hotkey to figure out the app path and name of current focused window -- 当选中某窗口按下ctrl+command+.时会显示应用的路径等信息 hs.hotkey.bind({ 'ctrl', 'cmd' }, \".\", function() hs.alert.show(\"App path: \" .. hs.window.focusedWindow():application():path() .. \"\\n\" .. \"App name: \" .. hs.window.focusedWindow():application():name() .. \"\\n\" .. \"IM source id: \" .. hs.keycodes.currentSourceID()) end) -- Handle cursor focus and application's screen manage. -- 窗口激活时自动切换输入法 function applicationWatcher(appName, eventType, appObject) if (eventType == hs.application.watcher.activated or eventType == hs.application.watcher.launched) then updateFocusAppInputMethod() end end appWatcher = hs.application.watcher.new(applicationWatcher) appWatcher:start() SwiftBar xbar DevToys OnlySwitch ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:4","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"系统优化 Lemon Cleaner AppCleaner ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:5","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"系统监控 Stats eul MenuMeters ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:6","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"下载 Motrix Free Download Manager gopeed you-get - 网站视频下载命令工具，如需视频合并需额外安装ffmpeg ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:7","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Office LibreOffice ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:8","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"流程图 Draw.io asciiflow tlddraw ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:9","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Markdown MarkText typst ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:10","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"阅读 WeRead - 利用Rust Tauri打包的 APP Legado - Android 报纸/期刊 十万个为什么 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:11","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"PDF Skim Edge Firefox Chrome ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:12","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"播放器 收费的可以试试Movist Pro、Infuse Pro IINA MPC-BE MusicFree - Flutter Music 站点 网易云音乐 MAC 云盘上传工具 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:13","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"截图 Snipaste shottr flameshot eSearch Xnip iShot ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:14","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"窗口管理 Rectangle yabai ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:15","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"文件压缩 The Unarchiver Keka PeaZip ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:16","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"屏幕保护 Brooklyn ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:17","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"防火墙 Lulu ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:18","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"翻译 Bob EasyDict 沉浸式双语网页翻译扩展 kiss-translator TTime pot-desktop tran ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:19","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"状态栏 HiddenBar - 折叠图标 Dozer ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:20","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"TouchBar Pock MTMR ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:21","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Quick Look glance - All-in-one Quick Look plugin SouceCodeSyntaxHighlight QLMarkdown Mac-QuickLook ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:22","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"邮件 Spark ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:23","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"键盘 KeyCastr - 显示当前按键 Tickys - 模拟机械键盘的声音 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:24","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"输入法切换 KeyboardHolder 搜狗输入法切换助手 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:25","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"屏幕录制 LICEcap Kap GIFCapture ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:26","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"直播 obs-studio ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:27","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"视频编辑 shotcut lossless-cut ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:28","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"格式转码 handbrake ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:29","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"NTFS NTFSTool mounty ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:30","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Hosts iHosts SwitchHosts ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:31","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"RSS NetNewsWire Lettura mdSilo-app ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:32","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"文件传输 localsend FlyingCarpet ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:33","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"U 盘系统制作 Rufus Ventoy etcher ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:34","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"数据恢复 KeychainCracker ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:35","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"代理 ClashX Tunnelblick - OpenVPN whistle ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:36","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"收费软件推荐 可以到这里找 特(破)别(解) 版 Xee - 图片浏览 Picture View - 图片浏览 Kaleidoscope - 文件diff ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:3:37","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"开发 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"版本管理 Python pyenv pixi WebEnv/Node volta fnm nvm Ruby rbenv rvm Java sdkman jenv Flutter fvm Swift swiftly ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:1","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"调试 LLVM Lookin LLDB - lldb插件 Chisel - lldb插件 injectionIII - hotreload OpenSim - 读取模拟器沙盒 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:2","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Mach-O MachOView MachOView MachO-Explorer XMachOViewer MachOExplorer MachO-Kit LinkMap bloaty - 对比文件体积变化 ipsw dSYMTools go-macho ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:3","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"逆向 比较有名的可能是IDA和Hopper Disassembler Ghidra Frida Cutter Hashcat ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:4","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Hex HexFriend ImHex hexyl ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:5","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"命令行 fig inshellisense starship - prompt nushell atuin - shell history fd - file search ripgrep - grep dust - du lsd - ls eza - ls bat - cat ugit - 撤销git操作 thefuck ipatool - 下载IPA文件 HTTPie - 查看网络 zsh-autocomplete zsh-autosuggestions zsh-syntax-highlighting git-cliff - changelog erdtree - file-tree tokei - 统计代码行数 onefetch - Git information zoxide - jump ios-deploy joshuto - file manager yazi - file manager ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:6","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"快捷打开终端 OpenInTerminal FinderGo Go2Shell Alfred 插件 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:7","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"图片压缩 ImageSmith - 推荐，刚发布时白嫖到的 😏 Imagenie Crunch TinyPNG4Mac ImageOptim Pngyu rimage oxipng ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:8","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"检测无用资源和代码 无用资源 LSUnusedResources 无用代码 periphery WBBlades Pecker Stencil Sitrep czkawka ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:9","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"推送 PushDeer Knuff Pusher Easy APNs Provider PushNotifications ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:10","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Git Fork GitUI LazyGit 开源的还有Xit、GitUp，收费的有Tower、Sublime Merge、GitKraken ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:11","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"数据库 SQLiteBrowser DBeaver ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:12","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"WWDC WWDC ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:13","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Docker OrbStack ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:14","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"分辨率调整 RDM ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:15","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Web 打包成 MacAPP Pake ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:16","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"网络 thunder-client hoppscotch - Postwomen RapidAPI / Paw HTTPToolKit-Desktop cocoa-reset-client Stream Knot ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:17","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"爬虫 EasySpider ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:18","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Xcode Plugin Json2Property quicktype-xcode CleverToolKit XCFormat EditKit Pro ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:19","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Xcode 版本管理 xcodes xcinfo xcode-install ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:20","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Xcode 缓存清理 DevCleaner ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:21","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"VSCode 插件 Shades of Purple - 主题 Dracula - 主题 Code Runner CodeLLDB clangd Error Lens GitLess Git Blame GitLens Git Graph Path Intellisense Thunder Client CodeSnap Comment Tranlate Markdown Editor Image Preview Paste JSON as Code Project Manager Bookmarks Todo Tree shellman Hex Editor Doxygen Documentation Generator Better Comments whatchanged - changelog Swift 如果没有代码联想，可能是因为sourcekit-lsp与本机Swift不在同一目录下。在/usr/local/bin下建立一个sourcekit-lsp的软链接可以解决：ls -s $(xcrun --find sourcekit-lsp) /usr/local/bin/sourcekit-lsp。 如果断点调试无法显示变量，检查下是否安装了llvm，如果是那可能默认用的是llvm的lldb。把CodeLLDB的lldb指定为Xcode的lldb，或者在.zshrc中用Xcode版本覆盖llvm版本： export PATH=\"/Applications/Xcode.app/Contents/Developer/usr/bin:$PATH\" ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:22","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Windows VC 环境 VCRedist ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:23","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"Windows 激活 HEU_KMS_Activator ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:4:24","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"常见问题 VSCode 函数参数没有代码提示 关闭阻止选项 snippets_prevent_suggestions 找回IDEA的copy reference lose copy reference ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:5:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"软件站 AppStorrent 麦氪搜 open-source-mac-os-apps Xclient MacBL AlternativeTo NSANE FORUMS TorrentMac UUP dump MacYY(网站已转卖) MacWk(已关站) ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:6:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"参考 HellGithub 老胡的周刊 ","date":"2022-08-29","objectID":"/%E5%B7%A5%E5%85%B7/:7:0","tags":["工具"],"title":"工具","uri":"/%E5%B7%A5%E5%85%B7/"},{"categories":["实现原理"],"content":"记录Swift语言中的一些疑惑","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"Swift分析利器 swiftc xxx.swift -emit-sil[gen] | xcrun swift-demangle \u003e xxxxSILGen.sil ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:1:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"备忘录 全局的常量或者变量都是延迟计算的，跟延迟加载存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量和变量不延迟计算； 枚举类型不支持存储属性，想存储数据可以使用枚举关联的方式； 为类定义计算型类型属性时，可以改用关键字class来支持子类对父类的实现进行重写； 如果一个被标记为lazy的属性在没有初始化时就被多个线程访问，则无法保证该属性只会被初始化一次，也就是说lazy不是线程安全的； 我们可以为除了延迟计算属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器；不需要为非重写的计算属性添加属性观察器，因为可以通过它的setter直接监控和响应值的变化；如果在一个属性的didSet观察器里为它赋值，这个值会替换该观察器之前设置的值； 父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。 存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化，即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用lazy修饰符。 如果将属性通过in-out方式传入函数，willSet 和 didSet 也会调用，这是因为 in-out参数采用了拷入拷出模式：即在函数内部使用的是参数的copy，函数结束后，又对参数重新赋值； ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:2:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"值类型线程安全？ 不要人云亦云，这个说法是有问题的，思考一下：假如我们有个变量 var i = 1，多线程修改时不需要加锁？ 在未优化状态下值类型其实默认是在堆上分配的，只是在SIL优化阶段，编译器会根据上下文把大部分值类型改为在栈上分配，在栈上分配的情况是才是线程安全的，因为每个线程都有自己的栈空间，不需要考虑线程安全问题。但是对于被捕获的这种情况是没办法优化的，你想想如果放到栈上在出作用域后不就被释放了嘛，所以这种情况不会优化到栈上，而是继续留在堆上，也就是说这种场景下多线程操作值类型是不安全的，需要加锁来防止数据竞争。 那值类型的安全性体现在哪里呢？ 显式捕获：这种情况会发生值类型的拷贝操作，即生成一份新的变量，所以是安全的 函数传参时值类型会发生拷贝，所以是安全的 let 标记的变量是不允许修改的，所以这种也是安全的 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:3:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"闭包（closure） closure-define 闭包和函数都是引用类型 函数也是特殊的闭包 Objective-C中的block默认会捕获外界变量，我们要想修改捕获的值需要添加__block。 可是在Swift中不太一样，Swift中的闭包是捕获和存储其所在上下文中任意常量和变量的引用 引用 引用，注意是引用，如果想要捕获值类型变量的值，需要在闭包中显式引用。 我们来简单分析下，Swift捕获外界上下文变量时会在堆上开辟一块内存project_box （仔细想想，如果是在栈上，出作用域就会释放掉，还怎么实现捕获的目的？！），然后上下文变量会被包装成project_box(先被HeapObject包装一下，HeapObject再被Box包装一下，最后捕获的是Box，即捕获的上下文存储在堆空间)，这个project_box会被放到闭包的参数列表后面传递进来。变量属于是被间接捕获的，有点类似于OC中的__block原理。当然，并不是所有的外界变量捕获都是经过包装过的，只有在闭包内发生修改的变量才会被包装，官方文档中有提到。 注意： 为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。 struct HeapObject { var Kind: UInt64 var refcount: UInt64 } // 负责包装的结构体,也就是用来包装捕获需要更新的值 struct Box { var refCounted: HeapObject // 这个捕获的值的类型根据捕获的值进行分配，此处规范操作是写泛型 // var value: Int var value: \u003cT\u003e } 而显式捕获，比如捕获全局变量的场景，经过编译后可以发现，其实是把被捕获的变量作为闭包函数的参数放到了原有闭包函数的后面，而值类型的函数参数在传参过程中会发生拷贝操作。 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:4:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"Lazy 这里的lazy指的是高阶函数前面的lazy，而非属性声明中的lazy。 使用lazy后再执行高阶函数，返回的其实是一个lazy对象，比如对一个数组进行XX操作，返回的是 LazyXXSequence 类型，这个类型中会保存原函数的操作行为和原始数据，只有在对这个lazy类型进行操作时才会真正进行函数操作。 swift_lazy ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:5:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"Weak机制 Swift中weak与Objective-C中的weak实现机制不太一样，Objective-C中是不允许在一个对象释放过程中再被弱引用的，而Swift却没有这个限制。 Swift中的弱引用并没有和Objective-C一样放在全局的side table表中（Swift也不存在这个全局side table），而是由自身结构中的 InlineRefCounts refCounts来管理，这样效能会比Objective-C那种查表的方式高一些。 Swift对象基本结构如下： // The members of the HeapObject header that are not shared by a // standard Objective-C instance #define SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS \\ InlineRefCounts refCounts /// The Swift heap-object header. /// This must match RefCountedStructTy in IRGen. struct HeapObject { /// This is always a valid pointer to a metadata object. HeapMetadata const *__ptrauth_objc_isa_pointer metadata; SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS; #ifndef __swift__ HeapObject() = default; // Initialize a HeapObject header as appropriate for a newly-allocated object. constexpr HeapObject(HeapMetadata const *newMetadata) : metadata(newMetadata) , refCounts(InlineRefCounts::Initialized) { } // Initialize a HeapObject header for an immortal object constexpr HeapObject(HeapMetadata const *newMetadata, InlineRefCounts::Immortal_t immortal) : metadata(newMetadata) , refCounts(InlineRefCounts::Immortal) { } #ifndef NDEBUG void dump() const SWIFT_USED; #endif #endif // __swift__ }; Swift 引用计数的存储结构在RefCount 头文件 有介绍： //Objects initially start with no side table. They can gain a side table when: //* a weak reference is formed and pending future implementation: //* strong RC or unowned RC overflows (inline RCs will be small on 32-bit) //* associated object storage is needed on an object //* etc //Gaining a side table entry is a one-way operation; an object with a side //table entry never loses it. This prevents some thread races. //Strong and unowned variables point at the object. //Weak variables point at the object's side table. //Storage layout: HeapObject { isa InlineRefCounts { atomic\u003cInlineRefCountBits\u003e { strong RC + unowned RC + flags OR HeapObjectSideTableEntry* } } } HeapObjectSideTableEntry { SideTableRefCounts { object pointer atomic\u003cSideTableRefCountBits\u003e { strong RC + unowned RC + weak RC + flags } } } 一般情况下Swift引用类型的对象结构中的InlineRefCounts并不会开辟HeapObjectSideTableEntry内存，只有在创建weak引用时，会先把对象的引用计数放到新创建的HeapObjectSideTableEntry中去，再把空出来的空间存放 HeapObjectSideTableEntry 的地址，而 runtime 会通过一个标志位来区分对象是否有 HeapObjectSideTableEntry。 对象的生命周期在 RefCount 头文件 中也有详细的说明： Object lifecycle state machine: LIVE without side table The object is alive. Object's refcounts are initialized as 1 strong, 1 unowned, 1 weak. No side table. No weak RC storage. Strong variable operations work normally. Unowned variable operations work normally. Weak variable load can't happen. Weak variable store adds the side table, becoming LIVE with side table. When the strong RC reaches zero deinit() is called and the object becomes DEINITING. LIVE with side table Weak variable operations work normally. Everything else is the same as LIVE. DEINITING without side table deinit() is in progress on the object. Strong variable operations have no effect. Unowned variable load halts in swift_abortRetainUnowned(). Unowned variable store works normally. Weak variable load can't happen. Weak variable store stores nil. When deinit() completes, the generated code calls swift_deallocObject. swift_deallocObject calls canBeFreedNow() checking for the fast path of no weak or unowned references. If canBeFreedNow() the object is freed and it becomes DEAD. Otherwise, it decrements the unowned RC and the object becomes DEINITED. DEINITING with side table Weak variable load returns nil. Weak variable store stores nil. canBeFreedNow() is always false, so it never transitions directly to DEAD. Everything else is the same as DEINITING. DEINITED without side table deinit() has completed but there are unowned references outstanding. Strong variable operations can't happen. Unowned variable store can't happen. Unowned variable load halts in swift_abortRetainUnowned(). Weak variable operations can't happen. When the unowned RC reaches zero, the object is freed and it becomes DEAD. DEINITED with si","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:6:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"struct 嵌套类型会影响父级结构的内存占用吗？ 不会。最简单的验证方法就是通过MemoryLayout\u003cType\u003e.size打印一下父级结构所占内存大小就清楚了。也就是说嵌套只是起到了命名空间的作用，并不会影响其他东西 Array存Any类型的元素是怎么内存对齐的？ 元素会被包装成existential类型，初步猜测应该和数组中存放遵守相同协议的元素的处理方式类似。 下面截取函数原型为arr.append(1); arr.append((100, 200)); arr.append(XX());的部分SIL代码，注意里面的init_existential_addr字眼： store %6 to %3 : $*Array\u003cAny\u003e // id: %7 %8 = alloc_stack $Any // users: %17, %15, %11 %9 = integer_literal $Builtin.Int64, 1 // user: %10 %10 = struct $Int (%9 : $Builtin.Int64) // user: %12 %11 = init_existential_addr %8 : $*Any, $Int // user: %12 store %10 to %11 : $*Int // id: %12 %13 = begin_access [modify] [dynamic] %3 : $*Array\u003cAny\u003e // users: %16, %15 // function_ref Array.append(_:) %14 = function_ref @Swift.Array.append(__owned A) -\u003e () : $@convention(method) \u003cτ_0_0\u003e (@in τ_0_0, @inout Array\u003cτ_0_0\u003e) -\u003e () // user: %15 %15 = apply %14\u003cAny\u003e(%8, %13) : $@convention(method) \u003cτ_0_0\u003e (@in τ_0_0, @inout Array\u003cτ_0_0\u003e) -\u003e () end_access %13 : $*Array\u003cAny\u003e // id: %16 dealloc_stack %8 : $*Any // id: %17 %18 = alloc_stack $Any // users: %32, %30, %19 %19 = init_existential_addr %18 : $*Any, $(Int, Int) // users: %21, %20 %20 = tuple_element_addr %19 : $*(Int, Int), 0 // user: %24 %21 = tuple_element_addr %19 : $*(Int, Int), 1 // user: %27 %22 = integer_literal $Builtin.Int64, 100 // user: %23 %23 = struct $Int (%22 : $Builtin.Int64) // user: %24 store %23 to %20 : $*Int // id: %24 %25 = integer_literal $Builtin.Int64, 200 // user: %26 %26 = struct $Int (%25 : $Builtin.Int64) // user: %27 store %26 to %21 : $*Int // id: %27 %28 = begin_access [modify] [dynamic] %3 : $*Array\u003cAny\u003e // users: %31, %30 // function_ref Array.append(_:) %29 = function_ref @Swift.Array.append(__owned A) -\u003e () : $@convention(method) \u003cτ_0_0\u003e (@in τ_0_0, @inout Array\u003cτ_0_0\u003e) -\u003e () // user: %30 %30 = apply %29\u003cAny\u003e(%18, %28) : $@convention(method) \u003cτ_0_0\u003e (@in τ_0_0, @inout Array\u003cτ_0_0\u003e) -\u003e () end_access %28 : $*Array\u003cAny\u003e // id: %31 dealloc_stack %18 : $*Any // id: %32 %33 = alloc_stack $Any // users: %43, %41, %37 %34 = metatype $@thick XX.Type // user: %36 // function_ref XX.__allocating_init() %35 = function_ref @A.XX.__allocating_init() -\u003e A.XX : $@convention(method) (@thick XX.Type) -\u003e @owned XX // user: %36 %36 = apply %35(%34) : $@convention(method) (@thick XX.Type) -\u003e @owned XX // user: %38 %37 = init_existential_addr %33 : $*Any, $XX // user: %38 store %36 to %37 : $*XX // id: %38 %39 = begin_access [modify] [dynamic] %3 : $*Array\u003cAny\u003e // users: %42, %41 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:7:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"枚举 ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:8:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"内存占用 普通的枚举（非关联类型）自身只占用1个字节，与case数量无关； 带关联值的枚举，其所占内存大小为所有case中关联类型占用内存最大的那个(类似union)，再加枚举自身的大小； 特殊场景：只有一个case的枚举，枚举本身所占用的内存大小是0个字节，如果带关联值，那枚举所占内存大小只包含关联值所占内存的大小，不包含枚举自身的大小； 对于有关联值的case，它的case值会根据定义的顺序默认从0开始累加1；而其余所有不带关联值的case，它们的case地址相同，都等于最后一个带关联成员case的值+1（也就是说不带关联值的case在带关联值的case后面）； 关联值是直接存储在枚举变量内存里面的，而原始值不是，它是通过xx.rawValue（计算属性）访问的，因此它的原始值完全不需要存储（枚举也不支持存储属性），而是在计算属性函数的返回值中，即函数中。rawValue这个计算属性是编译器帮我们默认添加的，它的返回值默认是我们设置的原始值，假如我们自己实现了这个计算属性，编译器就不会帮我们默认添加了，而是使用我们自己的实现； 嵌套枚举：被indirect标记的对象会被BoxPair包装成引用类型（放到堆上），和Rust一样的处理方式（Rust中是被包装成Box类型）； ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:8:1","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"派发方式 静态派发 函数表派发 消息派发 添加 @objc 标识，编译器会生成两份函数实现，一份是消息派发的函数供OC调用，另一份是函数表派发或静态派发的函数实现；消息派发那个函数内部会调用另一份实现，我觉得可以简单理解为@objc只是编译器帮我们暴漏了一个OC接口而已； 多使用final关键字，一个类标记为final后，默认的函数表派发会变成静态派发，但是它不会影响@objc这个接口的生成；函数用final标记后也会变成静态派发； 在extension中的方法是静态派发； protocol中声明的方法属于函数表派发，即使在extension中添加了默认实现，当我们在调用某个对象的这个协议方法时采用的也是函数表派发；但是我们调用protocol的extension中的某个未作为协议声明的方法时，采用的是静态派发的策略； private函数并未改变函数的派发方式（iOS摸鱼周报#73 中说private会隐式final声明，但我测试发现它并不会改变函数的派发方式，感兴趣的同学可以自己验证一下）； ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:9:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"any VS some // 1.泛型 func tFoo\u003cT: Equatable\u003e() -\u003e T { return 42 as! T } // 2.some func someFoo() -\u003e some Equatable { return 42 } // 3.any func anyFoo() -\u003e any Equatable { return 42 } some是Swift 5.1新加的。any是Swift 5.6引入的，用来修饰existential type，在Swift5.7中这个修饰行为变为了强制； some其实只是对泛型协议参数的一种等价简化（如上的1和2是等价的），也就是说some在编译期就可以确定出类型，在方法调用上可以做到函数表派发、静态派发； any则是类似盒子的类型，它包装了遵循特定协议的类型。这个box盒子允许我们去存储任何具体类型，只要该类型遵循了特定协议即可。 性能：由于编译器无法在编译期确定盒子内对象的具体类型以及内存分配方式，导致在运行时不得不采用动态派发的方式将消息派发到具体的对象上，这肯定比静态派发方式要慢很多。 由于existential type使用上太简单、太方便，很容易会出现滥用的情况，为了提醒开发人员性能损失这一点，所以在Swift 5.7中苹果强制要求对existential type使用any来标记。 我们不能使用==操作来比较两个existential type实例对象。 some_vs_any 最后，根据下面的例子体会一下： // ✅ No compile error when changing the underlying data type var myCar: any Vehicle = Car() myCar = Bus() myCar = Car() ​ // 🔴 Compile error in Swift 5.7: Use of protocol 'Vehicle' as a type must be written 'any Vehicle' func wash(_ vehicle: Vehicle) { // Wash the given vehicle } ​ // ✅ No compile error in Swift 5.7 func wash(_ vehicle: any Vehicle) { // Wash the given vehicle } // 🔴 Compile error in Swift 5.7: Use of protocol 'Vehicle' as a type must be written 'any Vehicle' // 一个函数不能返回多种类型结果，而`some`在编译期就可以确定类型，所以编译失败 func createVehicle(isPublicTransport: Bool) -\u003e some Vehicle { if isPublicTransport { return Bus() } else { return Car() } } ​ // ✅ No compile error when returning different kind of concrete type func createAnyVehicle(isPublicTransport: Bool) -\u003e any Vehicle { if isPublicTransport { return Bus() } else { return Car() } } ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:10:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"@objc方法的派发方式 不考虑@dynamic关键字标记的场景（被@dynamic和@objc标记后会变为消息派发） Swift方法被@objc标记后，编译器会生成2份接口：一份是Swift接口，供Swift内部调用；另一份是OC接口，用于给OC层调用。其中Swift的函数调用采用的是函数表派发（函数在sil_vtable中），而OC接口内部其实最终调用的还是Swift函数，也就是说派发方式并没有发生变化，还是函数表派发。 创建一个Foo类，并实现一个@objc标记的bar方法： import Foundation class Foo: NSObject { @objc func bar() { print(\"Hello from Swift!\") } } 通过 swiftc Foo.swift -emit-sil | xcrun swift-demangle \u003e FooSILGen.sil转换为SIL代码如下： 有精简，只保留了bar函数和vtable相关部分 sil_stage canonical import Builtin import Swift import SwiftShims import Foundation @objc @_inheritsConvenienceInitializers class Foo : NSObject { @objc func bar() override dynamic init() @objc deinit } // Foo.bar() sil hidden @Foo.Foo.bar() -\u003e () : $@convention(method) (@guaranteed Foo) -\u003e () { // %0 \"self\" // user: %1 bb0(%0 : $Foo): debug_value %0 : $Foo, let, name \"self\", argno 1, implicit // id: %1 %2 = integer_literal $Builtin.Word, 1 // user: %4 // function_ref _allocateUninitializedArray\u003cA\u003e(_:) %3 = function_ref @Swift._allocateUninitializedArray\u003cA\u003e(Builtin.Word) -\u003e ([A], Builtin.RawPointer) : $@convention(thin) \u003cτ_0_0\u003e (Builtin.Word) -\u003e (@owned Array\u003cτ_0_0\u003e, Builtin.RawPointer) // user: %4 %4 = apply %3\u003cAny\u003e(%2) : $@convention(thin) \u003cτ_0_0\u003e (Builtin.Word) -\u003e (@owned Array\u003cτ_0_0\u003e, Builtin.RawPointer) // users: %6, %5 %5 = tuple_extract %4 : $(Array\u003cAny\u003e, Builtin.RawPointer), 0 // user: %17 %6 = tuple_extract %4 : $(Array\u003cAny\u003e, Builtin.RawPointer), 1 // user: %7 %7 = pointer_to_address %6 : $Builtin.RawPointer to [strict] $*Any // user: %14 %8 = string_literal utf8 \"Hello from Swift!\" // user: %13 %9 = integer_literal $Builtin.Word, 17 // user: %13 %10 = integer_literal $Builtin.Int1, -1 // user: %13 %11 = metatype $@thin String.Type // user: %13 // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) %12 = function_ref @Swift.String.init(_builtinStringLiteral: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) -\u003e Swift.String : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -\u003e @owned String // user: %13 %13 = apply %12(%8, %9, %10, %11) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -\u003e @owned String // user: %15 %14 = init_existential_addr %7 : $*Any, $String // user: %15 store %13 to %14 : $*String // id: %15 // function_ref _finalizeUninitializedArray\u003cA\u003e(_:) %16 = function_ref @Swift._finalizeUninitializedArray\u003cA\u003e(__owned [A]) -\u003e [A] : $@convention(thin) \u003cτ_0_0\u003e (@owned Array\u003cτ_0_0\u003e) -\u003e @owned Array\u003cτ_0_0\u003e // user: %17 %17 = apply %16\u003cAny\u003e(%5) : $@convention(thin) \u003cτ_0_0\u003e (@owned Array\u003cτ_0_0\u003e) -\u003e @owned Array\u003cτ_0_0\u003e // users: %26, %23 // function_ref default argument 1 of print(_:separator:terminator:) %18 = function_ref @default argument 1 of Swift.print(_: Any..., separator: Swift.String, terminator: Swift.String) -\u003e () : $@convention(thin) () -\u003e @owned String // user: %19 %19 = apply %18() : $@convention(thin) () -\u003e @owned String // users: %25, %23 // function_ref default argument 2 of print(_:separator:terminator:) %20 = function_ref @default argument 2 of Swift.print(_: Any..., separator: Swift.String, terminator: Swift.String) -\u003e () : $@convention(thin) () -\u003e @owned String // user: %21 %21 = apply %20() : $@convention(thin) () -\u003e @owned String // users: %24, %23 // function_ref print(_:separator:terminator:) %22 = function_ref @Swift.print(_: Any..., separator: Swift.String, terminator: Swift.String) -\u003e () : $@convention(thin) (@guaranteed Array\u003cAny\u003e, @guaranteed String, @guaranteed String) -\u003e () // user: %23 %23 = apply %22(%17, %19, %21) : $@convention(thin) (@guaranteed Array\u003cAny\u003e, @guaranteed String, @guaranteed String) -\u003e () release_value %21 : $String // id: %24 release_value %19 : $String // id: %25 release_value %17 : $Array\u003cAny\u003e // id: %26 %27 = tuple () // user: %28 return %27 : $() // id: %28 } // end sil function 'Foo.Foo.bar() -\u003e ()' // @objc Foo.bar() sil private [thunk] @@objc Foo.Foo.bar() -\u003e () : $@convention(objc_method) (Foo) -\u003e ()","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:11:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"推荐文章 Swift Intermediate Language (SIL) 从 SIL 角度看 Swift 中的值类型与引用类型 从 SIL 看 Swift 函数派发机制 iOS下的闭包下篇-Closure Swift 性能优化(2)——协议与泛型的实现 Swift 泛型底层实现原理 【译】Understanding the “some” and “any” keywords in Swift 5.7 【译】What is the “some” keyword in Swift? 【译】What is the “any” keyword in Swift? 【译】What’s the difference between any and some in Swift 5.7? 【译】Using the ‘some’ and ‘any’ keywords to reference generic protocols in Swift 5 【译】What are primary associated types in Swift 5.7? ","date":"2022-07-26","objectID":"/swift%E8%A7%A3%E6%83%91/:12:0","tags":["iOS","swift"],"title":"Swift解惑","uri":"/swift%E8%A7%A3%E6%83%91/"},{"categories":["实现原理"],"content":"Runtime AutoreleasePoolPage 、SideTableMap、AssociationsManager 是在map_images-\u003emap_images_nolock-\u003earr_init() 函数中初始化的； 一个类最多能添加64个分类； ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"dyld加载流程 引自飘云的dyld详解 第一步：设置运行环境 第二步：加载共享缓存 第三步：实例化主程序 第四步：加载插入的动态库 第五步：链接主程序 第六步：链接插入的动态库 第七步：执行弱符号绑定 第八步：执行初始化方法（runtime和类的加载是在这一步） 第九步：查找入口点并返回 叙述一下： 配置环境变量，开启共享缓存，接下来把主程序的可执行文件（macho）加载进内存，检测macho内的magic、cpu等属性以及兼容性，如果通过则创建一个imageLoader，然后插入动态库，链接主程序（加载进所有依赖库，然后rebase修正偏移、rebind绑定符号地址）和插入的动态库，然后弱符号绑定，接下来就是进入真正的初始化方法，如下图，当dyld加载到开始链接主程序的时候，递归调用recursiveInitialization函数； _objc_init recursiveInitialization 这个函数第一次执行，会走到 doInitialization -\u003e doModInitFunctions -\u003e libSystemInitialized，进行libsystem的初始化； libsystem 的初始化，它会调用起 libdispatch_init，libdispatch 的 init 会调用 _os_object_init，这个函数里面调用了 _objc_init； _objc_init 中注册并保存了map_images、load_images、unmap_image函数地址； 注册完毕继续回到 recursiveInitialization 递归下一次调用，例如 libobjc，当 libobjc 来到 recursiveInitialization 调用时会触发libsystem，调用到_objc_init里注册好的回调函数进行调用，就来到了libobjc，调用load_images。 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:1","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"类的加载 read_image： 初始化gdb_objc_realized_classes表，容量是类总数量的 4/3 倍，这个表用来存放不在共享缓存中并且非懒加载类。接下来从mach-o中读取非懒加载类，把从mach-o中读取的类指针转换成类名，变成可识别的类（地址 -\u003e 类名），然后加入前面创建的gdb_objc_realized_classes map表中（这个表的作用是在后面处理类有没有被正确的处理），同时也会加入 allocatedClasses 这个set表中（这个表是在 _objc_init 中的 runtime_init 函数中初始化的，存储的是已经初始化过的类）；总的来说，这一步就是把类读取到内存； 接下来就是重点方法realizeClassWithoutSwift：创建rw，把ro放到rw中（方法列表是在后面放的），递归执行realizeClassWithoutSwift，即递归设置rw； 设置类、父类和元类，其实就是生成一个双向链表； methodizeClass ： 获取class的ro中的baseMethods，通过prepareMethodLists函数进行方法升序排序，然后 unttachedCategories::attachToClass ，这里是重头戏， attachToClass中会执行attachCategories，在这里面会初始化rwe，在这过程中会把ro中的方法列表、属性列表、协议列表都复制到rwe中，然后接着会把category中的方法列表、属性列表、协议列表也会吸纳进去，此时类才算加载完成； 方法排序的这里有几个细节：在methodizeClass中首次从class_ro_w中拿到basemethods后就立即做了升序排序处理，而分类中的方法排序发生在attachCategory方法中，也就是说他们是分开各自独立排序的（疑问：没有整合到一起后再排序，那怎么用的二分查找？）。 解答： 只有类和分类都实现load方法，才会存在load_image阶段分类方法整合到所属类的方法列表中的操作，也就是说只有类或者分类中实现load方法的情况，类的方法列表和分类方法都是直接在编译期存放在class_ro_t中的baseMethods中的；那这种情况怎么能保证分类方法在原始类方法前面的？这应该是编译器自己在编译期做的处理，让分类方法地址比原始类的方法地址要低。而对于二分查找，其实整合后的方法列表其实是个二维数组，内部存的是排好序的一维方法列表（methodizeClass阶段preparemethod进行方法排序），方法查找先是顺序遍历二维数组，再在有序的一维方法列表中进行二分查找。 方法添加顺序：新建个数组，先把类中class_ro_w basemethods放到数组的后面，然后把分类方法放到数组前面 为什么category会覆盖原来的方法？ 在map_images方法的 attachCategories -\u003e attachLists 分类附加到原来的类的方法列表时，会先重新开辟一个新的数组，把原来的方法列表倒序遍历添加到新数组的后面，接着再正序遍历，把分类的方法添加到新数组的前面（方法列表的顺序与原来的顺序一致）； methodLists 类和category实现load对加载的影响 只有类和分类都实现load方法，才会发生在load_image阶段分类方法整合到所属类的方法列表中的操作; 只有类或者分类中实现load的时候，类的方法和分类方法都是直接在编译期存放到class_ro_t中的baseMethods中的。那这种情况怎么能保证分类方法在原始类方法前面的？这应该是编译器自己在编译期做的处理，让分类方法地址比原始类的方法地址要低（方法排序用的是升序排序）。 而对于类和分类都实现load的场景，即在load_image阶段把分类方法整合到类的方法列表中的情况是如何进行二分查找的呢？其实整合后的方法列表是个二维数组，内部存的是排好序的一维方法列表（methodizeClass阶段preparemethod进行的方法升序排序），方法查找时先是顺序遍历二维数组，再在有序的一维方法列表中进行二分查找。 综上所述，不要在类和分类中同时实现load方法也是提升启动速度的一个点，当然，不用load最好了。 为什么会有CleanMemory和DirtyMemory呢？ iOS运行过程中会涉及对内存进行增删改查，为了防止对原始数据的修改，所以把原来的CleanMemory copy一份到rw中。 有了rw为什么还要rwe（脏内存）？因为不是所有的类加载进内存时需要进行动态的插入、删除，当我们添加一个属性、一个方法会对内存改动很大，对内存的消耗有一定影响，所以只要我们对类进行动态处理了（比如把category的方法、属性、协议合并到类中），就会生成一个rwe。 为什么执行load方法时没有触发initialize？ 一定明确initialize是在首次发消息时才会触发，而load的执行是通过函数指针的方式调用的，没有走消息发送机制，所以不会触发initialize。 为什么在对象释放过程中通过weak变量获取不到这个对象？ 在关联的场景中，比如A关联B，B弱持有A，A释放时会释放其关联的B，导致B的dealloc执行，然后我们在B的dealloc方法中通过weak变量读取A，却发现获取到的是nil（根据释放流程此时A还没有free掉），这是为什么？ 分析如下： 读取weak变量时执行的是objc_loadWeak函数，内部执行大概流程为：objc_loadWeak -\u003e objc_loadWeakRetained -\u003e obj-\u003erootTryRetain() -\u003e rootRetain(true, RRVariant::Fast) ，在rootRetain中如果当前对象正在处于释放流程中，则返回nil。具体代码如下： id objc_loadWeakRetained(id *location) { id obj; id result; Class cls; SideTable *table; retry: obj = *location; if (_objc_isTaggedPointerOrNil(obj)) return obj; table = \u0026SideTables()[obj]; table-\u003elock(); if (*location != obj) { table-\u003eunlock(); goto retry; } result = obj; cls = obj-\u003eISA(); if (! cls-\u003ehasCustomRR()) { // 执行此逻辑 if (! obj-\u003erootTryRetain()) { result = nil; } } else { // 执行不到的逻辑，删掉 } table-\u003eunlock(); return result; } ALWAYS_INLINE bool objc_object::rootTryRetain() { return rootRetain(true, RRVariant::Fast) ? true : false; } ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, objc_object::RRVariant variant) { if (slowpath(isTaggedPointer())) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; isa_t oldisa; isa_t newisa; oldisa = LoadExclusive(\u0026isa().bits); // ... do { transcribeToSideTable = false; newisa = oldisa; // 关键逻辑： // 如果正在释放中，并且tryRetain=true，则返回nil // don't check newisa.fast_rr; we already called any RR overrides if (slowpath(newisa.isDeallocating())) { ClearExclusive(\u0026isa().bits); if (sideTableLocked) { ASSERT(variant == RRVariant::Full); sidetable_unlock(); } if (slowpath(tryRetain)) { return nil; } else { return (id)this; } } uintptr_t carry; newisa.bits = addc(newisa.bits, RC_ONE, 0, \u0026carry); // extra_rc++ if (slowpath(carry)) { // newisa.extra_rc++ overflowed if (variant != RRVariant::Full) { ClearExclusive(\u0026isa().bits); return rootRetain_overflow(tryRetain); } // Leave half of the retain counts inline and // prepare to copy the other half to th","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:2","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"对象释放流程 调用release -\u003e rootRelease，引用计数-1，当引用计数变为0时，就会通过objc_msgSend调用Objective-C对象的dealloc方法，然后进入到objc_object::rootDealloc()函数，函数内部会读取当前对象的isa中存储的信息，包括是否是非指针、有没有弱引用、成员变量、关联对象、has_sidetable_rc，如果都没有会直接释放（free），否则会执行objc_destructInstance(obj)，这个函数的逻辑为先释放成员变量，接着移除关联对象，再移除弱引用，把弱引用指针置为nil，最后再从SideTable的RefcountMap refcnts成员变量中 把存储当前对象引用计数的记录（key-value）从引用计数表中移除，类似于从字典中把这条key-value都删除（疑问：此时引用计数已经是0了，那最后这个引用计数表的处理是不是多余的，什么情况下会执行进来？？？）。 在dealloc方法中如果有对self的引用，比如- (void)dealloc { id obj = self; }，是不会发生引用计数+1的，runtime处理如下： // 是否正在释放 bool isDeallocating() { return extra_rc == 0 \u0026\u0026 has_sidetable_rc == 0; } // retain最终执行的函数 ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, objc_object::RRVariant variant) { // 省略代码 ... // 在dealloc中这里的执行结果是true if (slowpath(newisa.isDeallocating())) { ClearExclusive(\u0026isa.bits); if (sideTableLocked) { ASSERT(variant == RRVariant::Full); sidetable_unlock(); } if (slowpath(tryRetain)) { return nil; } else { return (id)this; } } // 省略代码 ... } ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:3","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"Weak weak_table_t 是全局保存弱引用的哈希表，它是通过对object地址做hash计算，然后从8个SideTable数组中取出其中一张，然后再从SideTable中读取到weak_table。weak_table_t 是以 object 地址为 key，以 weak_entry_t 为 value。 weak_entry_t 是用来存储所有指向某个对象的弱引用变量的地址的，里面有个weak_referrer_t数组，它存储的其实是弱引用的指针，即指针的指针，这么做的目的是可以把弱引用置为nil。 weak_entry_t 中有2种结构，当存储的弱引用数量\u003c= 4个的时候用的其实是个定长数组，\u003e 4的时候才会转为哈希数组。（这里使用哈希数组的原因应该是为了处理B弱引用A，然后B先释放了，这时那个弱引用可能也要置为nil，用hash数组的话查询速度会比较快）。往weak_entry_t 中添加弱引用变量时，即更新weak_referrer_t采用的是定向寻址法； 往weak_table 中插入weak_entry_t时，先是对object地址取hash作为它的index，如果这个index下的位置不为空，则通过一个算法（index = (index+1) \u0026 weak_table-\u003emask）重新计算生成一个新的index再读取对应的位置，直到找到一个空位置，然后把weak_entry_t放进去，同时更新元素数量。这种插入方式其实也是定向寻址法。 hash 函数，与 mask 做与操作，防止 index 越界; size_t begin = hash_pointer(referent) \u0026 weak_table-\u003emask; weak_hash_insert weak_table_t 还有一个扩容和缩容的处理，当前使用容量占到总容量（mask + 1)的 3/4 的时候会进行扩容处理，扩大到现有总容量的2倍。 当总容量超过1024，而实际使用的空间低于总空间的 1/16 时则会进行容量压缩，缩到现有总容量的1/8 （为什么是八分之一？是为了保证总容量是现有使用容量的2`倍）。 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"@synchronized原理 先从当前线程的TLS中尝试获取SyncData（本身是个单向链表），如果存在并且SyncData中的object与传进来的object相同，则说明找到对应的SyncData了。更新锁数量（lockCount），并返回SyncData。 （注意：一条线程的TLS中只能存唯一一个SyncData，假如已经存在了但是object并不与自己传进来的一致，则创建新的SyncData后并不会更新到TLS中，而是保存到 pthread_data 中，有点先入为主的意思） 从pthread_data中获取SyncCache（里面存着一个SyncCacheItem数组，SyncCacheItem存的是SyncData），如果存在则遍历SyncCacheItem数组，如果cacheItem中的syncData中的object与传进来的object相同，则更新 item-\u003elockCount ，然后返回SyncData。 走到这里就说明没有从thread cache中找到合适的SyncData。这时就会从全局StripMap\u003cSyncList\u003e sDataLists 表中读取，先通过对象object的hash值取出一个SyncList，接着拿到SyncList中的SyncData链表，然后遍历整个链表。 a. 如果发现与object匹配的SyncData则更新SyncData中的threadCount数量，然后把找到的这个SyncData保存到TLS或者pthread_data中的SyncCache里面； b. 如果遍历到最后也没发现匹配的，则找到链表中第一个未使用（SyncData中的threadCount = 0）的SyncData，进行复用。这个SyncData也会和上面一样进行缓存； c. 如果没找到匹配的，也没找到未使用的，则创建一个新的SyncData。这个新的SyncData会先保存到SyncList中，然后也会和上面一样保存到TLS或者pthread_data中一份，即新创建的有2份缓存。 synchronized ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"Associate 原理 所有的关联对象都是由AssociationsManager管理的，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象。这相当于把所有对象的关联对象都存在一个全局hashMap里面，hashMap的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个hashMap的value又是一个ObjectAssociationsMap，里面保存了关联对象的key和对应的value值。runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有会调用_object_remove_assocations做关联对象的清理工作。 在set和get时，即对内部的map进行操作时都会用manager中的spinlock（底层其实还是unfair_lock），所以set、get时一般情况下是线程安全的。但是可能是为了追求性能，set时把旧对象的释放放到了锁外，atomic get时为了保证线程安全，会retain一下访问对象，在锁外又autorelease了一下，如果不执行retain操作可能会出现数据竞争。可以参考下这篇文章: AssociatedObject 源码分析：如何实现线程安全？ Associate ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:4:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"GCD 可创建的最大线程数是 255 thread_pool_size = DISPATCH_WORKQ_MAX_PTHREAD_COUNT 255 自定义串行队列是overcommit的，并行队列不是overcommit的 自定义队列的目标队列在初始化时传参为NULL，然后会为其从_dispatch_root_queues 中获取一个根目标队列；当 tq 为 NULL，即入参目标队列为 DISPATCH_TARGET_QUEUE_DEFAULT（值是 NULL） 时， 根据 qos 和 overcommit 从 _dispatch_root_queues 全局的根队列数组中获取一个根队列作为新队列的目标队列 if (!tq) { tq = _dispatch_get_root_queue( qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, overcommit == _dispatch_queue_attr_overcommit_enabled)-\u003e_as_dq; if (unlikely(!tq)) { // 如果未取得目标队列则 crash DISPATCH_CLIENT_CRASH(qos, \"Invalid queue attribute\"); } } dispatch_sync a. 首先将任务加入队列 b. 执行任务block c. 将任务移出队列 d. sync里面的处理最终执行的是barrier的内部函数 e. 会死锁的原因：执行时会检查当前线程的状态（是否正在等待），然后与当前的线程的ID（_dispatch_tid_self()）做比较，相等的话则判定为死锁。（相关处理在 __DISPATCH_WAIT_FOR_QUEUE__ 函数中） dispatch_async a. 将异步任务（dispatch_queue 、 block）封装为 dispatch_continuation_t 类型 b. 然后执行 _dispatch_continuation_async -\u003e dx_push递归重定向到根队列，然后执行_dispatch_root_queue_poke进行出队操作，通过创建线程执行 dx_invoke 执行block回调； dispatch_barrier_async a. 和dispatch_async 流程一样，只是里面有一个while循环，等队列中的barrier前面的任务执行完，才执行后面的； b. 这里有个优化是：封装成 dispatch_continuation_s 结构时，会先从当前线程的TLS中获取一下，获取不到再从堆上创建新的 dispatch_group a. dispatch_group内部维护着一个数值，初始值为0，enter时减4，leave时加4 https://juejin.cn/post/6902346229868019719#heading-4 b. 等待用的是while循环，而不是信号量 dispatch_semaphore_t a. dispatch_semaphore_wait 时里面其实是起了一个do-while 循环，不断的去查询原子变量的值，不满足条件时会一直循环，借此阻塞流程的进行。有点像dispatch_once dispatch_group_async 内部其实是对dispatch_async 和 dispatch_group_enter / dispatch_group_leave 的封装 线程池复用原理 线程创建后从队列里取出任务执行，任务执行后使用信号量使其等待5秒钟，如果在这期间再有GCD任务过来，会先尝试唤醒线程，让它继续工作，否则等待超时后线程会自动结束，被系统销毁。（不是tableview中的复用池机制） static void * _dispatch_worker_thread(void *context) { ////////////////////////////////// // 删减了部分代码 ////////////////////////////////// dispatch_queue_global_t dq = context; dispatch_pthread_root_queue_context_t pqc = dq-\u003edo_ctxt; int pending = os_atomic_dec2o(dq, dgq_pending, relaxed); // 线程存活5秒钟 const int64_t timeout = 5ull * NSEC_PER_SEC; pthread_priority_t pp = _dispatch_get_priority(); dispatch_priority_t pri = dq-\u003edq_priority; // 从队列中取出任务执行，执行完后等待5秒钟 // 如果5秒后没有被唤醒则进入超时逻辑，队列释放，线程退出 do { // 任务执行 _dispatch_root_queue_drain(dq, pri, DISPATCH_INVOKE_REDIRECTING_DRAIN); _dispatch_reset_priority_and_voucher(pp, NULL); } while (dispatch_semaphore_wait(\u0026pqc-\u003edpq_thread_mediator, dispatch_time(0, timeout)) == 0); #if DISPATCH_USE_INTERNAL_WORKQUEUE if (monitored) _dispatch_workq_worker_unregister(dq); #endif (void)os_atomic_inc2o(dq, dgq_thread_pool_size, release); _dispatch_root_queue_poke(dq, 1, 0); _dispatch_release(dq); // retained in _dispatch_root_queue_poke_slow return NULL; } dispatch_once dispatch_once函数中的token (dispatch_once_t) 会被强转为dispatch_once_gate_t类型，而dispatch_once_gate_t里面是个union联合体类型，其中dgo_once用来记录当前block的执行状态，执行完后状态会被标记为DLOCK_ONCE_DONE。 typedef struct dispatch_once_gate_s { union { dispatch_gate_s dgo_gate; uintptr_t dgo_once; }; } dispatch_once_gate_s, *dispatch_once_gate_t; 我们首先获取dgo_once变量的值，如果是DLOCK_ONCE_DONE，则表示已经执行过了，直接return掉； 如果是DLOCK_ONCE_UNLOCKED状态，则表示首次执行，然后会把当前的线程id存到dgo_once变量中，然后开始执行block任务，结束后会把dgo_once置为DLOCK_ONCE_DONE； 如果有其他线程执行过来，根据dgo_once判断，发现正在执行中，则会进入等待流程，等待其实是启了个for (;;)无限循环，在循环中不断地通过原子操作查询dgo_once的状态，等发现变为DLOCK_ONCE_DONE后则退出循环。 dispatch_source_merge_data 对应的结构定义 // 定义在 libdispatch 仓库中的 init.c 文件中 DISPATCH_VTABLE_INSTANCE(source, .do_type = DISPATCH_SOURCE_KEVENT_TYPE, .do_dispose = _dispatch_source_dispose, .do_debug = _dispatch_source_debug, .do_invoke = _dispatch_source_invoke, .dq_activate = _dispatch_source_activate, .dq_wakeup = _dispatch_source_wakeup, .dq_push = _dispatch_lane_push, ); 把任务包装成dispatch_continuation_t对象，每次dispatch_source_merge_data时对内部变量进行原子性的ADD、OR、REPLACE等操作，并执行dx_wakeup函数，dx_wakeup是个宏定义，其实调用的是_dispatch_source_wakeup，wakeup这个函数其实是一个入队操作，但并不是每次都会进行入队（此处还未完全看明白 o(╯□╰)o ），接着会执行_dispatch_main_queue_drain -\u003e _dispatch_continuation_pop_inline出队操作，流程基本和dispatch_async一致。 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:5:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"NSTimer timer添加到runloop的过程： 如果是commonMode ，会被添加到runloop持有的一个_commonModeItems 集合中， 然后调用 __CFRunLoopAddItemToCommonModes 函数，把timer添加到runloopMode对象持有的_timers数组中 ，同时也会把modeName添加到runloopTimer的 _rlModes 中，记录runloopTimer都能在哪种runloop mode下执行； 如果是普通mode，则先获取这个runloopMode对象，把runloopMode的name添加到runloopTimer持有的 _rlModes集合中，然后调用 __CFRepositionTimerInMode 函数，把runloopTimer插入runloopMode持有的 _timers 数组中（如果数组中已经存在了，则先做移除操作）； 上面添加完成后，会调用 __CFRepositionTimerInMode 函数，然后调用 __CFArmNextTimerInMode，再调用 mk_timer_arm 函数把 CFRunLoopModeRef 的 _timerPort 和一个时间点注册到系统中，等待着 mach_msg 发消息唤醒休眠中的 runloop 起来执行到达时间的计时器。（macOS 和 iOS 下都是使用 mk_timer 来唤醒 runloop）； 每次计时器都会调用 __CFArmNextTimerInMode 函数注册计时器的下次执行时间（这个时间是基于本次执行的理论时间叠加得到的，而非当前的真实时间，也就是说假如本次执行滞后了，不会影响下次理论上要执行的时间点），休眠中的runloop 通过当前runloop mode的 _timerPort 端口唤醒，然后在本次runloop循环中在 _CFRunloopDoTimers 函数中循环调用 __CFRunLoopDoTimer 函数，执行达到触发时间的timer的 _callout 函数。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-\u003e_callout, rlt, context_info); 是执行计时器的 _callout 函数。 NSTimer 不准时问题 通过上面的 NSTimer 执行流程可看到计时器的触发回调完全依赖 runloop 的运行（macOS 和 iOS 下都是使用 mk_timer 来唤醒 runloop），使用 NSTimer 之前必须注册到 run loop，但是 run loop 为了节省资源并不会在非常准确的时间点调用计时器，如果一个任务执行时间较长（例如本次 run loop 循环中 source0 事件执行时间过长或者计时器自身回调执行时间过长，都会导致计时器下次正常时间点的回调被延后或者延后时间过长的话则直接忽略这次回调（计时器回调执行之前会判断当前的执行状态 !__CFRunLoopTimerIsFiring(rlt)，如果是计时器自身回调执行时间过长导致下次回调被忽略的情况大概与此标识有关 ）），那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer 提供了一个 tolerance 属性用于设置宽容度，即当前时间点已经过了计时器的本次触发点，但是超过的时间长度小于 tolerance 的话，那么本次计时器回调还可以正常执行，不过是不准时的延后执行。 tolerance 的值默认是 0，最大值的话是计时器间隔时间_interval 的一半，可以根据自身的情况酌情设置 tolerance 的值。 （NSTimer 不是一种实时机制，以 main run loop 来说它负责了所有的主线程事件，例如 UI 界面的操作，负责的运算使当前 run loop 持续的时间超过了计时器的间隔时间，那么计时器下一次回调就被延后，这样就造成 timer 的不准时，计时器有个属性叫做 tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果延后时间过长的话会直接导致计时器本次回调被忽略。） ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:6:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["实现原理"],"content":"推荐文章 深入浅出 GCD 之 dispatch_queue iOS之武功秘籍⑧: 类和分类加载过程 iOS 从源码解析Run Loop (八)：Run Loop 与 AutoreleasePool、NSTimer、PerformSelector 系列 ","date":"2022-06-09","objectID":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:7:0","tags":["iOS","runtime"],"title":"iOS源码阅读笔记","uri":"/ios%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["开发环境"],"content":"问题 ","date":"2024-01-30","objectID":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","tags":["开发环境","前端"],"title":"前端开发环境配置","uri":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["开发环境"],"content":"Python12 移除 distutils 包，导致 pnpm 执行失败 ❯ pnpm add canvas -D Packages: +804 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Progress: resolved 804, reused 804, downloaded 0, added 0, done node_modules/.pnpm/canvas@2.11.2_encoding@0.1.13/node_modules/canvas: Running install script, failed in 1.7s .../node_modules/canvas install$ node-pre-gyp install --fallback-to-build --update-binary │ node-pre-gyp info it worked if it ends with ok │ node-pre-gyp info using node-pre-gyp@1.0.11 │ node-pre-gyp info using node@20.11.0 | darwin | arm64 │ node-pre-gyp http GET https://github.com/Automattic/node-canvas/releases/download/v2.11.2/canvas-v2.11.2-node-v115-darwin-unknown-ar… │ node-pre-gyp ERR! install response status 404 Not Found on https://github.com/Automattic/node-canvas/releases/download/v2.11.2/canva… │ node-pre-gyp WARN Pre-built binaries not installable for canvas@2.11.2 and node@20.11.0 (node-v115 ABI, unknown) (falling back to so… │ node-pre-gyp WARN Hit error response status 404 Not Found on https://github.com/Automattic/node-canvas/releases/download/v2.11.2/can… │ gyp info it worked if it ends with ok │ gyp info using node-gyp@9.4.1 │ gyp info using node@20.11.0 | darwin | arm64 │ gyp info ok │ gyp info it worked if it ends with ok │ gyp info using node-gyp@9.4.1 │ gyp info using node@20.11.0 | darwin | arm64 │ gyp info find Python using Python version 3.12.1 found at \"/Users/zero_d_saber/.pyenv/versions/3.12.1/bin/python\" │ gyp info spawn /Users/zero_d_saber/.pyenv/versions/3.12.1/bin/python │ gyp info spawn args [ │ gyp info spawn args '/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_modules/node-gyp/gyp/gyp… │ gyp info spawn args 'binding.gyp', │ gyp info spawn args '-f', │ gyp info spawn args 'make', │ gyp info spawn args '-I', │ gyp info spawn args '/Users/zero_d_saber/Dev/Tauri/solid-pnpm/node_modules/.pnpm/canvas@2.11.2_encoding@0.1.13/node_modules/canvas… │ gyp info spawn args '-I', │ gyp info spawn args '/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_modules/node-gyp/addon.g… │ gyp info spawn args '-I', │ gyp info spawn args '/Users/zero_d_saber/Library/Caches/node-gyp/20.11.0/include/node/common.gypi', │ gyp info spawn args '-Dlibrary=shared_library', │ gyp info spawn args '-Dvisibility=default', │ gyp info spawn args '-Dnode_root_dir=/Users/zero_d_saber/Library/Caches/node-gyp/20.11.0', │ gyp info spawn args '-Dnode_gyp_dir=/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_modules/n… │ gyp info spawn args '-Dnode_lib_file=/Users/zero_d_saber/Library/Caches/node-gyp/20.11.0/\u003c(target_arch)/node.lib', │ gyp info spawn args '-Dmodule_root_dir=/Users/zero_d_saber/Dev/Tauri/solid-pnpm/node_modules/.pnpm/canvas@2.11.2_encoding@0.1.13/n… │ gyp info spawn args '-Dnode_engine=v8', │ gyp info spawn args '--depth=.', │ gyp info spawn args '--no-parallel', │ gyp info spawn args '--generator-output', │ gyp info spawn args 'build', │ gyp info spawn args '-Goutput_dir=.' │ gyp info spawn args ] │ Traceback (most recent call last): │ File \"/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_modules/node-gyp/gyp/gyp_main.py\", line… │ import gyp # noqa: E402 │ ^^^^^^^^^^ │ File \"/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_modules/node-gyp/gyp/pylib/gyp/__init__… │ import gyp.input │ File \"/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_modules/node-gyp/gyp/pylib/gyp/input.py… │ from distutils.version import StrictVersion │ ModuleNotFoundError: No module named 'distutils' │ gyp ERR! configure error │ gyp ERR! stack Error: `gyp` failed with exit code: 1 │ gyp ERR! stack at ChildProcess.onCpExit (/Users/zero_d_saber/.volta/tools/image/packages/pnpm/lib/node_modules/pnpm/dist/node_mo… │ gyp ERR! stack at ChildProcess.emit (node:events:","date":"2024-01-30","objectID":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:1","tags":["开发环境","前端"],"title":"前端开发环境配置","uri":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["开发环境"],"content":"yarn4 module找不到 yarn4 node_modules 解决方案 yarn config set nodeLinker node-modules ","date":"2024-01-30","objectID":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:2","tags":["开发环境","前端"],"title":"前端开发环境配置","uri":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["学习笔记"],"content":"记录React Native学习过程中的一点收获","date":"2024-01-14","objectID":"/reactnativenote/","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：JSON转JavaScript对象时自定义key const jsonString = '{\"componentName\":\"abc\",\"theme\":\"light\",\"debugMode\":\"1\"}' const obj = JSON.parse(jsonString, function(k, v){ if (k == 'theme') { // 给自定义的属性赋值 this.custom = v; // 返回undefined会把当前这个key从对象中移除 return undefined; } else if (k == '') { console.log(\"宝儿姐\"); } return v; }); console.log(obj); ","date":"2024-01-14","objectID":"/reactnativenote/:1:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：对象如何判空？ let obj; console.log(obj == null); // true console.log(obj == undefined); // true console.log(obj == false); // false ","date":"2024-01-14","objectID":"/reactnativenote/:2:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：?? 与 || 区别 ?? 只有当value是null、undefined时才会取后面的值，而 || 则认为null、undefined、0、\"\"、false 这些都是false。 ","date":"2024-01-14","objectID":"/reactnativenote/:3:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：JS数组取值需要注意越界问题吗？ 不需要，JS的数组不会发生越界的异常，我们使用时只需关注数组是否 undefined的问题。 const arr = [] console.log(arr[0]) // undefined undefined问题： undefined 解决办法： const arr = undefined console.log(arr?.[0]) // undefined ","date":"2024-01-14","objectID":"/reactnativenote/:4:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：JS中如何判断一个变量是数组还是对象？ const arr = [] const obj = {} console.log(Array.isArray(arr)) // true ","date":"2024-01-14","objectID":"/reactnativenote/:5:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：\u003c\u003e vs React.flagment 相同点： 都可以包裹子元素 都不渲染任何真实的DOM标签 性能提升 不同点： React.flagment支持设置key属性 fragment可以解决我们什么问题？ map函数中的组件需要设置key属性，\u003c\u003e 并不支持设置属性，而我们又不想增加DOM节点，此时React.fragment就可以大展身手了： \u003cText style={style} numberOfLines={numberOfLines}\u003e {icons?.map(({ width, height, url }, index) =\u003e { return ( \u003cReact.fragment key={index.toString()}\u003e \u003cImage style={styles.iconImg} resizeMode={'contain'} source={{ uri: url, }} /\u003e \u003cText\u003e\u0026nbsp;\u003c/Text\u003e \u003c/React.Fragment\u003e ); })} {props.children ?? ''} \u003c/Text\u003e ","date":"2024-01-14","objectID":"/reactnativenote/:6:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：hook函数不让在函数中使用怎么办？ 使用useMutation export function useQueryProviderNextPage() { const bookId = 123 const dispatch = useAppDispatch(); return useMutation( (params: IParams) =\u003e { return request({ method: 'POST', url: '/a/b/c', params: { id: bookId, currentPage: params.currentPage ?? 2, }, }); }, { onSuccess: (response) =\u003e { if (response) { dispatch(updateProviderList(response.data)); } }, onError: (response) =\u003e { console.log('--- 请求失败---', console.log(JSON.stringify(response))); }, }, ); } const fetchNextPageMutation = useQueryNextPage(); // 调用 fetchNextPageMutation.mutate({ currentPage: (section?.currentPage ?? 1) + 1, bookId: section?.id, }); ","date":"2024-01-14","objectID":"/reactnativenote/:7:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：ListEmptyComponets 不能铺满： 给SectionList设置如下属性: contentContainerStyle={{ flexGrow: 1, }} ","date":"2024-01-14","objectID":"/reactnativenote/:8:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["学习笔记"],"content":"Q：条件渲染 React 中条件渲染的 N 种方法 在写组件时不要用{ 判断条件 \u0026\u0026 组件 }这种写法，因为假如前面的条件是false，那这个结果就是 { false } ，然而这并不是一个合法的组件，在某些场景下会报错。建议使用{ 判断条件 ? 组件 : null }这种方式。 ","date":"2024-01-14","objectID":"/reactnativenote/:9:0","tags":["ReactNative"],"title":"React Native笔记","uri":"/reactnativenote/"},{"categories":["面试"],"content":"面试准备","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"优秀文章 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:0","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"UI iOS触摸事件全家桶 移动端渲染原理浅析 iOS渲染原理 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:1","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"Runtime iOS源码阅读笔记 dyld详解 iOS之武功秘籍 Block的本质 Block捕获实体引用 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:2","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"Memory iOS Memory内存详解 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:3","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"Performance 带你打造一套APM监控系统 iOS APP包瘦身真没你想的那么难，难得是业务！！！ ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:4","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"Crash iOS crash分类：Mach异常、Unix信号和NSException异常 iOS崩溃监控与分析 你真的懂iOS的异常捕获吗？ iOS Crash崩溃异常捕获 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:5","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"Network 计算机网络太难了？了解这一篇就够了 「查缺补漏」巩固你的HTTP知识体系 Web技术（五）：HTTP/2 是如何解决HTTP/1.1 性能瓶颈的？ Web技术（六）：QUIC 是如何解决TCP 性能瓶颈的？ ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:6","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"Swift 从 SIL 角度看 Swift 中的值类型与引用类型 从 SIL 看 Swift 函数派发机制 iOS下的闭包下篇-Closure Swift 性能优化(2)——协议与泛型的实现 Swift 泛型底层实现原理 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:7","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"业务 iOS直播流程概述 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:1:8","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"算法 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:0","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"快速排序 class Solution { func sortArray(_ nums: [Int]) -\u003e [Int] { let left = 0, right = nums.count - 1 var arr = nums quickSort(\u0026arr, left, right) return arr } func quickSort(_ nums: inout [Int], _ low: Int, _ high: Int) { guard low \u003c high else { return } let randomIndex = Int.random(in: (low...high)) let pivot = nums[randomIndex] // 把随机选择的数放到最前面 nums.swapAt(low, randomIndex) var left = low, right = high while left \u003c right { while left \u003c right, pivot \u003c= nums[right] { right -= 1 } while left \u003c right, nums[left] \u003c= pivot { left += 1 } if left \u003c right { nums.swapAt(left, right) } } // 把pivot交换回来 nums.swapAt(left, low) quickSort(\u0026nums, low, left - 1) quickSort(\u0026nums, left + 1, high) } } ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:1","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"二叉树遍历 递归 /// traversals 为输出的数组 func preorder(_ node: TreeNode?) { guard let node = node else { return } /// 前序遍历 traversals.append(node.val) preorder(node.left) preorder(node.right) /// 中序遍历 preorder(node.left) traversals.append(node.val) preorder(node.right) /// 后序遍历 preorder(node.left) preorder(node.right) traversals.append(node.val) } 迭代 前序遍历 func preorderIteration(_ root: TreeNode?) { var st: [TreeNode?] = [root] while !st.isEmpty { guard node = st.removeLast() else { continue } traversals.append(node.val) st.insert(node.right, at: 0) st.insert(node.left, at: 0) } } 中序遍历 func inorderIteration(_ root: TreeNode?) { var st: [TreeNode?] = [] var cur: TreeNode? = root while cur != nil || !st.isEmpty { if cur != nil { st.append(cur) cur = cur?.left } else { let lastNode = st.popLast() traversals.append(lastNode!.val) cur = lastNode?.right } } } 后序遍历 func postorderIteration(_ root: TreeNode?) { var st: [TreeNode?] = [root] while !st.isEmpty { let node = st.removeFirst() if node != nil { traversals.append(node!.val) } else { continue } st.insert(node?.left, at: 0) st.insert(node?.right, at: 0) } traversals = traversals.reversed() } 颜色标记 前序 中→左→右 按照 右→左→中 中序 左→中→右 按照 右→中→左 后序 左→右→中 按照 中→右→左 func inorderTraversal(_ root: TreeNode?) -\u003e [Int] { var traversals = [Int]() var stack = [(root, false)] while !stack.isEmpty { let (node, isVisted) = stack.removeLast() guard let node == node else { continue } if isVisted { traversals.append(node.val) continue } // ------ 逆序添加 ------ ///前序遍历 stack.append((node.right, false)) stack.append((node.left, false)) stack.append((node, true)) ///中序遍历 stack.append((node.right, false)) stack.append((node, true)) stack.append((node.left, false)) ///后序遍历 stack.append((node, true)) stack.append((node.right, false)) stack.append((node.left, false)) } return traversals } ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:2","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"堆排序 // 堆排序 func sortArray(_ nums: [Int]) -\u003e [Int] { var nums = nums var endIndex = nums.count - 1 // 1.把当前数组构建成一个大顶堆 // 2.接着第一个值与最后一个值调换(把最大值放到最后) // 3.然后把刨除最后最大值的数组重新构建成大顶推， // 4.再然后递归执行上面的流程 repeat { buildMaxHeap(\u0026nums, endIndex) (nums[endIndex], nums[0]) = (nums[0], nums[endIndex]) endIndex = endIndex - 1 } while(endIndex \u003e 0) return nums } // 把数组构建成大顶堆 private func buildMaxHeap(_ nums: inout [Int], _ endIndex: Int) { var parentIndex = endIndex \u003e\u003e 1 while parentIndex \u003e= 0 { let parentValue = nums[parentIndex] var minNodeIndex = parentIndex let leftChildIndex = parentIndex * 2 + 1 if endIndex \u003e= leftChildIndex \u0026\u0026 nums[leftChildIndex] \u003e parentValue { minNodeIndex = leftChildIndex } let rightChildIndex = parentIndex * 2 + 2 if rightChildIndex \u003c= endIndex \u0026\u0026 nums[rightChildIndex] \u003e nums[minNodeIndex] { minNodeIndex = rightChildIndex } // 如果父节点不是最大的值，那么与最大值进行交换，保证堆顶是最大值 if minNodeIndex != parentIndex { (nums[minNodeIndex], nums[parentIndex]) = (nums[parentIndex], nums[minNodeIndex]) } parentIndex = parentIndex - 1 } } ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:3","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"基数（桶）排序 // 基数排序 func radixSort(_ nums: [Int]) -\u003e [Int] { // 最终结果 var resultArray = nums //通过基数排序实现 var maxDigit = 0 //最大位数 var digit = 0 //当前所在位数(个十百千万) var maxValue = 0 repeat { //1、建立20个桶((-9 - 9)一个数字一个桶),负数放在前10个桶,正数放到后10个桶 var buckets = [[Int]]() for _ in 0 ..\u003c 20 { buckets.append([Int]()) } //2、按每个位上的值放入对应的桶中 //let digit10n = NSDecimalNumber(decimal: pow(Decimal(10), digit)).intValue let digit10n = Int(pow(Double(10), Double(digit))) for num in resultArray { let mod = num / digit10n % 10 //取得某位上的值 buckets[mod + 10].append(num) //首次遍历时获取到数组中的最大值，后面要用它计算最大位数是多少位 if digit == 0 { maxValue = max(maxValue, abs(num)) } } //resultArray.removeAll() //3、二维数组降维成一维数组，用于二次递归 resultArray = buckets.flatMap {$0} // 计算绝对值最大的数的位数 if digit == 0 { var tempMaxValue = maxValue while tempMaxValue != 0 { tempMaxValue = tempMaxValue / 10 maxDigit = maxDigit + 1 } } //4、进位 digit = digit + 1 } while (digit \u003c maxDigit) return resultArray } ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:4","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"寻找两个View的最近公共父视图 - (__kindof MAS_VIEW *)mas_closestCommonSuperview:(MAS_VIEW *)view { MAS_VIEW *closestCommonSuperview = self; MAS_VIEW *secondViewSuperview = view; while (closestCommonSuperview != secondViewSuperview) { closestCommonSuperview = closestCommonSuperview == nil ? view : closestCommonSuperview.superview; secondViewSuperview = secondViewSuperview == nil ? self : secondViewSuperview.superview; } return closestCommonSuperview; } ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:5","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["面试"],"content":"leetcode #42 接雨水 #142 环形链表II #206 反转链表 #92 反转链表II #405 十进制转十六进制 #215 数组中第K个最大的元素 #面试题02.08 环路检测 ","date":"2022-10-25","objectID":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/:2:6","tags":["面试"],"title":"面试资料","uri":"/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"categories":["编译链接"],"content":"笔记 内存分为不可访问区域、.text、.data、.bss、堆区、共享库、.stack、内核区； 全局变量、静态变量在数据段，其中已初始化并且初始化值不为0的.data段，初始化为0或者未初始化的在.bss段，函数中的变量（即指令）放在了.text段； main函数第一个参数是命令行参数个数，第二个是命令行参数； .bss占用的是虚拟内存的空间，不占用mach-o文件的空间； mach-o的header中记录了.bss要占多少空间； mach-o中函数存的是偏移量，pc寄存器中存的是下一行指令的地址，跳转时需要用当前的指令偏移 + pc指令地址，才是我们要跳转到的函数地址； 链接时只处理mach-o文件中的global符号，不处理local符号（比如文件中的static变量）； 链接过程： a. 按属性（比如.data / .text）合并所有mach-o文件的段（即合并同名section为segment） -\u003e 并调整段偏移和段长度 -\u003e 合并符号表 -\u003e 进行符号解析 -\u003e 分配内存地址； b.由于编译过程中不会给符号分配地址，所以链接阶段要进行符号重定位（数据符号替换成真正的地址，函数符号替换成与下一行指令地址的偏移量）； ","date":"2022-09-22","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["iOS","编译链接"],"title":"《程序员的自我修养》笔记","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/"},{"categories":["编译链接"],"content":"视频 ","date":"2022-09-22","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["iOS","编译链接"],"title":"《程序员的自我修养》笔记","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/"},{"categories":["事件响应链"],"content":"childController的nextResponder是谁？","date":"2022-09-19","objectID":"/nextresponder/","tags":["iOS","事件响应链"],"title":"NextResponder","uri":"/nextresponder/"},{"categories":["事件响应链"],"content":"在这里就不介绍事件响应链了，想必大家很清楚，如果有朋友印象模糊了，推荐看看iOS触摸事件全家桶这篇文章。 那写点啥呢？咱们聊点上文中的几处不严谨的地方：视图的nextResponder是谁。 ","date":"2022-09-19","objectID":"/nextresponder/:0:0","tags":["iOS","事件响应链"],"title":"NextResponder","uri":"/nextresponder/"},{"categories":["事件响应链"],"content":"视图的nextResponder是谁？ UIView 若视图是控制器的根视图，则其nextResponder为控制器对象；否则，其nextResponder为父视图。 以上说法一般情况下是没问题的，但是对于控制器添加子控制器的场景确是不符合的。 仅仅把控制器的视图添加到父视图上，则视图的下一个响应者就是父视图，而不是控制器。 unaddchildcontroller 把子控制器也添加到父控制器上，子控制器的下一响应者是父控制器的跟视图，而不是父控制器。 addchildcontroller ","date":"2022-09-19","objectID":"/nextresponder/:1:0","tags":["iOS","事件响应链"],"title":"NextResponder","uri":"/nextresponder/"},{"categories":["事件响应链"],"content":"推荐 iOS触摸事件全家桶 ","date":"2022-09-19","objectID":"/nextresponder/:2:0","tags":["iOS","事件响应链"],"title":"NextResponder","uri":"/nextresponder/"},{"categories":[],"content":"我 符现超，菜鸡程序员一枚 ","date":"2022-08-26","objectID":"/about/whoami/:1:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":[],"content":"技术栈 有向全栈发展的想法，正在修行中 Objective-C Swift Lua JavaScript ReactNative Shell 会点C++，喜欢Rust、Flutter, 学习中… ","date":"2022-08-26","objectID":"/about/whoami/:2:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":[],"content":"兴趣爱好 喜欢热血系和治愈系动漫 喜欢收藏各种工具 爱瞎折腾 喜欢尝试新技术 喜欢想办法解决项目中的问题 ","date":"2022-08-26","objectID":"/about/whoami/:3:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":[],"content":"优缺点 处女座，有点小强迫症；乡下人，踏实稳重，能吃苦； ","date":"2022-08-26","objectID":"/about/whoami/:4:0","tags":[],"title":"自我简介","uri":"/about/whoami/"},{"categories":["混编"],"content":"CocoaPods组件中Swift与Objective-C混编","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"前言 本文是笔者在解决混编时的一些记录，有些东西可能已经发生了变化。而且由于只是随手记录，写的比较乱，各位看官见谅~~~ 笔者负责的业务是以pod模块的形式存在于工程中的，所以以下调研的方案只针对于pod中的混编场景，在MM主工程混编几乎是无缝，没什么可说的。。。 推荐大家浏览下 CocoaPods（podfile \u0026 podspec） 的 API，没几个，花费不了几分钟，但是却能帮助大家少踩很多的坑，一本万利~ ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:1:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"前期方案 暂时采用折中方案，把Swift独立成一个pod，然后业务pod再引用Swift pod。目的是减少依赖，避免引用不规范的repo。 如果打算在同一pod中混编，只要把你依赖的库都支持module即可，而且需要修改一下你们引用外部repo头文件的形式，比如 #import \"SDWebImage.h\" 改为 #import \u003cSDWebImage/SDWebImage.h\u003e 在MM主工程中创建个新的Swift文件（空文件即可），让Xcode自动生成一个bridge-header，目的是营造一个Swift环境（之前一直想不修改主工程而只在pod中营造，但是很遗憾，最后以失败告终）； 由于混编pod中依赖的repo需要支持module，但是MM中的pod水平参差不齐，大部分都没有支持module，这就限制我们在业务pod中混编时编译失败。而让pod一下子都支持module是一个不太现实的要求，所以我们暂时采用了一种折中的方案； 把Swift单独放一个pod中去，让Swift尽量少的依赖其他repo，然后业务pod再依赖Swift repo来调用Swift代码； ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:2:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"踩坑记录 pod中不支持bridging-header，所以混编pod中要想引用OC类，pod需要支持module 混编的Swift库需要打成framework形式才可以编译成功，比如RxCocoa、PromiseKit 限于苹果本身机制和现有二进制方案实现问题，不支持 :modular_headers =\u003e true，所以使用:modular_headers =\u003e true 时临时需要添加参数:use_source_code =\u003e true，切换为代码编译； Swift与OC混编的pod所依赖的库需要改为动态库，比如ZDFlexLayout内部为Swift与OC混编的，依赖了Yoga，需要把Yoga编为动态库。 报错如下图 undefine_symbol 实际操作 跨模块引用时需要把要暴露给外部的类或者函数的访问权限设置为 public，并标记为 @objc，同时需要继承自NSObject类 pod 中引用其他pod都是通过 @import 语法 Swift依赖的repo需要module化， 有3种方式： i: 在podfile中让所有的repo开启modular: use_modular_headers! ii: 只给某几个repo开启modular，举个例子：pod 'SDWebImage', :modular_headers =\u003e true iii: 让repo自己开启module支持，需要在podspec中修改下设置：spec.pod_target_xcconfig = { 'DEFINES_MODULE' =\u003e 'YES' } , 这个设置不管你开不开启modular开关，都会自动创建module 如果podspec中不设置DEFINES_MODULE=true，默认是不会生成module的，哪怕你在podspec中设置了module_map也不行，除非你在podfile中手动开启modular_hear你自己的modulemap才会生效 如果你手动创建了modulemap就不要设置DEFINES_MODULE=true了，因为笔者发现开启DEFINES_MODULE后它还会自己再生成一份xxx-umbraller文件。 推荐让CocoaPods帮我们创建modulemap，如非你特别懂modulemap，不建议自己手动创建。 只需要把Swift用到的OC类放到umbrella中（后面说控制方法） ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:3:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"同一混编pod内OC调用Swift 在头文件中引入 #import \u003cmodule-name\u003e-Swift.h\"，然后就可以调用Swift类了 oc_import_swift ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:4:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"同一混编pod内Swift调用OC 同一pod中，把oc类引用放入umbrella中（默认就有了），然后需要这个文件能被找到。 一种方式是修改此文件的membership为public，目的是为了把它移到public header中去（静态库形式pod中的文件默认都是project的，动态库形式的pod才会区分public、private、project） 修改起来成本比较高，不推荐 member_ship header 第二种方式是把这个文件的路径包含搜索路径中，可以通过设置podspec中的 spec.header_dir参数 header_dir 可以是任意名字, 笔者一般会设置为./，即当前文件夹 这个选项也不是万能的，你会发现就算设置了这个选项，也会出现报错的问题。建议业务方的pod如无必要，把类都放到private_header_files 中，减少umbrella 中的头文件数量。 如下设置 header_dir_set 静态库中的import需要是全路径的，而动态库中的搜索路径会被flatten，所以动态库不会出现此问题 不过这里有点需要注意的是，设置 header_dir 后需要同时设置 module_name，否则 modulename 默认会取 header_dir 的值。。。 其实官方文档上都有提到，惭愧 module_name ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:5:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"解惑 为什么能够混编？ 能够互相调用的类都需要继承NSObject Swift中的类和Objective-C中的类底层元数据（class metadata）是共用的 // objc4-818.2 // objc-runtime-new.h typedef struct objc_class *Class; typedef struct objc_object *id; struct objc_object { private: isa_t isa; // ... }; struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // ... }; struct swift_class_t : objc_class { uint32_t flags; uint32_t instanceAddressOffset; uint32_t instanceSize; uint16_t instanceAlignMask; uint16_t reserved; uint32_t classSize; uint32_t classAddressOffset; void *description; // ... void *baseAddress() { return (void *)((uint8_t *)this - classAddressOffset); } }; 1. XCode9 \u0026 Cocopoads 1.5 之后，不是已经支持把Swift编译为静态库了吗，为什么会报错呢？ 第三方库对于把混编pod编译为静态库支持的不好，这不是苹果的锅，而是三方库未进行及时的适配，像Kingfisher、RxCocoa都有问题 这两个库笔者已经提了pr 来解决这个问题，现已合入主分支，从 RxCocoa 6.1.0、Kingfisher 6.1.0 开始都已支持编译为静态库; RxCocoa #2281 Kingfisher #1608 2. 为什么改为动态库就可以正常编译通过了？ 静态库需要使用绝对路径引用，而动态库强制把头文件平铺了，所以动态库能引到，静态库引不到 可以自己验证一下，改成 #import \"\u003cmodule-name\u003e/xxxx.h\" 之后你再编译一下 3. 为什么设置 header_dir 编译就不报错了？ 默认情况下使用的是普通的header ，设置header_dir之后，pod会以header_dir为名称创建一个文件夹，然后把所有public出来的头文件引用放里面，umbrella引用头文件的时候其实指向的都是这里； 见源码 header_dir_code 4. pod中没有bridging-header为什么Swift还能引用Objective-C类？ pod中umbrella文件其实就相当于是主工程中的bridging-header。 5. 为什么Xcode生成的hmap对我们的项目并没起到什么作用？ 上面已经提到静态库的形式下我们的类文件的membership是project，hmap生成的是#import \"xx.h\"形式的引用路径的cache，而我们通常引用库文件的方式为#import \u003cA/B.h\u003e，这就导致我们的引用根本就没办法命中hmap中的映射缓存（pcm），所以最终还是会走search_path的查找逻辑。而且由于Xcode中的USE_HEADERMAP设置默认是开启的，Xcode在编译期还会自动创建对我们用处不大的hmap，而这个过程间接拖慢了我们的编译速度。 6. public、private、project区别 Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction. Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they’re not supposed to use them. Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you. Project和Private的权限或者说是作用基本一致，都是私有化的一种方式，只是Project权限的头文件是不会放到编译产物中的，注意说的是头文件，而Private头文件会放到编译产物中，只是告诉编译器不要暴漏给外界。CocoaPods是通过Pods-\u003eHeaders-\u003ePublic/Private目录管理头文件的引用，来控制对某一文件的访问权限的。 ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:6:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"推荐设置 podspec中在不指定private_header_files或project_header_files的时候source_files路径下的文件默认全都是public的，而public的头文件默认都会放到umbrella中，这样很容易导致umbrella中头文件爆炸，尤其是业务pod（比如我们的直播业务有2300多个头文件），特别影响编译速度。 解决办法：把那些暴露给swift的头文件放到public_header_files中，其他的头文件则默认变成project类型。或者是把全部头文件默认指定为private_header_files或project_header_files，然后把需要公开的放到public_header_files中，尽量减少umbrella中头文件的数量。 贴一下供参考的Swift podspec，请按需修改 Pod::Spec.new do |spec| spec.name = \"foo\" spec.version = \"0.0.1\" spec.summary = \"foo\" spec.description = \u003c\u003c-DESC 我是一只小柯基 DESC spec.homepage = \"https://foo/bar/abc\" spec.license = \"MIT\" spec.platform = :ios, \"12.0\" spec.source = { :git =\u003e \"https://foo/bar/abc.git\", :tag =\u003e \"#{spec.version}\" } spec.swift_versions = ['5.1'] publicHeaders = Dir[\"Source/Room/PublicHeaders/*.h\"] privateHeaders = Dir[\"Source/Room/**/*.{h}\"] - publicHeaders spec.source_files = 'Source/Room/**/*.{h,m,swift}' spec.public_header_files = publicHeaders # 下面这行可有可无，设置的话会放到private中，不设置则等价于 `spec.project_header_files = privateHeaders`，会放到project中 # spec.private_header_files = privateHeaders spec.module_name = spec.name spec.header_dir = \"./\" spec.pod_target_xcconfig = { 'DEFINES_MODULE' =\u003e 'YES', } spec.dependency 'RxCocoa' spec.dependency 'Cartography', '~\u003e 4.0.0' spec.dependency 'ZDFlexLayoutKit' end CocoaPods 骚操作： 用踩坑中提到的RxCocoa做例子，为了编译成功，我们需要把它指定为动态库，而其他的保持不变，这种需求我们可以在 pre_install 阶段动态修改编译模式：把dynamic_framework数组中的repo编译为framework，其他未指定的默认还是静态库。 pre_install do |installer| #以framework形式存在的pod dynamic_frameworks = ['RxSwift', 'RxCocoa', 'RxRelay'] Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if dynamic_frameworks.include?(pod.name) def pod.build_type; Pod::BuildType.dynamic_framework end end end end pre_install do |installer| #以静态库形式存在的pod static_library = ['Masonry', 'SDWebImage'] Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if static_library.include?(pod.name) def pod.build_type; Pod::BuildType.static_library end end end end ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:7:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["混编"],"content":"参考 importing_objective-c_into_swift importing_swift_into_objective-c https://www.rubydoc.info/gems/cocoapods-core/Pod/BuildType https://github.com/CocoaPods/CocoaPods/pull/7724 PromiseKit.podspec 6.15.3 从预编译的角度理解Swift与Objective-C及混编机制 ","date":"2020-11-04","objectID":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/:8:0","tags":["iOS","swift"],"title":"Swift与Objective-C混编","uri":"/swift%E4%B8%8Eobjective-c%E6%B7%B7%E7%BC%96/"},{"categories":["CI"],"content":"Jenkins踩坑记录","date":"2020-04-18","objectID":"/jenkins_note/","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"1、homebrew安装的Jenkins无法通过IP访问 这是因为brew把jenkins启动的监听地址设置为了127.0.0.1，改为0.0.0.0即可实现访问 jenkins配置所在路径：~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist jenkins_config_address ","date":"2020-04-18","objectID":"/jenkins_note/:1:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"2、jenkins脚本中无法使用pod、brew等命令 需要在脚本开头添加 -l #!/usr/bin/env sh -l export LANG=en_US.UTF-8 export LANGUAGE=en_US.UTF-8 export LC_ALL=en_US.UTF-8 ","date":"2020-04-18","objectID":"/jenkins_note/:2:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"3、构建中生成的数据无法传递给构建阶段 解决：把数据写入文件，然后通过Jenkins中的FILE获取 写文件 # 创建下载地址日志文件 download_urls=\"${EXPORT_DIR}/DownLoadURLs.log\" if [[ ! -f ${download_urls} ]]; then touch ${download_urls} fi # 清空文件 echo \"\" \u003e ${download_urls} echo \"包名称：${application_name} \u003cbr/\u003e\" \u003e\u003e ${download_urls} 读文件 Jenkins打包结果：\u003cbr/\u003e\u003chr/\u003e ${FILE, path=\"${PACKAGE_DIR}/${branch}/Package/DownLoadURLs.log\"} \u003cbr/\u003e\u003chr/\u003e 项目名称：$PROJECT_NAME\u003cbr/\u003e\u003chr/\u003e 构建编号：$BUILD_NUMBER\u003cbr/\u003e\u003chr/\u003e 构建状态：$BUILD_STATUS\u003cbr/\u003e\u003chr/\u003e 触发原因：${CAUSE}\u003cbr/\u003e\u003chr/\u003e 构建日志地址：\u003ca href=\"${BUILD_URL}console\"\u003e${BUILD_URL}console/\u003c/a\u003e\u003cbr/\u003e\u003chr/\u003e 构建地址：\u003ca href=\"$BUILD_URL\"\u003e$BUILD_URL\u003c/a\u003e\u003cbr/\u003e\u003chr/\u003e 变更集:${JELLY_SCRIPT,template=\"html\"}\u003cbr/\u003e\u003chr/\u003e ","date":"2020-04-18","objectID":"/jenkins_note/:3:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"4、自动输入 比如自动输入 Y # 输入一次 echo Y # 输入任意次 yes Y ","date":"2020-04-18","objectID":"/jenkins_note/:4:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"5、填充密码 使用echo 加 -S 解决 echo \"密码\" | sudo -S gem install cocoapods ","date":"2020-04-18","objectID":"/jenkins_note/:5:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"6、从构建日志中过滤日志 比如修改构建名称和构建描述 # 构建名称（编号 + 分支 + 当前登录用户） ${BUILD_NUMBER}_${branch##*/}_${BUILD_LOG_MULTILINE_REGEX,showTruncatedLines=\"false\", maxMatches=1,regex=\"Started by user.*\"} # 从构建日志中提取描述 ${BUILD_LOG_MULTILINE_REGEX,showTruncatedLines=\"false\", regex=\"BID:.*|Version:.*|commitId:.*\"} 获取登录用户名的另一种方式，需要打开Set jenkins user build variables #${BUILD_NUMBER}_${PROJECT_BRANCH}_${BUILD_USER} ","date":"2020-04-18","objectID":"/jenkins_note/:6:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"Jenkins插件推荐 插件镜像： http://mirror.esuni.jp/jenkins/updates/update-center.json Blue Ocean Pipeline Priority Sorter Plugin Extented Choice Parameter Plugin-In Git Parameter Plug-In List Git Branches Parameter Environment Injector Credentials Plugin CocoaPods Jenkins Integration Keychains and Provisioning Profiles Management Xcode Integration Safe Restart Plugin ","date":"2020-04-18","objectID":"/jenkins_note/:7:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"Shell Tips： 执行出错时自动执行后面的命令（||）： xcodebuild archive || echo \"执行失败\" 设置默认值：PROJECT_DIR=${project_path:-$WORKSPACE} #如果参数未设置取默认值 ","date":"2020-04-18","objectID":"/jenkins_note/:8:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["CI"],"content":"参考资料： Updating Homebrew’s “httpListenAddress” Default for Jenkins Shell 十三问 ","date":"2020-04-18","objectID":"/jenkins_note/:9:0","tags":["CI","jenkins"],"title":"Jenkins笔记","uri":"/jenkins_note/"},{"categories":["实现原理"],"content":"简析几个 Promise 开源库的实现 Promise思想的开源库其实有很多，这里仅简单分析下Bolts、PromiseKit、promises ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:0:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"一、 Bolts Facebook出品 BFTask原理： 每个BFTask自己都维护着一个任务数组，当task执行continueWithBlock:后（会生成一个新的BFTask），continueWithBlock:带的那个block会被加入到任务数组中，每当有结果返回时，会执行trySetResult:方法，这个方法中会拿到task它自己维护的那个任务数组，然后取出其中的所有任务block，然后遍历执行。 /// 内部维护的任务数组 @property (nonatomic, strong) NSMutableArray *callbacks; /// `continueWithBlock:`方法 - (BFTask *)continueWithExecutor:(BFExecutor *)executor block:(BFContinuationBlock)block cancellationToken:(nullable BFCancellationToken *)cancellationToken { // 创建一个新的`BFTaskCompletionSource`，创建它时，它里面会`new`一个`task`对象，最后`return`的也是这个`task` // 这个不是单例方法，所以此处创建的`task`是一个新对象 BFTaskCompletionSource *tcs = [BFTaskCompletionSource taskCompletionSource]; // (1) // 创建一个任务`block`，后面会把执行这个`block`的操作加入到数组中，当回调时会执行这个`block`里面的操作 // P.S. 下面附一张把这个block折叠后的图片 dispatch_block_t executionBlock = ^{ //(N.0) if (cancellationToken.cancellationRequested) { [tcs cancel]; return; } // 把当前类（`task`对象）作为参数进行回调 //(N.1) id result = nil; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wdeprecated-declarations\" if (BFTaskCatchesExceptions()) { @try { result = block(self); } @catch (NSException *exception) { NSLog(@\"[Bolts] Warning: `BFTask` caught an exception in the continuation block.\" @\" This behavior is discouraged and will be removed in a future release.\" @\" Caught Exception: %@\", exception); tcs.exception = exception; return; } } else { result = block(self); } #pragma clang diagnostic pop // 如果回调结果返回的是`BFTask`类型 if ([result isKindOfClass:[BFTask class]]) { // 下面`block`中的`task`就是上面的`result` id (^setupWithTask) (BFTask *) = ^id(BFTask *task) { //(N.3) if (cancellationToken.cancellationRequested || task.cancelled) { [tcs cancel]; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wdeprecated-declarations\" } else if (task.exception) { tcs.exception = task.exception; #pragma clang diagnostic pop } else if (task.error) { tcs.error = task.error; } else { tcs.result = task.result; } return nil; }; BFTask *resultTask = (BFTask *)result; /// 如果`continueWithBlock:`中的`block`回调返回的`task`是`complete`状态，则直接到 (N.3)，把任务的结果传递到上面新创建的那个`BFTask`对象的`result`属性中,否则就继续执行`continueWithBlock:`来监测任务状态 if (resultTask.completed) { setupWithTask(resultTask); //(N.2) } else { [resultTask continueWithBlock:setupWithTask]; //(N.4) } } else { tcs.result = result; } }; // 如果是未完成状态，则把操作加入到数组中，延后执行；否则就立即执行 BOOL completed; @synchronized(self.lock) { //(2.0) completed = self.completed; if (!completed) { // 把任务添加到数组中 [self.callbacks addObject:[^{ [executor execute:executionBlock]; } copy]]; } } if (completed) { //(2.1) [executor execute:executionBlock]; } return tcs.task; } ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:1:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"二、 PromiseKit 首先，让我们看看创建Promise的源码 + (instancetype)promiseWithResolver:(void (^)(PMKResolver))block { // (2) PMKPromise *this = [self alloc]; // (3) 初始化promise this-\u003e_promiseQueue = PMKCreatePromiseQueue(); this-\u003e_handlers = [NSMutableArray new]; @try { block(^(id result){ // (4) 立即开始原始任务（它传过去的参数还是一个`PMKResolver`类型的block，这个block会在PMKRejecter或者PMKFulfiller类型的block执行回调时执行） \"void (^PMKResolver)(id)\" if (PMKGetResult(this)) return PMKLog(@\"PromiseKit: Warning: Promise already resolved\"); PMKResolve(this, result); // (7) result为用户在`new:`方法中返回的数据结果,而this则是上面一开始时初始化的那个promise. 执行到这里后接下来会到(8),回调到(9)那个block,这个block中会遍历`handlers`数组中的`handler()` block, }); } @catch (id e) { // at this point, no pointer to the Promise has been provided // to the user, so we can’t have any handlers, so all we need // to do is set _result. Technically using PMKSetResult is // not needed either, but this seems better safe than sorry. PMKSetResult(this, NSErrorFromException(e)); } return this; } + (instancetype)new:(void(^)(PMKFulfiller, PMKRejecter))block { // (1) return [self promiseWithResolver:^(PMKResolver resolve) { id rejecter = ^(id error){ // (5-1) 失败的block if (error == nil) { error = NSErrorFromNil(); } else if (IsPromise(error) \u0026\u0026 [error rejected]) { // this is safe, acceptable and (basically) valid } else if (!IsError(error)) { id userInfo = @{NSLocalizedDescriptionKey: [error description], PMKUnderlyingExceptionKey: error}; error = [NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:userInfo]; } resolve(error); }; id fulfiller = ^(id result){ // (5-2) 成功的block if (IsError(result)) PMKLog(@\"PromiseKit: Warning: PMKFulfiller called with NSError.\"); resolve(result); // (6) 当用户执行`PMKFulfiller`类型的block时,会回调到这里,此方法执行(4)中的那个参数block,即执行(7) }; block(fulfiller, rejecter); // (5-3) 把成功和失败的block作为参数，执行回调原任务（e.g demo中的网络请求任务） }]; } static void PMKResolve(PMKPromise *this, id result) { void (^set)(id) = ^(id r){ // (9) handle回调执行(10) NSArray *handlers = PMKSetResult(this, r); for (void (^handler)(id) in handlers) handler(r); }; if (IsPromise(result)) { PMKPromise *next = result; dispatch_barrier_sync(next-\u003e_promiseQueue, ^{ id nextResult = next-\u003e_result; if (nextResult == nil) { // ie. pending [next-\u003e_handlers addObject:^(id o){ PMKResolve(this, o); }]; } else set(nextResult); }); } else set(result); // (8) } 调用new:方法时会调用promiseWithResolver:方法，在里面进行一些初始化promise的工作：创建了一个GCD并发队列和一个数组，并立即回调new:后面的那个参数block，即：立即执行，生成一个成功fulfiller和失败rejecter的block，这个block将由用户控制回调操作的时机。 下面看一下then的实现： - (PMKPromise *(^)(id))then { // 1 // 此处`then`本身就是一个block：（PMKPromise *(^then)(id param)），此方法类似于getter方法 // 返回一个`(PMKPromise *(^)(id))`类型的block，这个block执行后，返回一个PMKPromise // 下面整个都是一个then `block`，当执行then的时候会调用 `self.thenOn(dispatch_get_main_queue(), block)`，返回一个Promise类型的结果 return ^(id block){ return self.thenOn(dispatch_get_main_queue(), block); }; } - (PMKResolveOnQueueBlock)thenOn { return [self resolved:^(id result) { if (IsPromise(result)) return ((PMKPromise *)result).thenOn; if (IsError(result)) return ^(dispatch_queue_t q, id block) { return [PMKPromise promiseWithValue:result]; }; return ^(dispatch_queue_t q, id block) { // HACK we seem to expose some bug in ARC where this block can // be an NSStackBlock which then gets deallocated by the time // we get around to using it. So we force it to be malloc'd. block = [block copy]; return dispatch_promise_on(q, ^{ return pmk_safely_call_block(block, result); }); }; } pending:^(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolve)(id)) { if (IsError(result)) PMKResolve(next, result); else dispatch_async(q, ^{ resolve(pmk_safely_call_block(block, result)); // (11) }); }]; } - (id)resolved:(PMKResolveOnQueueBlock(^)(id result))mkresolvedCallback pending:(void(^)(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolver)(id)))mkpendingCallback { __block PMKResolveOnQueueBlock callBlock; __block id result; dispatch_sync(_promiseQueue, ^{ if ((result = _result)) // 有结果的情况下直接返回 retur","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:2:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"三、 Promises google出品 原理： 这个开源库的思路其实与BFTask很相似，每次promise执行then方法时都会创建一个新的promise对象，同时会创建一个观察者（block对象），这个观察者会持有这个新的promise，当（旧）promise对象fulfilled或者rejected的时候，会把fulfilled或者rejected拿到的value给新promise。 先看下promise的初始化方法: - (instancetype)initPending { self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self; } 首先进入一个单例dispatch_group_t中，为啥用dispatch_group_t呢？因为后面的then方法可以在其他队列处理，而且dispatch_group_t有同步队列的功能，后面作者每次初始化一个promise都会enter到dispatch_group_t中，fulfilled或者rejected时再leave。 接下来看看最重要同时也是精华所在的then方法： - (instancetype)initPending { // (0) self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self; } - (FBLPromise *)onQueue:(dispatch_queue_t)queue then:(FBLPromiseThenWorkBlock)work { return [self chainOnQueue:queue chainedFulfill:work chainedReject:nil]; // (1) } - (FBLPromise *)chainOnQueue:(dispatch_queue_t)queue chainedFulfill:(FBLPromiseChainedFulfillBlock)chainedFulfill chainedReject:(FBLPromiseChainedRejectBlock)chainedReject { // 首先new一个新的promise对象 FBLPromise *newPromise = [[FBLPromise alloc] initPending]; // (2) // 这个block其实就是抽离的一个方法，避免写重复代码。 // 当promise被fulfilled或者rejected时都会调用； // 结合下面方法block中的实现可以看出，如果thenBlock（chainedFulfill）存在，则先执行chainedFulfill这个block（其实就是map一下这个value值）重新生成一个value值（value值也可能不会变化，主要还得看map函数里有没有改变value）；接下来把这个重新赋值的value扔给resolverBlock，resolverBlock会把这个新的value给newPromise，newPromise会调用fulfilled方法，如果此时newPromise也有订阅者(被then过)，则就会把这个新value传递给下一个newNewPromise ... // 如果then的时候promise已经结束了，则直接把结果返回给订阅者,即调用thenBlock。 __auto_type resolver = ^(id __nullable value) { if ([value isKindOfClass:[FBLPromise class]]) { // (8) [(FBLPromise *)value observeOnQueue:queue fulfill:^(id __nullable value) { [newPromise fulfill:value]; } reject:^(NSError *error) { [newPromise reject:error]; }]; } else { [newPromise fulfill:value]; // (8) } }; [self observeOnQueue:queue fulfill:^(id __nullable value) { value = chainedFulfill ? chainedFulfill(value) : value; // (7) resolver(value); } reject:^(NSError *error) { id value = chainedReject ? chainedReject(error) : error; // (7) resolver(value); }]; return promise; } - (void)observeOnQueue:(dispatch_queue_t)queue fulfill:(FBLPromiseOnFulfillBlock)onFulfill reject:(FBLPromiseOnRejectBlock)onReject { @synchronized(self) { // (3) switch (_state) { // 默认的state，即待处理的事件 case FBLPromiseStatePending: { // 如果promise对象还没有观察者数组，new一个 // 这里为什么需要观察者数组呢？因为一个Promise可以被then很多次 if (!_observers) { _observers = [[NSMutableArray alloc] init]; } // 当事件被处理时会执行下面block __auto_type observer = ^(FBLPromiseState state, id __nullable resolution) { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ switch (state) { // (6) case FBLPromiseStatePending: break; case FBLPromiseStateFulfilled: onFulfill(resolution); break; case FBLPromiseStateRejected: onReject(resolution); break; } }); }; [_observers addObject:observer]; // (4) break; } // 当前promise已经结束 case FBLPromiseStateFulfilled: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onFulfill(self-\u003e_value); }); break; } // 当前promise已经结束 case FBLPromiseStateRejected: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onReject(self-\u003e_error); }); break; } } } } - (void)fulfill:(nullable id)value { if ([value isKindOfClass:[NSError class]]) { [self reject:(NSError *)value]; } else { @synchronized(self) { if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateFulfilled; _value = value; _pendingObjects = nil; for (FBLPromiseObserver observer in _observers) { observer(_state, _value); // (5) } _observers = nil; // 事件结束，leave group dispatch_group_leave(FBLPromise.dispatchGroup); } } } } - (void)reject:(NSError *)error { NSAssert([error isKindOfClass:[NSError class]], @\"Invalid error type.\"); if (![error isKindOfClass:[NSError class]]) { // Give up on invalid error type in Release mode. @throw error; // NOLINT } @synchronized(self) { if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateRejected; _error = error; _pendingObjects = nil; for (FBLPromiseObserver observer in ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:3:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"参考： iOS如何优雅的处理“回调地狱Callback hell”(一)——使用PromiseKit ","date":"2019-02-13","objectID":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/:4:0","tags":["iOS","promise"],"title":"Promise源码简析","uri":"/promise%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"探索block变量捕获的原理","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"探索block捕获外界变量的原理 在此之前先介绍一下block 基本语法： BlockSyntax Block Syntax // Block as a local variable returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; // Block as a property @property (nonatomic, copy) returnType (^blockName)(parameterTypes); // Block as a method parameter - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; // Block as an argument to a method call [someObject someMethodThatTakesABlock: ^returnType (parameters) {...}]; // Block as typedef typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; 对Object-C文件执行 xcrun -sdk iphonesimulator clang -fobjc-arc -fobjc-runtime=ios -rewrite-objc fileName.m 操作来获取伪代码，仅供技术探究。 先把__block_impl结构体拿出来放在最前面，最终block调用时都会被强转成这种类型，下面好多地方会用到。 struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; isa指针：指向一个类对象，在非GC模式下有三种类型：_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock； Flags：block的负载信息（引用计数和类型信息），按位存储； Reserved：保留变量； FuncPtr：指向block函数地址的指针。 descriptor：是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。 接下来进入正题： p.s：以下Objective-C的代码都处在ARC环境下 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:0:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"1、不加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; block(); } } 执行clang操作后的C++代码: // 定义block的结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSMutableArray *mutArr; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableArray *_mutArr, int flags=0) : mutArr(_mutArr) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 以下为调用`block`时执行的方法 // 此`mutArr`是在最初定义`block`时 为结构体传进去的局部变量`mutArr`的值 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // bound by copy:这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。 NSMutableArray *mutArr = __cself-\u003emutArr; // bound by copy ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)mutArr, sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } // block的copy函数 static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; NSMutableArray *mutArr = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); // 可以看出block变量实际上就是一个指向结构体`__main_block_impl_0`的指针,而结构体的第三个元素是局部变量mutArr的值 // 此处捕获的直接就是`mutArr`局部变量 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, mutArr, 570425344)); // 下面调用`block`的方法实质其实是: 指向结构体的指针`block`访问其`FuncPtr`元素(即,在定义block时为`FuncPtr`元素传进去的`__main_block_func_0`方法) ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:1:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"2、添加__block的情况: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { __block NSMutableArray *mutArr = [NSMutableArray array]; void(^block)() = ^{ [mutArr addObject:@2]; }; [mutArr addObject:@\"hello\"]; block(); } } 执行clang后的C++代码: // 由下面的代码可知: `__block`的作用就是定义一个新的结构体来包裹原来的变量 // 定义一个保存变量的结构体 （被__block标记的变量会被转化为这种格式的结构体对象） struct __Block_byref_mutArr_0 { void *__isa; __Block_byref_mutArr_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSMutableArray *mutArr; }; // block 结构体 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 包含捕获的局部变量的结构体指针 __Block_byref_mutArr_0 *mutArr; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_mutArr_0 *_mutArr, int flags=0) : mutArr(_mutArr-\u003e__forwarding) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 在block内部对`mutArr`操作 (block回调时执行的函数) static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 拿到 包含捕获的局部变量 的结构体指针 __Block_byref_mutArr_0 *mutArr = __cself-\u003emutArr; // bound by ref // 通过上面的结构体指针一步步拿到`mutArr`数组 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr-\u003e__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)((NSNumber *(*)(Class, SEL, int))(void *)objc_msgSend)(objc_getClass(\"NSNumber\"), sel_registerName(\"numberWithInt:\"), 2)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emutArr, (void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emutArr, 8/*BLOCK_FIELD_IS_BYREF*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; // 这里可以看到结构体中的 __forwarding 指针其实指向的就是其自身 __attribute__((__blocks__(byref))) __Block_byref_mutArr_0 mutArr = {(void*)0,(__Block_byref_mutArr_0 *)\u0026mutArr, 33554432, sizeof(__Block_byref_mutArr_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\"))}; // 与不加__block差不多,`block`变量还是一个指向`__main_block_impl_0`结构体的指针,区别在于第三个参数变了. 第三个参数是包含局部变量`mutArr`的结构体指针. // 即block捕获的是持有`mutArr`的结构体指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, (__Block_byref_mutArr_0 *)\u0026mutArr, 570425344)); // 在block外部对`mutArr`操作 // // 此处对`mutArr`数组对象进行操作,获取`mutArr`也是和`block`内部的获取方法一样, // 都是通过持有`mutArr`的结构体一步步获取到`mutArr`数组, // // 这里要经过 __forwarding 来获取`mutArr`的原因是： // __block 标记的变量有可能被copy到堆上，__forwarding 的作用就是在被copy到堆上时修改指向，使栈和堆上的 __forwarding 都指向堆上的那个副本，这样就保证了block内外操作的都是同一份内存。 // 具体的copy实现可以参见下面的 `_Block_byref_copy` 函数 // // 所以,在block内外,操作的都是同一个`mutArr`对象.都是通过包含`mutArr`对象的`__Block_byref_mutArr_0`结构体对其进行间接操作处理的 // 这也就是为什么添加`__block`后还能改变原来的对象的原因 // // PS: 当我们用__block 标记一个变量以后，当我们用到这个变量时都不是直接使用这个变量了，而是变成了通过`__Block_byref`来操作这个变量 ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(mutArr.__forwarding-\u003emutArr), sel_registerName(\"addObject:\"), (id)(NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_b07809_mi_0); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; // __block 变量被copy到堆上时的具体实现 static struct Block_byref *_Block_byref_copy(const void *arg) { struct Block_byref *src = (struct Block_byref *)arg; if ((src-\u003eforwarding-","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:2:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"3、静态变量: #import \u003cFoundation/Foundation.h\u003e int main(int argc, char *argv[]) { @autoreleasepool { static NSString *myString = @\"111\"; void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang之后的C++代码： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; // 注意这里, 外面的静态变量被捕获了,不过捕获的是对象的指针 NSString **myString; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString **_myString, int flags=0) : myString(_myString) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString **myString = __cself-\u003emyString; // bound by copy // 通过对`myString`指针进行取值操作(*myString),拿到 myString ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)(*myString), sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_1); // 由下面的伪代码可以看出,由于`myString`是指针,所以通过`*`操作来获取到原来的变量, // 然后再对其进行重新赋值操作 (*myString) = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_121621_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_2, (*myString)); } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)\u0026dst-\u003emyString, (void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-\u003emyString, 3/*BLOCK_FIELD_IS_OBJECT*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; static NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_0; // block捕获的是静态变量的指针 void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA, \u0026myString, 570425344)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_dac7fc_mi_3); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:3:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"4、全局变量: #import \u003cFoundation/Foundation.h\u003e NSString *myString = @\"111\"; int main(int argc, char *argv[]) { @autoreleasepool { void(^block)() = ^{ [myString stringByAppendingString:@\"222\"]; myString = @\"444\"; NSLog(@\"%@\", myString); }; [myString stringByAppendingString:@\"333\"]; block(); } } clang操作执行之后的C++伪代码: NSString *myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_0; // block结构体并没有捕获全局变量 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = \u0026_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { // 下面三个函数都是在用到全局变量`myString`的时候直接从内存去获取 ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_1); myString = (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_2; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_3, myString); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; // main函数 int main(int argc, char *argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; void(*block)() = ((void (*)())\u0026__main_block_impl_0((void *)__main_block_func_0, \u0026__main_block_desc_0_DATA)); ((NSString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)myString, sel_registerName(\"stringByAppendingString:\"), (NSString *)\u0026__NSConstantStringImpl__var_folders_4t_ldgq93v932g220vwkl7c1fk40000gn_T_BlockTest_938f32_mi_4); ((void (*)(__block_impl *))((__block_impl *)block)-\u003eFuncPtr)((__block_impl *)block); } } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:4:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"总结: 局部变量： 不加__block: block内部捕获的是局部变量的值，而且如果局部变量是数值类型（比如int）不会有__main_block_copy_0 和 __main_block_dispose_0 两个函数，如果是引用类型（比如NSArray）则会有这个函数，说明对于值类型变量是直接定义新变量并赋值相同，对于引用类型变量是定义一个新变量并copy这个对象的指针。 添加__block: 原来的局部变量会被放入到一个__Block_byref_变量名_0类型的结构体中，然后block内部当捕获局部变量时其实是捕获的是这个结构体的指针，当获取原来的局部变量时(不管是在block内还是block外)，其实都是通过这个结构体或者这个结构体指针来拿到原来的局部变量再进行操作的。这也就是为什么添加__block后可以对block内捕获的局部变量进行重新赋值等操作。 静态变量： block直接捕获的是静态变量的指针，前后都是对指针进行操作。 全局变量（或 全局静态变量）： block并没有捕获变量，而是在结构体的执行方法中直接使用了全局变量，是在执行时才去取值，一直都是获取变量的最新值。而且细心点我们可以发现，对于没有捕获全局变量的block中也没有__main_block_copy_0 和 __main_block_dispose_0 两个函数（用于在调用前后修改相应变量的引用计数），即没有发生copy操作。 其他 ARC环境下：在单独声明block的时候，block还是会在栈上的；当block作为参数返回的时候，block也会自动被移到堆上；在ARC下，只要指针过一下strong指针，或者由函数返回都会把block移动到堆上。 __main_block_copy_0 中的 _Block_object_assign 函数相当于retain实例方法，使 block 的成员变量持有捕获到的对象。 __main_block_dispose_0 中的 _Block_object_dispose 函数相当于 release 实例方法，释放 block 的成员变量持有的对象。 Objective-C 中的3种block： __NSStackBlock__、__NSMallocBlock、__NSGloballBlock 会在下面的情况下出现： 条件 ARC MRC 捕获外部变量 __NSStackBlock__ __NSMallocBlock__ __NSStackBlock__ 未捕获外部变量 __NSGlobalBlock__ __NSGlobalBlock__ 在 ARC 中，捕获了外部变量的block的类型会是__NSStackBlock__ 或者 __NSMallocBlock__，如果 block 被赋值给了某个变量，在这个过程中会执行_Block_copy，将原有的 __NSStackBlock__ 变成 __NSMallocBlock__；但是如果 block 没有被赋值给某个变量，那它的类型就是__NSStackBlock__；没有捕获外部变量的 block 的类则是 __NSGlobalBlock__ ，既不在栈上，也不在堆上，它类似于 C 语言函数一样，会在代码段中。 在MRC中，捕获了外部变量的 block 的类会是__NSStackBlock__，放置在栈上；没有捕获外部变量的 block 与 ARC 环境下的情况是相同的，类型是__NSGlobalBlock__，放置在代码段中。 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:5:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"推荐文章： 比我写的好 Block本质 ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:6:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["实现原理"],"content":"参考文章: 谈Objective-C Block的实现 iOS中的block是如何持有对象的 深入分析Objective-C block、weakself、strongself实现原理 block-copy ","date":"2018-08-17","objectID":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/:7:0","tags":["iOS","block"],"title":"Block捕获原理探究","uri":"/block%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"categories":["Tips"],"content":"代码技巧","date":"2018-07-11","objectID":"/codetips/","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"1. GNU-C的赋值扩展 即使用({...})的形式。这种形式的语句可以类似很多脚本语言，在顺次执行之后，会将最后一次的表达式的值作为返回值。 注意：这个不是懒加载 RETURN_VALUE_RECEIVER = {( // do whatever you want ... RETURN_VALUE; // 返回值 )}; REMenu 这个开源库中就使用了这种语法，如下： _titleLabel = ({ UILabel *label = [[UILabel alloc] initWithFrame:titleFrame]; label.isAccessibilityElement = NO; label.contentMode = UIViewContentModeCenter; label.textAlignment = (NSInteger)self.item.textAlignment == -1 ? self.menu.textAlignment : self.item.subtitleTextAlignment; label.backgroundColor = [UIColor clearColor]; label.autoresizingMask = UIViewAutoresizingFlexibleWidth; label; }); 使用这种语法的其中一个优点是结构鲜明紧凑，而且由于不用担心块里面的变量名污染外面变量名的问题。 ","date":"2018-07-11","objectID":"/codetips/:1:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"2. case语句中使用范围表达式 GCC对C11标准的语法扩展 比如，case 1 ... 5 就表示值如果在 1~5 的范围内则满足条件。 这里，省略号 ... 就作为一个范围操作符，其左右两个操作数之间至少要用一个空白符进行分割，如果写成 1...5 这种形式会引发词法解析错误。范围操作符的操作数可以是任一整数类型，包括字符类型。 另外，范围操作符的做操作数的值应该小于或等于右操作数，否则该范围表达式就会是一个空条件范围，永远不成立。 #include \u003cstdio.h\u003e int main(int argc, const char * argv[]) { int a = 1; const int c = 10; switch(a) { // 这条case语句是合法的，并且与case 1等效 case 1 ... 1: printf(\"a = %d\\n\", a); break; // 这条case语句中的范围操作符的左操作数⼤于右操作数， // 因此它是⼀个空条件范围，这条case语句下的逻辑永远不会被执⾏ case 2 ... 1: puts(\"Hello, world!\"); break; // 使⽤const修饰的对象也可作为范围操作符的操作数 case 8 ... c: puts(\"Wow!\"); break; default: break; } char ch = 'A'; switch(ch) { // 从'A'到'Z'的ASCII码范围 case 'A' ... 'Z': printf(\"The letter is: %c\\n\", ch); break; // 从'0'到'9'的ASCII码范围 case '0' ... '9': printf(\"The digit is: %c\\n\", ch); break; default: break; } } ","date":"2018-07-11","objectID":"/codetips/:2:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"3. __auto_type GCC对C11标准的语法扩展 #if defined(__cplusplus) #define var auto #define let auto const #else #define var __auto_type #define let const __auto_type #endif 例如： let block = ^NSString *(NSString *name, NSUInteger age) { return [NSString stringWithFormat:@\"%@ + %ld\", name, age]; }; let result = block(@\"foo\", 100); // no warning ","date":"2018-07-11","objectID":"/codetips/:3:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"4. 结构体的初始化 // 不加(CGRect)强转也不会warning GRect rect1 = {1, 2, 3, 4}; CGRect rect2 = {.origin.x=5, .size={10, 10}}; // {5, 0, 10, 10} CGRect rect3 = {1, 2}; // {1, 2, 0, 0} ","date":"2018-07-11","objectID":"/codetips/:4:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"5. 数组的下标初始化 const int numbers[] = { [1] = 3, [2] = 2, [3] = 1, [5] = 12306 }; // {0, 3, 2, 1, 0, 12306} 这个特性可以用来做枚举值和字符串的映射 typedef NS_ENUM(NSInteger, Type){ Type1, Type2 }; const NSString *TypeNameMapping[] = { [Type1] = @\"Type1\", [Type2] = @\"Type2\" }; 又如 UITableView+FDIndexPathHeightCache中的例子： // All methods that trigger height cache's invalidation SEL selectors[] = { @selector(reloadData), @selector(insertSections:withRowAnimation:), @selector(deleteSections:withRowAnimation:), @selector(reloadSections:withRowAnimation:), @selector(moveSection:toSection:), @selector(insertRowsAtIndexPaths:withRowAnimation:), @selector(deleteRowsAtIndexPaths:withRowAnimation:), @selector(reloadRowsAtIndexPaths:withRowAnimation:), @selector(moveRowAtIndexPath:toIndexPath:) }; for (NSUInteger index = 0; index \u003c sizeof(selectors) / sizeof(SEL); ++index) { SEL originalSelector = selectors[index]; SEL swizzledSelector = NSSelectorFromString([@\"fd_\" stringByAppendingString:NSStringFromSelector(originalSelector)]); Method originalMethod = class_getInstanceMethod(self, originalSelector); Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); } ","date":"2018-07-11","objectID":"/codetips/:5:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"6. 自带提示的keypath宏 #define keypath2(OBJ, PATH) \\ (((void)(NO \u0026\u0026 ((void)OBJ.PATH, NO)), # PATH)) ","date":"2018-07-11","objectID":"/codetips/:6:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"7. 逗号表达式 逗号表达式取后值，但前值的表达式参与运算，可用void忽略编译器警告 int a = ((void)(1+2), 2); // a == 2 于是上面的keypath宏的输出结果是#PATH也就是一个c字符串 ","date":"2018-07-11","objectID":"/codetips/:7:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"8. C函数重载标示符 RTRootNavigationController 中有用到这个技巧 __attribute((overloadable)) NSInteger ZD_SumFunc(NSInteger a, NSInteger b) { return a + b; } __attribute((overloadable)) NSInteger ZD_SumFunc(NSInteger a, NSInteger b, NSInteger c) { return a + b + c; } ","date":"2018-07-11","objectID":"/codetips/:8:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"9. 参数个数 // 最多支持10个参数 #define COUNT_PARMS2(_a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8, _a9, _a10, RESULT, ...) RESULT #define COUNT_PARMS(...) COUNT_PARMS2(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) int count = COUNT_PARMS(1,2,3,4,5,6); // 预处理时count == 6 ","date":"2018-07-11","objectID":"/codetips/:9:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"10. 同名全局变量或者全局函数共存 // 下面二者可以并存 NSDictionary *ZDInfoDict = nil; __attribute__((weak)) NSDictionary *ZDInfoDict = nil; ","date":"2018-07-11","objectID":"/codetips/:10:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"11. 偷梁换柱 class Test { dynamic func foo() { print(\"bar\") } } extension Test { @_dynamicReplacement(for: foo()) func new_foo() { print(\"bar new\") foo() // calls previous implementation } } Test().foo() // bar new 有2点需要说明： 标注dynamic关键字 在工程中运行，playground不支持 ","date":"2018-07-11","objectID":"/codetips/:11:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"12. 移花接木 @_silgen_name(\"backtrace\") internal func swift_backtrace(_ callstacks: UnsafeMutableRawPointer, _ counts: Int) -\u003e Int @_silgen_name(\"backtrace_symbols\") internal func swift_backtrace_symbols(_ callstacks: UnsafeRawPointer, _ counts: Int) -\u003e UnsafeMutablePointer\u003cUnsafePointer\u003cCChar\u003e\u003e? //------------------------------------------------ static func callstack() -\u003e [String] { var callstack = [UnsafeMutableRawPointer?](repeating: nil, count: 128) let frames = swift_backtrace(\u0026callstack, callstack.count) var callstackArr: [String] = [] if let symbols = swift_backtrace_symbols(\u0026callstack, frames) { for frame in 0..\u003cframes { let symbol = String(cString: symbols[frame]) callstackArr.append(symbol) } free(symbols) os_log(\"堆栈信息 =\u003e %@\", log: .apmLog, type: .info, callstackArr) } return callstackArr } ","date":"2018-07-11","objectID":"/codetips/:12:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"13. Swift类名解析 # xcrun swift-demangle _TtC11NewWolfKill22WKRoomControlMenuModel $ xcrun swift-demangle \u003cyour-mangled-symbol\u003e ","date":"2018-07-11","objectID":"/codetips/:13:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"14. 队列校验 methodThatCallsBackOnMain(completion: { result in // 确保在主队列中调用 dispatchPrecondition(.onQueue(.main)) // process `result` // ... }) ","date":"2018-07-11","objectID":"/codetips/:14:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"15. 指针调用Swift函数 https://github.com/apple/swift/issues/70630 public class Printable { public init (from sender : String) { print (\"Hello from \\(sender)!\") } public init (from sender : String, as name : String = \"Bastie\") { // 🆘 in result of init with one parameter unusable default value \"Bastie\" from init method print (\"Hello from \\(name)?\") } } let fn = Printable.init(from:as:) let _ = fn(\"Sebastian\") // or let _ = Printable.init(from:as:)(\"Sebastian\") ","date":"2018-07-11","objectID":"/codetips/:15:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"16. 使用map简化代码 https://github.com/ReactiveX/RxSwift/pull/2549 重构前： let disposable: Disposable if let onDisposed = onDisposed { disposable = Disposables.create(with: onDisposed) } else { disposable = Disposables.create() } 重构后： let disposable: Disposable = onDisposed.map( Disposables.create(with:) ) ?? Disposables.create() ","date":"2018-07-11","objectID":"/codetips/:16:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"17. Assert assert会导致程序退出，下面这种方式不会使程序退出而只是让IDE断在指定位置，类似于打断点那种效果 // 适用于所有架构 __builtin_debugtrap() 如果是模拟器，可以使用内联汇编的方式 asm(\"int3\") 如果是win平台，可以用 __debugbreak() 贴段样例： // MARK: - ZDAssert #if DEBUG #ifndef ZDAssert #define ZDAssert(condition, format, ...) do { \\ _Pragma(\"clang diagnostic push\") \\ _Pragma(\"clang diagnostic ignored \\\"-Wobjc-literal-conversion\\\"\") \\ if (condition) break; \\ if (format) printf(\"\\n%s\\n\\n\", [[NSString stringWithFormat:format, ##__VA_ARGS__] UTF8String]); \\ _Pragma(\"clang diagnostic pop\") \\ __builtin_debugtrap(); \\ } while(0); #endif #else #ifndef ZDAssert #define ZDAssert(condition, format, ...) #endif #endif 这里建议加上一个条件–只在调试期间起作用，因为在非调试阶段执行到这个trap程序会挂掉，代码如下： import Darwin // See http://developer.apple.com/library/mac/#qa/qa1361/_index.html @objc public class func isDebuggerAttached() -\u003e Bool { var info = kinfo_proc() var mib = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()] var size = MemoryLayout\u003ckinfo_proc\u003e.stride let junk = sysctl(\u0026mib, u_int(mib.count), \u0026info, \u0026size, nil, 0) assert(junk == 0) let isDebuggerAttaced = info.kp_proc.p_flag \u0026 P_TRACED != 0 return isDebuggerAttaced } ","date":"2018-07-11","objectID":"/codetips/:17:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"18. 保证对象的生命周期 Swift withExtendedLifetime() var owningReference = Instance() ... withExtendedLifetime(owningReference) { dosomething(...) } // Assuming: No stores to owned occur for the dynamic lifetime of // the withExtendedLifetime invocation. Objective-C 在 Objective-C ARC 中你可以使用 __attribute__((objc_precise_lifetime)) 或者 NS_VALID_UNTIL_END_OF_SCOPE 来标注变量以达到类似的效果。 ","date":"2018-07-11","objectID":"/codetips/:18:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"19. 区间判断 判断某一个值x是否在区间[min, max]内 第一个 (x - minx) 如果 x \u003c minx 的话，得到的结果 \u003c 0 ，即高位为 1，第二个判断同理，如果超过范围，高位也为 1，两个条件进行比特或运算以后，只有两个高位都是 0 ，最终才为真 if (( (x - minx) | (maxx - x) ) \u003e= 0) ... ","date":"2018-07-11","objectID":"/codetips/:19:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"20. 通过异或混淆key 通过异或的方式（字符串正常会进入常量区，但是通过异或的方式编译器会直接换算成异步结果） #define ENCRYPT_KEY 0xAC static NSString * AES_KEY(){ unsigned char key[] = { (ENCRYPT_KEY ^ 'd'), (ENCRYPT_KEY ^ 'e'), (ENCRYPT_KEY ^ 'm'), (ENCRYPT_KEY ^ 'o'), (ENCRYPT_KEY ^ '_'), (ENCRYPT_KEY ^ 'A'), (ENCRYPT_KEY ^ 'E'), (ENCRYPT_KEY ^ 'S'), (ENCRYPT_KEY ^ '_'), (ENCRYPT_KEY ^ '\\0'), }; unsigned char * p = key; while (((*p) ^= ENCRYPT_KEY) != '\\0') { p++; } return [NSString stringWithUTF8String:(const char *)key]; } ","date":"2018-07-11","objectID":"/codetips/:20:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"21. 另类的NSTimer破环方案 block结构中有个私有的函数：invoke。 @implementation NSTimer (ZDUtility) + (instancetype)zd_fireSecondsFromNow:(NSTimeInterval)delay block:(dispatch_block_t)block { return [self scheduledTimerWithTimeInterval:delay target:block selector:@selector(invoke) userInfo:nil repeats:NO]; } @end ","date":"2018-07-11","objectID":"/codetips/:21:0","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"参考 objc非主流代码技巧 Even Swiftier Objective-C 《C语言编程魔法书》 GCC中的弱符号与强符号 swift: SIL 30-tips-to-make-you-a-better-ios-developer C/C++调试技巧-debugbreak Swift 中的 ARC 机制: 从基础到进阶 C语言有什么奇淫技巧 iOS 摸鱼周报 #56 ","date":"2018-07-11","objectID":"/codetips/:21:1","tags":["iOS","tips"],"title":"代码技巧","uri":"/codetips/"},{"categories":["Tips"],"content":"CocoaPods笔记 ","date":"2016-11-21","objectID":"/cocoapods_tips/:0:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"1、The master repo requires CocoaPods 1.0.0 - (currently using 0.38.2) 参考：http://blog.cocoapods.org/Sharding/ 安装1.0之前（e.g：v0.38.2）版本的pod sudo gem install cocoapods -v 0.38.2 之后在执行pod setup时，由于pod工具已经升级到1.xx版本了，pod算法以及Specs库中的文件结构已经改变，所以它会默认拉取新版本的Specs库，这样就会出现旧版本pod新版本Specs库的情况，当执行pod install的时候会发生找不到xxx第三方库的情况。 解决此问题的方案是需要在Podfile中指定source源地址： source \"https://github.com/CocoaPods/Old-Specs\" 并把本地的Specs库切换到旧版本： cd ~/.cocoapods/repos/master/ git fetch origin master git checkout v0.32.1 最后，在执行pod install的时候需要添加上--no-repo-update标识，因为1.0之前的pod版本在执行pod install的时候会默认先更新升级本地Specs库文件。 以下2张图分别是旧版本的spec库和新版本spec库的结构，大家可以对比一下二者的结构： oldSpec newSpec ","date":"2016-11-21","objectID":"/cocoapods_tips/:1:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"2、File not found with include; use “quoates” instead 在target中手动设置Always Search User Paths为YES，也可以通过pod动态设置（推荐） post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['ALWAYS_SEARCH_USER_PATHS'] = 'YES' end end end ","date":"2016-11-21","objectID":"/cocoapods_tips/:2:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"3、Cannot create __weak reference in file using manual reference counting https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2761 @mdiep 对出现此问题的原因的解释：In Xcode 7.3, __weak causes errors in files compiled as -fno-objc-arc. Since RAC uses __weak, you cannot use it in those files without setting the Weak References in Manual Retain Release setting to YES. If you’re using a .pch that imports RAC, you’re more likely to see this error. 错误样式如下图所示 reactiveCocoa_issue_2761 有3种解决办法： 1）修改源码：把.h文件中报错的__weak标识删除（不能删除.m文件中的，否则会发生内存问题） 2）在引入ReactiveCocoa的地方添加macro判断标识： #if __has_feature(objc_arc) #import \u003cReactiveCocoa/ReactiveCocoa.h\u003e #endif 3）设置工程文件：设置Weak References in Manual Retain Release为YES weak reference in manual ","date":"2016-11-21","objectID":"/cocoapods_tips/:3:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"4、“The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a .swift-version file to set the version for you Pod. For example to use Swift 2.3, run: echo \"2.3\" \u003e .swift-version:” 如下图所示： SwiftVersionError 解决办法： 把pod的引用方式由:git方式改为指定版本号的方式。 ","date":"2016-11-21","objectID":"/cocoapods_tips/:4:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"5、在pod的pch文件中添加引用时，比如 s.prefix_header_contents = '#import \"DDDefine.h\"' 不能添加自己工程中的文件，执行pod lib lint时，它会一直报找不到你想引入的文件的错误。 但是你可以在这里添加其他pod中的文件，或者iOS自己API中的库文件。 ","date":"2016-11-21","objectID":"/cocoapods_tips/:5:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"6、CocoaPods卸载 有的时候不小心把podSpec升级到了1.x 版本，然后pod search就不能用了，然后通过切换分支checkout到v0.32.1，但是pod search还是报错： $ pod search ZDTableView [!] Unable to load a specification for the plugin `/Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-deintegrate-1.0.0.beta.1` ――― MARKDOWN TEMPLATE ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― Command /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/pod search ZDTableView Report * What did you do? * What did you expect to happen? * What happened instead? Stack CocoaPods : 0.38.2 Ruby : ruby 2.2.1p85 (2015-02-26 revision 49769) [x86_64-darwin14] RubyGems : 2.4.8 Host : Mac OS X 10.12.2 (16C67) Xcode : 8.2.1 (8C1002) Git : git version 2.11.0 Ruby lib dir : /Users/fuxianchao/.rvm/rubies/ruby-2.2.1/lib Repositories : cocoapods - https://github.com/CocoaPods/Old-Specs @ 6e256ccc84aad851d401fabb79b2c0f9e09bb875 DDSpec - http://10.255.223.213/ios-code/DDSpec.git @ 941bed4b0c03090e13ecb7ee16a1eafa77969785 master - https://github.com/CocoaPods/Specs.git @ 2d939ca0abb4172b9ef087d784b43e0696109e7c Plugins cocoapods-keys : 1.7.0 cocoapods-playgrounds : 0.1.0 cocoapods-plugins : 0.4.2 cocoapods-search : 1.0.0.beta.1 cocoapods-stats : 0.5.3 cocoapods-trunk : 0.6.4 cocoapods-try : 0.4.5 Error NoMethodError - undefined method `all' for Pod::Platform:Class /Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-search-1.0.0.beta.1/lib/cocoapods-search/command/search.rb:34:in `initialize' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:334:in `new' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:334:in `parse' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:330:in `parse' /Users/fuxianchao/.rvm/gems/ruby-2.2.1@global/gems/claide-0.9.1/lib/claide/command.rb:308:in `run' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-0.38.2/lib/cocoapods/command.rb:48:in `run' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/gems/cocoapods-0.38.2/bin/pod:44:in `\u003ctop (required)\u003e' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/pod:23:in `load' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/pod:23:in `\u003cmain\u003e' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/ruby_executable_hooks:15:in `eval' /Users/fuxianchao/.rvm/gems/ruby-2.2.1/bin/ruby_executable_hooks:15:in `\u003cmain\u003e' ――― TEMPLATE END ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― [!] Oh no, an error occurred. Search for existing GitHub issues similar to yours: https://github.com/CocoaPods/CocoaPods/search?q=undefined+method+%60all%27+for+Pod%3A%3APlatform%3AClass\u0026type=Issues If none exists, create a ticket, with the template displayed above, on: https://github.com/CocoaPods/CocoaPods/issues/new Be sure to first read the contributing guide for details on how to properly submit a ticket: https://github.com/CocoaPods/CocoaPods/blob/master/CONTRIBUTING.md Don't forget to anonymize any private data! 这时候我的做法通常就是卸载pod ，然后重新安装。 $ which pod //得到path $ sudo rm -rf \u003cpath\u003e // 循环遍历卸载pod组件（如果是安装在了用户目录下，那就去掉命令中的sudo） $ for i in `gem list | grep pod | awk '{print $1}'`; do sudo gem uninstall $i; done 有的时候对于新系统直接调用gem install cocoapods 是不行的，提示错误，此种情况就用下面的命令： // 安装指定版本的pod sudo gem install -n /usr/local/bin cocoapods -v 1.2.0 // 卸载 sudo gem uninstall -n /usr/local/bin cocoapods -v 1.2.0 ","date":"2016-11-21","objectID":"/cocoapods_tips/:6:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"7、Library not found for -lAFNetworking 这种情况的解决方案是设置project -\u003e build setting -\u003e library search patchs 里添加 $(inherited) 标识。 ","date":"2016-11-21","objectID":"/cocoapods_tips/:7:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"8、Cannot synthesize weak property because the current deployment target does not support weak refernces refer: http://stackoverflow.com/questions/37160688/set-deployment-target-for-cocoapodss-pod 解决方案： post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if target.name == 'DDKit' config.build_settings['ENABLE_STRICT_OBJC_MSGSEND'] = 'NO' elsif target.name == 'PulsingHalo' config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '9.2' end end end end 或者错误提示为：Cannot synthesize weak property in file using manual reference counting post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if target.name == 'ReactiveCocoa' config.build_settings['CLANG_ENABLE_OBJC_WEAK'] = 'YES' end end end end ","date":"2016-11-21","objectID":"/cocoapods_tips/:8:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"9、Cocoapods debug 我们可以用 pry 来调试 podfile ，即调试 ruby，使用之前先安装 gem install pry 接下来在 podfile 中导入 require 'pry'，然后在你想打断点调试的地方添加一行代码 binding.pry，这样就可以在每次执行pod install or pod update 的时候断在这句代码的位置，我们就可以调试了； ","date":"2016-11-21","objectID":"/cocoapods_tips/:9:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"10、自动添加modulemap的支持 如果我们想以@import的方式引用一个不支持modulemap的repo，那么我们可以让CocoaPods自动生成modulemap，语法如下： pod 'MLFilterKit', '1.9.705', :modular_headers =\u003e true 这个可以解决部分repo中 @import 报错的问题； ","date":"2016-11-21","objectID":"/cocoapods_tips/:10:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"11、为CocoaPods开启增量编译模式： 开启增量编译模式后，post_install、pre_install 中的某些设置会报错，因为工程配置的层级结构发生了变化； install! 'cocoapods', :generate_multiple_pod_projects =\u003e true, :incremental_installation =\u003e true ","date":"2016-11-21","objectID":"/cocoapods_tips/:11:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"12、静态库和动态库共存的设置： # https://www.rubydoc.info/gems/cocoapods/Pod # https://github.com/facebook/flipper/issues/254 # https://github.com/facebook/flipper/blob/master/docs/getting-started.md $dynamic_framework = ['LayoutInspector', 'PromiseKit', 'Yoga', 'YogaKit'] pre_install do |installer| # installer.pod_targets.each do |pod| # if $dynamic_framework.include?(pod.name) # pod.instance_variable_set(:@host_requires_frameworks, true) # end # end Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if not $dynamic_framework.include?(pod.name) def pod.build_type; #Pod::Target::BuildType.static_library Pod::BuildType.static_library end end end end pre_install do |installer| $dynamic_framework = ['RxSwift'] Pod::Installer::Xcode::TargetValidator.send(:define_method,:verify_no_static_framework_transitive_dependencies) {} installer.pod_targets.each do |pod| if $dynamic_framework.include?(pod.name) def pod.build_type; Pod::BuildType.dynamic_framework end end end end ","date":"2016-11-21","objectID":"/cocoapods_tips/:12:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"13、使用Ruby快速设置头文件 https://github.com/mxcl/PromiseKit/blob/6.15.3/PromiseKit.podspec s.subspec 'CorePromise' do |ss| hh = Dir['Sources/*.h'] - Dir['Sources/*+Private.h'] cc = Dir['Sources/*.swift'] - ['Sources/SwiftPM.swift'] cc \u003c\u003c 'Sources/{after,AnyPromise,GlobalState,dispatch_promise,hang,join,PMKPromise,when,race}.m' cc += hh ss.source_files = cc ss.public_header_files = hh ss.preserve_paths = 'Sources/AnyPromise+Private.h', 'Sources/PMKCallVariadicBlock.m', 'Sources/NSMethodSignatureForBlock.m' end ","date":"2016-11-21","objectID":"/cocoapods_tips/:13:0","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["Tips"],"content":"参考： podspec 语法指南 podfile 语法指南 开启 Cocoapods 新选项，加快项目索引速度 Flipper ","date":"2016-11-21","objectID":"/cocoapods_tips/:13:1","tags":["iOS","cocoaPods","tips"],"title":"CocoaPods笔记","uri":"/cocoapods_tips/"},{"categories":["实现原理"],"content":"简析`ReactiveCocoa`中的几个函数","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"简析ReactiveCocoa中的几个函数 ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:0:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"flattenMap 与 map 推荐文章： RAC 核心元素与信号流 细说 ReactiveCocoa 的冷信号与热信号（三）：怎么处理冷信号与热信号 map 和 flatten 是基于 flattenMap, 而 flattenMap 是基于 bind:, 所以在此之前先来看看 bind 函数。 具体来看源码（为方便理解，去掉了源代码中 RACDisposable, @synchronized, @autoreleasepool 相关代码 )。当新信号 N 被外部订阅时，会进入信号 N 的 didSubscribeBlock (1)，之后订阅原信号 O (2)，当原信号 O 有值输出后就用 bind 函数传入的 bindBlock 将其变换成中间信号 M (3), 并马上对其进行订阅 (4)，最后将中间信号 M 的输出作为新信号 N 的输出 (5)。即：当新生成的信号被订阅时，源信号也会立即被订阅。 - (RACSignal *)bind:(RACStreamBindBlock (^)(void))block { return [RACSignal createSignal:^(id\u003cRACSubscriber\u003e subscriber) {// (1) RACStreamBindBlock bindingBlock = block(); // (MARK: 此处执行 block 回调, 生成一个 bindingBlock) [self subscribeNext:^(id x) {// (2) BOOL stop = NO; id middleSignal = bindingBlock(x, \u0026stop); // (3) map 与 flatten 结果不同，问题就出在这里 if (middleSignal != nil) { RACDisposable *disposable = [middleSignal subscribeNext:^(id x) {// (4) [subscriber sendNext:x]; // (5) } error:^(NSError *error) { [subscriber sendError:error]; } completed:^{ [subscriber sendCompleted]; }]; } } error:^(NSError *error) { [subscriber sendError:error]; } completed:^{ [subscriber sendCompleted]; }]; return nil }]; } flattenMap 其实就是对 bind: 方法进行了一些安全检查，它最终返回的是 bindBlock 执行后生成的那个中间 signal 又被订阅后传递出的值的信号，而 map 方法返回的是 bindBlock 的执行结果生成的那个信号，没有再加工处理（即被订阅，再发送值） - (instancetype)flattenMap:(RACStream * (^)(id value))block { Class class = self.class; return [[self bind:^{ /// @return 返回的是 RACStreamBindBlock /// @discussion /// /// 跟 `bind：` 方法中的代码对应起来如下： /// BOOL stop = NO; /// id middleSignal = bindingBlock(x, \u0026stop); /// /// 与上面 `bind:` 函数中的 (3) 对应起来, /// 可以看出 bindBlock 中的 x 是原信号被 subscribe 后传出的值，即对应下面的 value /// 也即 flattenMap block 中执行后传出的值， /// 即上面的 (RACStream * (^ block)(id value)) 中的 value /// flattenMap: 后的那个 block 其实与 bind: 后的 block 基本是一样的，参数都是原信号发出的值，返回值都是 RACStream，差别就是一个 bool 参数，所以说，flattenMap 其实就是对 bind 方法进行了一些安全检查 /// 综上所述：*flattenMap 方法中传进来的那个 block 参数值就是原信号被订阅后发送的值* return ^(id value, BOOL *stop) { // 下面这个 value 并不是 flattenMap 后面 block 中的那个 value（原信号被订阅后发出去的值），而是原信号发出的值被转换为中间信号后，又被订阅后发出去的值。 id stream = block(value) ?: [class empty]; NSCAssert([stream isKindOfClass:RACStream.class], @\"Value returned from -flattenMap: is not a stream: %@\", stream); return stream; }; }] setNameWithFormat:@\"[%@] -flattenMap:\", self.name]; } map: 下面是 map 方法的源码，可以看出，map 只是对 flattenMap 传出的 vaue（即原信号传出的值）进行了 mapBlock 操作，并没有再进行订阅操作，即并不像 bind： 一样再次对原信号进行 bindBlock 后生成的中间信号进行订阅。 - (instancetype)map:(id (^)(id value))block { NSCParameterAssert(block != nil); Class class = self.class; return [[self flattenMap:^(id value) { return [class return:block(value)]; }] setNameWithFormat:@\"[%@] -map:\", self.name]; } flatten: 该操作主要作用于信号的信号。原信号 O 作为信号的信号，在被订阅时输出的数据必然也是个信号 (signalValue)，这往往不是我们想要的。当我们执行 [O flatten] 操作时，因为 flatten 内部调用了 flattenMap (1)，flattenMap 里对应的中间信号就是原信号 O 输出的 signalValue (2)。按照之前分析的经验，在 flattenMap 操作中新信号 N 输出的结果就是各中间信号 M 输出的集合。因此在 flatten 操作中新信号 N 被订阅时输出的值就是原信号 O 的各个子信号输出值的集合。 - (instancetype)flatten { return [self flattenMap:^(RACSignal *signalValue) {// (1) /// 返回值作为 bind: 中的中间信号 return signalValue; // (2) }; } 小结： flatten 与 map 之间的区别：flatten 和 map 后面的 block 返回结果其实最终都会变为 bind: 方法中的中间信号，但是 flatten: 的 block 是直接把原信号发出的值返回来作为中间信号的，所以中间信号被订阅，其实就是原信号发出的值又被订阅，这也就是 flatten: 能拿到信号中的信号中的值的原因。 而 map: 后面的 block 是把原信号发出的值加工处理了的，又生成了一个新的信号，即 map: 方法 block 返回的中间信号已经不是原来的信号中的信号了，而是把原信号发出的值作为它的包含值的一个新的信号，它被订阅时，发送的是原信号发出的那个值，这就是 map 拿不到原信号中的信号的原因。 说白了就是 flatten: 操作的始终是原来的信号，而 map: 会生成一个包含原信号发送值的新信号。 ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:1:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"multicast - (RACMulticastConnection *)multicast:(RACSubject *)subject; 当 RACSignal 类的实例调用 - (RACMulticastConnection *)multicast:(RACSubject *)subject 时，以 self 和 subject 作为构造参数创建一个 RACMulticastConnection 实例。 RACMulticastConnection 构造的时候，保存 source 和 subject 作为成员变量，创建一个 RACSerialDisposable 对象，用于取消订阅。 当 RACMulticastConnection 类的实例调用 - (RACDisposable *)connect 这个方法的时候，判断是否是第一次。如果是的话 用 _signal 这个成员变量（RACSubject 类型）来订阅 sourceSignal， 之后返回 self.serialDisposable，否则直接返回 self.serialDisposable 。 RACMulticastConnection 的 signal 只读属性，就是一个热信号，订阅这个热信号就避免了各种副作用的问题。它会在 - (RACDisposable *)connect 第一次调用后，根据 sourceSignal 的订阅结果来传递事件。 想要确保第一次订阅就能成功订阅 sourceSignal ，可以使用 - (RACSignal *)autoconnect 这个方法，它保证了第一个订阅者触发 sourceSignal 的订阅，也保证了当返回的信号所有订阅者都关闭连接后 sourceSignal 被正确关闭连接。 这里面订阅 sourceSignal 是重点，_signal 是一个 RACSubject 类型，它里面维护着一个可变数组，每当它被订阅时，会把所有的订阅者保存到这个数组中。当 connection.signal（即 _signal）被订阅时，其实是 _signal 被订阅了。由于 _signal 是 RACSubject 类型对象，且 _signal 也是信号，它里面重写了订阅方法，所以会执行它自己的 subscribe: 方法，执行此方法之前订阅者参数是 RACSubscriber 类型，但是在这个 subscribe 方法中，初始化了一个 RACPassthroughSubscriber 实例对象，使它作为新的订阅者（其实就是对订阅者进行了一层包装），并把它存入了 subject 维护的那个订阅者数组里（原来的 订阅者 和 信号 被 RACPassthroughSubscriber 实例保存了），所以数组中最终保存的是 RACPassthroughSubscriber 类型的订阅者，然后它发送消息的时候调的还是它持有的 subject 对象进行发送消息。 当 RACMulticastConnection 调用 connect 方法时，源信号 sourceSignal 被 _signal 订阅，即执行 [sourceSignal subscribe:subject] 方法，然后执行订阅 subscribeNext:block 回调，在回调中执行 sendNext:，由于订阅者是 RACSubject 类型的实例对象，它里面也会执行 sendNext: 方法，此方法中会遍历它的数组中的订阅者依次发送消息。 connect 时订阅者是 RACSubject 发送的 sendNext:，subject 会拿到它那个订阅者数组遍历，取出其中的 RACPassthroughSubscriber 对象，然后用 RACPassthroughSubscriber 对象中的真实的订阅者去发送数据。 ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:2:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"RACCommand 直接上源码: - (id)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal * (^)(id input))signalBlock { NSCParameterAssert(signalBlock != nil); self = [super init]; if (self == nil) return nil; _activeExecutionSignals = [[NSMutableArray alloc] init]; _signalBlock = [signalBlock copy]; // 监听 `activeExecutionSignals` 数组 RACSignal *newActiveExecutionSignals = [[[[[self rac_valuesAndChangesForKeyPath:@keypath(self.activeExecutionSignals) options:NSKeyValueObservingOptionNew observer:nil] reduceEach:^(id _, NSDictionary *change) { NSArray *signals = change[NSKeyValueChangeNewKey]; if (signals == nil) { return [RACSignal empty]; } // 把数组转换为信号发送出去 return [signals.rac_sequence signalWithScheduler:RACScheduler.immediateScheduler]; }] concat] // 把各个信号中的信号连接起来 publish] // 广播出去，可以被多个订阅者订阅 autoconnect]; // 有订阅了再发送广播 // 把上面的信号 `map` 一下, 当出现错误的时候转换成 `empty` 空信号, 并在主线程上传递 _executionSignals = [[[newActiveExecutionSignals map:^(RACSignal *signal) { return [signal catchTo:[RACSignal empty]]; }] deliverOn:RACScheduler.mainThreadScheduler] setNameWithFormat:@\"%@ -executionSignals\", self]; // 先通过 `ignoreValues` 方法屏蔽掉 `sendNext:` 的结果，只保留 `sendError:` 和 `sendCompleted` 结果，然后再通过 `catch:` 方法拿到所有的 `sendError:` 结果，发送给订阅者。 // 此处用的是 `flattenMap`，可以直接获取到错误信息。 RACMulticastConnection *errorsConnection = [[[newActiveExecutionSignals flattenMap:^(RACSignal *signal) { return [[signal ignoreValues] catch:^(NSError *error) { return [RACSignal return:error]; }]; }] deliverOn:RACScheduler.mainThreadScheduler] publish]; _errors = [errorsConnection.signal setNameWithFormat:@\"%@ -errors\", self]; [errorsConnection connect]; // 根据执行信号的数量判断 `RACCommand` 当前是否正在执行 RACSignal *immediateExecuting = [RACObserve(self, activeExecutionSignals) map:^(NSArray *activeSignals) { return @(activeSignals.count \u003e 0); }]; // 是否正在执行 _executing = [[[[[immediateExecuting deliverOn:RACScheduler.mainThreadScheduler] // This is useful before the first value arrives on the main thread. startWith:@NO] distinctUntilChanged] replayLast] setNameWithFormat:@\"%@ -executing\", self]; // 如果允许并发执行，返回 `YES`，否则反转 `immediateExecuting` 信号的结果 RACSignal *moreExecutionsAllowed = [RACSignal if:RACObserve(self, allowsConcurrentExecution) then:[RACSignal return:@YES] else:[immediateExecuting not]]; if (enabledSignal == nil) { enabledSignal = [RACSignal return:@YES]; } else { enabledSignal = [[[enabledSignal startWith:@YES] takeUntil:self.rac_willDeallocSignal] replayLast]; } _immediateEnabled = [[RACSignal combineLatest:@[enabledSignal, moreExecutionsAllowed]] and]; _enabled = [[[[[self.immediateEnabled take:1] concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]] distinctUntilChanged] replayLast] setNameWithFormat:@\"%@ -enabled\", self]; return self; } // 使用时，我们通常会去生成一个 RACCommand 对象，并传入一个返回 signal 对象的 block。每次 RACCommand execute 执行操作时，都会通过传入的这个 signal block 生成一个执行信号 E (1)，并将该信号添加到 RACCommand 内部信号数组 activeExecutionSignals 中 (2)，同时将信号 E 由冷信号转成热信号 (3)，最后订阅该热信号 (4)，并将其返回 (5)。 - (RACSignal *)execute:(id)input { RACSignal *signal = self.signalBlock(input); //（1） RACMulticastConnection *connection = [[signal subscribeOn:RACScheduler.mainThreadScheduler] multicast:[RACReplaySubject subject]]; // (3) @weakify(self); [self addActiveExecutionSignal:connection.signal]; // (2) [connection.signal subscribeError:^(NSError *error) { @strongify(self); [self removeActiveExecutionSignal:connection.signal]; } completed:^{ @strongify(self); [self removeActiveExecutionSignal:connection.signal]; }]; [connection connect]; // (4) return [connection.signal]; // (5) } 接下来再来简单说说 RACCommand 中用到的几个函数 // 以下是对 `allowsConcurrentExecution` 属性的处理方法，利用了属性的原子性，防止资源竞争，值得学习 @property (atomic, assign) BOOL allowsConcurrentExecution; @property (atomic, copy, readonly) NSArray *activeExecutionSignals; { // The mutable array backing `activeExecutionSignals`. // // This should only be used while synchronized on `self`. NSMutableArray *_activeExecutionSignals; // Atomic backing variable for `allowsConcurrentExecut","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:3:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["实现原理"],"content":"推荐 FRPCheatSheeta ","date":"2016-10-01","objectID":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/:4:0","tags":["iOS","reactive"],"title":"ReactiveCocoa部分简析","uri":"/reactivecocoa%E9%83%A8%E5%88%86%E7%AE%80%E6%9E%90/"},{"categories":["学习笔记"],"content":"函数 结构体和枚举是值类型，默认情况下，值类型的属性不能在它的实例方法中被修改，但是如果你确实需要在某个具体的方法中修改结构体或者枚举的属性，可以在方法func前添加mutating关键字，然后就可以修改它的属性了，并且它做的任何改变在方法结束时还会保留在原始结构体中。 方法与函数的区别：方法是与某些特定类型相关联的函数，即方法就是函数，只是这个函数与某个类型相关联罢了。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"闭包 闭包表达式语法： { (parameters) -\u003e returnType in statements //函数体 } 闭包表达式参数可以是 in-out 参数，但是不能设置默认值；也可以使用具名的可变参数（译者注：可变参数需要放在参数列表最后，因为如果可变参数不放在参数列表的最后一位的话，调用闭包的时候编译器将报错）；元组也可以作为参数返回。 类型推断：因为所有的类型都可以被正确推断，此时，闭包中的返回箭头（-\u003e）和围绕在参数周围的括号可以被省略: reversedName = names.sorted(by: { s1, s2 in return s1 \u003e s2 }) 单表达式闭包隐式返回(闭包隐式返回单行表达式)：单行表达式可以通过省略return关键字来隐式返回当行表达式的结果，如sort函数的例子可以改写为: reversedName = names.sorted(by: { s1, s2 in s1 \u003e s2 }) 参数名称缩写：如果你在闭包表达式中使用参数名称缩写，那么你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过参数类型自行进行推断出来。in关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成： reversedName = names.sorted(by: { $0 \u003e $1 }) 运算符方法：Swift的String类型定义了关于大于号\u003e的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值： reversedName = names.sorted(by: \u003e ) 尾随闭包：如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数时，可以使用 尾随闭包 来增强函数可读性。 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用，在使用尾随闭包时，你不用写出他的参数标签： func someFunctionThatTakesAClosure(closure: () -\u003e Void) { // 函数体部分 } // 以下是没有用尾随闭包进行函数调用 someFunctionThatTakesAClosure(closure: { // 闭包主体部分 }) // 以下是使用尾随闭包进行函数调用，省略掉了参数标签 `closure` someFunctionThatTakesAClosure() { // 闭包主体部分 } 所以sorted(by:)方法的参数字符串排序闭包可以改写为： reversedName = names.sorted() { $0 \u003e $1 } 如果闭包表达式是函数或者方法的唯一参数，则当你使用尾随闭包时，甚至可以把()省略掉： // 去掉小括号 reversedName = names.sorted { $0 \u003e $1 } 当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当 你定义接受闭包作为参数的函数时，你可以在参数名之前标注@escaping，用来指明这个闭包是允许“逃逸”出 这个函数的。将一个闭包标记为 @escaping 意味着你必须在闭包中显示的引用 self 。 自动闭包： 自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。自动闭包不接受任何参数(e.g. () -\u003e T )，当它被调用的时候，会返回被包装在其中的表达式的值，这种便利语法让你能够省略闭包的花括号，用一个普通的表达式 来代替显式的闭包。 // customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"] func serve(customer customerProvider: @autoclosure () -\u003e String) { print(\"Now serving \\(customerProvider())!\") } serve(customer: customersInLine.remove(at: 0)) // 打印 \"Now serving Ewa!\" @autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -\u003e T 的参数才能简化。 通过将参数标记为 @autoclosure 来接收一个自动闭包。**现在你可以将该函数当作接受 String 类型参数（而非闭包） 的函数来调用，也就是上面看到的serve(customer: \"string\")，可以直接传递字符串参数，而不是闭包或函数，因为Swift将会把参数 \"string\" 自动转换为 () -\u003e String。 customerProvider 参数将自动转化为一个闭包，因为该参数被标记了 @autoclosure 特性。 @autoclosure 和 ?? @autoclosure what, why and when {}() : 通过闭包或函数设置属性的默认值： 如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。 这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最 后返回这个临时变量，作为属性的默认值。 class SomeClass { let someProperty: SomeType = { // 在这个闭包中给 someProperty 创建一个默认值 // someValue 必须和 SomeType 类型相同 return someValue }() } 注意 注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括 号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。 如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包 里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 self 属性，或者调用任何实例方法。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"枚举 关联值： 可以在定义Swift枚举来存储任意类型的关联值，每个枚举成员的关联值类型可以各不相同； enum Barcode { case upc(Int, Int, Int, Int) case qrCode(String) } 原始值的隐式赋值： 在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为 你赋值。例如使用整数作为原始值时，其默认原始值为0，然后一次递增；当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。 使用枚举成员的rawValue属性可以访问该枚举成员的原始值。 使用原始值初始化枚举实例： 如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型极为原始值类型，返回值则是枚举成员或nil。因为并非所有的值都能匹配到枚举值，所以，原始值欧股早起总是返回一个可选的枚举成员。 递归枚举： 可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的； indirect enum ArithmeticExpression { case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression) } ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"类 \u0026 结构体 Swift允许直接设置结构体属性的子属性； 所有的结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器中： let vga = Resolution(width:640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。 注意: 以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回 避赋值来保证性能最优化。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"属性 计算属性不直接存储值，而是提供一个getter和一个可选的setter来间接获取和设置其他属性或变量的值。计算属性可以用于类、结构体和枚举，而存储属性只能用于类和结构体，不能用于枚举。 常量结构体的存储属性：如果创建了一个结构体的实例并将其复制给一个常量，则无法修改该实例的任何属性，即使有属性被声明成变量也不行。这种行为是由于结构体属于值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。属于引用类型的类则不一样，把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。 延迟存储属性： 在属性声明前使用lazy来标示一个延迟存储属性。 必须将延迟存储属性声明为变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到，而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。 如果一个被标记为lazy的属性在没有初始化时就被多个线程访问，则无法保证该属性只会被初始化一次。 Swift中的数信没有对应的实例变量，属性的后端存储也无法直接访问。 计算属性：类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个getter和一个可选的setter，来间接获取和设置其他属性或变量的值。 如果计算属性的setter没有定义新值的参数，则可以使用默认名称newValue。 必须使用var关键字定义计算属性，包括只读计算属性， 因为他们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值。 只读计算属性的声明可以去掉get关键字和花括号。 可以为属性添加如下的一个或全部观察器： willSet 在新的值被设置之前调用; didSet 在新的值被设置之后立即调用; willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。 同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet方法中再次对该属性赋值，那么新值会覆盖旧的值。 我们可以为除了延迟计算属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式 为继承的属性（包括存储属性和计算属性）添加属性观察器。 不需要为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。 如果在一个属性的didSet观察器里为它赋值，这个值会替换该观察器之前设置的值。 父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。 class StepCounter { var totalSteps: Int = 0 { willSet(newTotalSteps) { print(\"About to set totalSteps to \\(newTotalSteps)\") } didSet { if totalSteps \u003e oldValue { print(\"Added \\(totalSteps - oldValue) steps\") } } } } let stepCounter = StepCounter() stepCounter.totalSteps = 200 // About to set totalSteps to 200 // Added 200 steps stepCounter.totalSteps = 360 // About to set totalSteps to 360 // Added 160 steps stepCounter.totalSteps = 896 // About to set totalSteps to 896 // Added 536 steps StepCounter 类定义了一个 Int 类型的属性 totalSteps，它是一个存储属性，包含 willSet 和 didSet 观察器。 当 totalSteps 被设置新值的时候，它的 willSet 和 didSet 观察器都会被调用，即使新值和当前值完全相同时也会被调用。 例子中的 willSet 观察器将表示新值的参数自定义为 newTotalSteps，这个观察器只是简单的将新的值输出。 didSet 观察器在 totalSteps 的值改变后被调用，它把新值和旧值进行对比，如果总步数增加了，就输出一个消息表示增加了多少步。didSet 没有为旧值提供自定义名称，所以默认值 oldValue 表示旧值的参数名。 如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。 全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。 类型属性是用static关键字修饰的，但是如果想让子类支持重写父类方法实现，需要把static改为class，但是class只支持类（协议中好像也可以用），不支持结构体和枚举。 struct SomeStructure { static var storedTypeProperty = \"Some value.\" static var computedTypeProperty: Int { return 1 } } enum SomeEnumeration { static var storedTypeProperty = \"Some value.\" static var computedTypeProperty: Int { return 6 } } class SomeClass { static var storedTypeProperty = \"Some value.\" static var computedTypeProperty: Int { return 27 } class var overrideableComputedTypeProperty: Int { return 107 } } 存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用lazy修饰符。 值类型（结构体和枚举）不支持继承。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"方法 方法是与某些特定类型相关联的函数。 如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。 要使用可变方法，将关键字mutating 放到方法的func关键字之前就可以了。 不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性。 类型方法： 可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字static，来指定类型方法。类还可以用关键字class来允许子类重写父类的方法实现。在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"覆写 覆写：你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供getter和setter即可，但是，不能将一个继承来的可读写属性重写为一个只读属性。如果你在重写属性中提供了setter，那么你也一定要提供getter。 重写属性观察器：你不可以为继承来的常量存储属性或者继承来的只读计算属性添加属性观察器。这些属性的值是不可以被设置的，所以，为他们提供willSet和didSet 实现是不恰当的。此外还要注意，你不可以同时提供重写的setter和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的setter，那么你在setter中就可以观察到任何变化了。 你可以通过把方法，属性或下标标记为 final 来防止它们被重写，只需要在声明关键字前加上 final 修饰符即可（例如： final var ， final func ， final class func ，以及 final subscript ）。你可以通过在关键字 class 前添加 final 修饰符来将整个类标记为 final 的。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"构造过程 与Objective-C中的构造器不同的是：Swift的构造器无需返回值，他们的主要任务是保证新实例在第一次使用前完成正确的初始化。 当你为存储型属性设置默认值或者在构造器中为其赋值时，他们的值是被直接设置的，不会触发任何属性观察者。 构造过程中常量属性可以修改：对于类的实例来说，它的常量属性只能在 定义它的类 的构造过程中 修改，不能在子类中修改。 比如： // 修改上面的 SurveyQuestion 示例，用常量属性替代变量属性 text ，表示问题内容 text 在 SurveyQuestio n 的实例被创建之后不会再被修改。尽管 text 属性现在是常量，我们仍然可以在类的构造器中设置它的值： class SurveyQuestion { let text: String //常量属性 var response: String? init(text: String) { self.text = text } func ask() { print(text) } } let beetsQuestion = SurveyQuestion(text: \"How about beets?\") beetsQuestion.ask() // 打印 \"How about beets?\" beetsQuestion.response = \"I also like beets. (But not with cheese.)\" 默认构造器：如果 结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。 结构体的逐一成员构造器（结构体特有的）：除了默认构造器，如果结构体没有提供自定义的构造器，他们将自动获得一个逐一成员构造器，即使结构体的存储属性没有默认值。 值类型的构造器代理：对于值类型，你可以使用self.init在自定义的构造器中使用相同类型中的其它构造器，并且你只能在构造器内部调用self.init。如果你为了某个值类型定义了一个自定义构造器，你将无法访问默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后，仍有人错误的使用自动生成的构造器。假如你希望默认构造器、逐一成员构造器以及你自己定义的构造器都能用来创建实例，你可以将自定义的构造器写到扩展（extension）里面，而不是卸载值类型的原始定义中。 指定构造器是类中最重要的构造器。每一个类都必须拥有至少一个指定构造器。 //指定构造器 init(parameters) { statements } //便利构造器（在`init`前放置 `convenience` 关键字） convenience init(parameters) { statements } 类的构造器代理规则： \u003e 为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用： \u003e \u003e 规则 1 指定构造器必须调用其直接父类的的指定构造器。 \u003e \u003e 规则 2 便利构造器必须调用同类中（即自己类里面）定义的其它构造器。 \u003e \u003e 规则 3 便利构造器必须最终导致一个指定构造器被调用。 \u003e \u003e 一个更方便记忆的方法是： • 指定构造器必须总是向上代理 • 便利构造器必须总是横向代理 两段式构造过程：Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存 储型属性。 两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过 程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。 构造过程的安全检查（重要）： \u003e Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成： \u003e \u003e 安全检查 1: 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中 的构造器。 \u003e \u003e 如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器 必须保证它所在类引入的属性在它往上代理之前先完成初始化。 \u003e \u003e 安全检查 2: 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的 新值将被父类中的构造器所覆盖。 \u003e \u003e 安全检查 3: 便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。 \u003e \u003e 安全检查 4: 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self作为一个值。 \u003e \u003e 类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性 和调用方法。 以下是两段式构造过程中基于上述安全检查的构造流程展示： \u003e 阶段 1： \u003e \u003e - 某个指定构造器或便利构造器被调用。 \u003e \u003e - 完成新实例内存的分配，但此时内存还没有被初始化。 \u003e \u003e - 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。 \u003e \u003e - 指定构造器将调用父类的构造器，完成父类属性的初始化。 \u003e \u003e - 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。 \u003e \u003e - 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完 全初始化。此时阶段 1 完成。 \u003e \u003e 阶段2： \u003e \u003e - 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问 `self` 、修改它的属性并调用实例方法等等。 \u003e \u003e - 最终，任意构造器链中的便利构造器可以有机会定制实例和使用 `self `。 Swift中的子类默认情况下不会继承父类的构造器，父类的构造器仅会在安全和适当的情况下被继承。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"协议 类类型专属协议： 你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体和枚举不能遵循该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前： protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol { // 这里是类类型专属协议的定义部分 } 当协议定义的要求需要遵循协议的类型必须是引用予以而非值语义时，应该采用类类型专属协议。 协议合成： 同时采纳多个协议,多个协议之间用 \u0026 分隔.协议的合成并不会生成新的协议类型,只是一个临时局部的。 protocol Name { var name: String { get } } protocol Age { var age: Int { get } } struct People: Name, Age { // 遵守name age这两个协议 var name: String var age: Int } // 参数支持多个协议的话，协议之间用`\u0026`分隔开 func say(to people: Name \u0026 Age) { // 参数类型:Name \u0026 Age print(\"This is \\(people.name), age is \\(people.age)\") // This is Joan, age is 20 } let p = People(name: \"Joan\", age: 20) say(to: p) // 只要遵守这两个协议的对象都能被传进去 可选的协议前面需要加 @objc 关键字。@objc : 表示该协议暴露给OC代码，但即使不与OC交互只想实现可选协议要求，还是要加@objc关键字。带有@objc关键字的协议只能被OC类，或者带有@objc关键字的类遵守，结构体和枚举都不能遵守。 @objc protocol CounterDataSource { // 用于计数的数据源 @objc optional var fixAdd: Int { get } // 可选属性 @objc optional func addForCount(count: Int) -\u003e Int // 可选方法,用于增加数值 } class Counter: CounterDataSource { var count = 0 // 用来存储当前值 var dataSource: CounterDataSource? func add() { // 增加count值 // 使用可选绑定和两层可选链式调用来调用可选方法 if let amount = dataSource?.addForCount?(count: count) { count += amount }else if let amount = dataSource?.fixAdd { count += amount } } } class ThreeSource: NSObject, CounterDataSource { let fixAdd = 3 } var counter = Counter() counter.dataSource = ThreeSource() // 将counter的数据源设置为ThreeSource counter.add() // 增加3 counter.add() // 增加3 print(counter.count) // 6 协议扩展： 协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改。 提供默认实现： 可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。 如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。 通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。 协议扩展和提供的默认实现，可以实现多继承的效果。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"运算符 要实现前缀或者后缀运算符，需要在声明运算符函数的时候在func关键字之前指定prefix或者postfix修饰符。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"解惑 1. lazy修饰的实例为什么不能用lazy let？ 在 Swift 里你不能创建 lazy let 实例属性，这是由 lazy 的具体实现细节决定的：它在没有值的情况下以某种方式被初始化，然后在被访问时改变自己的值，这就要求该属性是可变的。因此无法实现一个使用时才会被计算的常量。 既然说到了let，顺便说一条比较有意思的特性： 被声明在全局作用域下 或者 被声明为一个类型属性（即声明为static let）的常量，是自动具有惰性(lazy)的，而且还是线程安全的。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"重要概念 写时复制: Swift 中的“写时复制”是指，值类型只在被改动前进行复制。传统意义上的值类型会在被传递或者被赋值给其他变量时就发生复制行为，但是这将会带来极大的，也是不必要的性能损耗。写时复制将在值被传递和赋值给变量时首先检查其引用计数，如果引用计数为 1 (唯一引用)，那么意味着并没有其他变量持有该值，对当前值的复制也就可以完全避免，以此在保持值类型不可变性的优良特性的同时，保证使用效率。Swift 中像是 Array 和 Dictionary 这样的类型都是值类型，但是底层实现确是引用类型，它们都利用了写时复制的技术来保证效率。 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"备注 以上内容全部摘自The Swift Programming Language 中文版 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"资料 Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad “懒”点儿好 Swift2.0：理解flatMap 谈谈 Swift 中的 map 和 FlatMap 第二篇 - 另一层思维方式 Swift中枚举高级用法与实践 Unowned 还是 Weak？生命周期和性能对比 所有权宣言 - Swift 官方文章 Ownership Manifesto 译文评注版 ","date":"2016-03-01","objectID":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["iOS","swift"],"title":"Swift学习笔记","uri":"/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]